{"version":3,"sources":["webpack:///app.js","webpack:///webpack/bootstrap 26a4502983c84f9af9cd","webpack:///./app.js","webpack:///./libs/tools.js","webpack:///../~/angular-cookies/angular-cookies.js","webpack:///../~/angular-cookies/index.js","webpack:///../~/angular-md5/angular-md5.js","webpack:///../~/angular-resource/angular-resource.js","webpack:///../~/angular-resource/index.js","webpack:///../~/angular-ui-router/release/angular-ui-router.js","webpack:///./controllers/todoController.js","webpack:///./controllers/userController.js","webpack:///./libs/consts.js","webpack:///./models/todoModel.js","webpack:///./models/userModel.js","webpack:///./router.js","webpack:///../~/path-browserify/index.js","webpack:///../~/process/browser.js"],"names":["modules","hotDownloadUpdateChunk","chunkId","head","document","getElementsByTagName","script","createElement","type","charset","src","__webpack_require__","p","hotCurrentHash","appendChild","hotDownloadManifest","callback","XMLHttpRequest","Error","request","requestPath","open","timeout","send","err","onreadystatechange","readyState","status","update","JSON","parse","responseText","e","hotCreateRequire","moduleId","ensure","hotStatus","hotSetStatus","hotChunksLoading","finishChunkLoading","hotWaitingFilesMap","hotEnsureUpdateChunk","hotWaitingFiles","hotUpdateDownloaded","call","fn","me","installedModules","hot","active","parents","indexOf","push","children","hotCurrentParents","console","warn","name","Object","prototype","hasOwnProperty","canDefineProperty","defineProperty","configurable","enumerable","get","set","value","hotCreateModule","_acceptedDependencies","_declinedDependencies","_selfAccepted","_selfDeclined","_disposeHandlers","accept","dep","i","length","decline","dispose","addDisposeHandler","removeDisposeHandler","idx","splice","check","hotCheck","apply","hotApply","l","hotStatusHandlers","addStatusHandler","removeStatusHandler","data","hotCurrentModuleData","newStatus","toModuleId","id","isNumber","hotApplyOnUpdate","hotRequestedFilesMap","hotAvailibleFilesMap","c","hotUpdateNewHash","h","hotCallback","hotUpdate","hotAddUpdateChunk","moreModules","outdatedModules","options","getAffectedStuff","module","outdatedDependencies","queue","slice","pop","parentId","parent","addAllToSet","a","b","item","appliedUpdate","result","ignoreUnaccepted","outdatedSelfAcceptedModules","errorHandler","disposeHandlers","j","cb","child","moduleOutdatedDependencies","dependency","error","callbacks","exports","loaded","parentHotUpdateCallback","this","webpackHotUpdate","x","m","app","angular","config","$resourceProvider","defaults","actions","method","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","_path","_path2","_app","_app2","factory","$http","$window","$cookies","tools","apiUrl","url","join","userInfo","userid","localStorage","getItem","parseInt","userName","lastLogin","unfinishNum","save","setItem","user_name","last_login","unfinish_num","isLogin","window","$$CookieWriter","$document","$log","$browser","buildCookieString","path","expires","isDefined","cookiePath","isUndefined","isString","Date","str","encodeURIComponent","domain","toUTCString","secure","cookieLength","baseHref","rawDocument","cookie","provider","calcOptions","extend","$get","$$cookieReader","$$cookieWriter","key","getObject","fromJson","getAll","put","putObject","toJson","remove","undefined","$inject","filter","md5","cache","text","defaultText","createHash","toString","toLowerCase","xl","k","AA","BB","CC","DD","d","rotateLeft","lValue","iShiftBits","addUnsigned","lX","lY","lX4","lY4","lX8","lY8","lResult","_F","y","z","_G","_H","_I","_FF","s","ac","_GG","_HH","_II","convertToWordArray","lWordCount","lMessageLength","lNumberOfWords_temp1","lNumberOfWords_temp2","lNumberOfWords","lWordArray","Array","lBytePosition","lByteCount","charCodeAt","wordToHex","lByte","lCount","wordToHexValue","wordToHexValue_temp","substr","S11","S12","S13","S14","S21","S22","S23","S24","S31","S32","S33","S34","S41","S42","S43","S44","temp","isValidDottedPath","MEMBER_NAME_REGEX","test","lookupDottedPath","$resourceMinErr","keys","split","ii","shallowClearAndCopy","dst","forEach","charAt","$$minErr","PROTOCOL_AND_DOMAIN_REGEX","stripTrailingSlashes","query","isArray","delete","$q","$timeout","encodeUriSegment","val","encodeUriQuery","replace","pctEncodeSpaces","Route","template","urlParams","resourceFactory","paramDefaults","extractParams","actionParams","ids","isFunction","defaultResponseInterceptor","response","resource","Resource","route","toJSON","$promise","$resolved","action","hasBody","numericTimeout","cancellable","debug","a1","a2","a3","a4","success","params","arguments","timeoutDeferred","numericTimeoutPromise","isInstanceCall","httpConfig","responseInterceptor","interceptor","responseErrorInterceptor","responseError","copy","defer","promise","resolve","setUrlParams","then","noop","reject","$cancelRequest","cancel","headers","bind","additionalParamDefaults","actionUrl","encodedVal","self","protocolAndDomain","param","RegExp","isQueryParamValue","match","paramInfo","urlParam","p1","leadingSlashes","tail","inherit","extra","merge","ancestors","first","second","n","objectKeys","object","array","Number","len","from","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","inherited","inheritList","equalForKeys","filterByKeys","values","filtered","pick","concat","omit","collection","map","$Resolve","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","study","invocables","visit","visited","cycle","plan","annotate","isResolve","isObject","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","fail","reason","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","promises","$TemplateFactory","$templateCache","fromConfig","fromString","templateUrl","fromUrl","templateProvider","fromProvider","Accept","UrlMatcher","pattern","parentMatcher","addParameter","location","paramNames","$$UMFP","Param","quoteRegExp","string","squash","optional","surroundPattern","matchDetails","isSearch","regexp","segment","cfg","substring","last","index","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","exec","isOptional","lastIndex","search","sourceSearch","sourcePath","strict","prefix","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","shift","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","bool","date","getFullYear","getMonth","getDate","capture","isNaN","valueOf","equals","toISOString","json","any","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","to","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","chain","ignore","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$rootScope","$sniffer","appendBasePath","isHtml5","absolute","evt","rule","handled","defaultPrevented","lastPushedUrl","rules","otherwise","listen","listener","$on","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","enabled","history","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","global","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","current","state","states","queueState","parentName","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","$state","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","unshift","MAX_VALUE","decorator","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","controller","$$state","$$controllerAs","controllerAs","$$resolveAs","resolveAs","all","TransitionPrevented","root","reload","go","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","includes","lossy","nav","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","","abstract","$ViewProvider","$templateFactory","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","$interpolate","getService","has","service","getRenderer","attrs","scope","statics","enter","element","target","after","leave","$animate","version","minor","$animator","animate","directive","restrict","terminal","priority","transclude","tElement","tAttrs","$transclude","cleanupLastView","previousEl","currentScope","$destroy","currentEl","$uiViewData","renderer","$$animLeave","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","$emit","clone","animEnter","animLeave","viewData","$animEnter","$animLeave","autoScrollExp","$eval","onloadExp","onload","autoscroll","inheritedData","$ViewDirectiveFill","$compile","$controller","initial","html","resolveData","link","contents","$scope","$onInit","uiView","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","el","stateData","getTypeInfo","isSvg","prop","isForm","nodeName","attr","isAnchor","toUpperCase","clickable","clickHook","button","which","ctrlKey","metaKey","shiftKey","preventDefault","ignorePreventDefaultCount","defaultOpts","$StateRefDirective","require","uiSrefActive","hookFn","uiSref","unlinkInfoFn","uiSrefOpts","$$addStateInfo","$set","$watch","unbind","$StateRefDynamicDirective","runStateRefLink","group","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","$attrs","addState","stateParams","activeClass","stateHash","createStateHash","stateInfo","activeClasses","anyMatch","addClass","removeClass","exactMatch","activeEqClass","className","uiSrefActiveEq","newState","deregister","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","run","constant","autoinject","todoTools","todoModel","todoConsts","todoList","filterList","todoNum","title","newTodo","initNewTodo","todo_name","DEFAULT_TODONAME","categoryid","DEFAULT_CATEGORYID","DEFAULT_TODOSTATUS","remark","todoStatusCateogries","TODO_CATEGORYLIST","currentStatus","loading","validate","msg","start_time","end_time","fetchList","list","filterStatusList","getDetail","todoid","detail","errMsg","errmsg","errcode","alert","directToDetail","saveTodo","startTimeStamp","endTimestamp","insert","resp","updateStatus","log","todoItem","find","deleteTodo","confirm","timestampToDate","timestamp","dateObj","userModel","create_time","userLoginInfo","password","login","loginInfo","consts","$resource","$stateProvider","publicUrls","event","fromState","previousState","process","normalizeArray","parts","allowAboveRoot","up","xs","f","res","splitPathRe","splitPath","filename","resolvedPath","resolvedAbsolute","cwd","TypeError","normalize","isAbsolute","trailingSlash","paths","trim","arr","start","end","fromParts","toParts","min","samePartsLength","outputParts","sep","delimiter","dirname","dir","basename","ext","extname","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","setTimeout","clearTimeout","Item","fun","nextTick","args","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","chdir","umask"],"mappings":"CAAS,SAAUA,GCOnB,QAAAC,GAAAC,GACA,GAAAC,GAAAC,SAAAC,qBAAA,WACAC,EAAAF,SAAAG,cAAA,SACAD,GAAAE,KAAA,kBACAF,EAAAG,QAAA,QACAH,EAAAI,IAAAC,EAAAC,EAAA,GAAAV,EAAA,IAAAW,EAAA,iBACAV,EAAAW,YAAAR,GAGA,QAAAS,GAAAC,GACA,sBAAAC,gBACA,MAAAD,GAAA,GAAAE,OAAA,sBACA,KACA,GAAAC,GAAA,GAAAF,gBACAG,EAAAT,EAAAC,EAAA,GAAAC,EAAA,kBACAM,GAAAE,KAAA,MAAAD,MACAD,EAAAG,QAAA,IACAH,EAAAI,KAAA,MACI,MAAAC,GACJ,MAAAR,GAAAQ,GAEAL,EAAAM,mBAAA,WACA,OAAAN,EAAAO,WACA,OAAAP,EAAAQ,OAEAX,EAAA,GAAAE,OAAA,uBAAAE,EAAA,oBACK,UAAAD,EAAAQ,OAELX,QACK,UAAAG,EAAAQ,QAAA,MAAAR,EAAAQ,OAELX,EAAA,GAAAE,OAAA,uBAAAE,EAAA,iBACK,CAEL,IACA,GAAAQ,GAAAC,KAAAC,MAAAX,EAAAY,cACM,MAAAC,GAEN,WADAhB,GAAAgB,GAGAhB,EAAA,KAAAY,KAuBA,QAAAK,GAAAC,GAsCA,QAAAC,GAAAjC,EAAAc,GACA,UAAAoB,GACAC,EAAA,WACAC,IACA3B,EAAAqB,EAAA9B,EAAA,WAOA,QAAAqC,KACAD,IACA,YAAAF,IACAI,EAAAtC,IACAuC,EAAAvC,GAEA,IAAAoC,GAAA,IAAAI,GACAC,KAbA,IACA3B,EAAA4B,KAAA,KAAAC,GACM,QACNN,OA7CA,GAAAO,GAAAC,EAAAb,EACA,KAAAY,EAAA,MAAAnC,EACA,IAAAkC,GAAA,SAAA1B,GAYA,MAXA2B,GAAAE,IAAAC,OACAF,EAAA5B,IACA4B,EAAA5B,GAAA+B,QAAAC,QAAAjB,GAAA,GACAa,EAAA5B,GAAA+B,QAAAE,KAAAlB,GACAY,EAAAO,SAAAF,QAAAhC,GAAA,GACA2B,EAAAO,SAAAD,KAAAjC,IACMmC,GAAApB,IAENqB,QAAAC,KAAA,4BAAArC,EAAA,0BAAAe,GACAoB,MAEA3C,EAAAQ,GAEA,QAAAsC,KAAA9C,GACA+C,OAAAC,UAAAC,eAAAhB,KAAAjC,EAAA8C,KACAI,EACAH,OAAAI,eAAAjB,EAAAY,EAAA,SAAAA,GACA,OACAM,gBACAC,cACAC,IAAA,WACA,MAAAtD,GAAA8C,IAEAS,IAAA,SAAAC,GACAxD,EAAA8C,GAAAU,KAGOV,IAEPZ,EAAAY,GAAA9C,EAAA8C,GAqCA,OARAI,GACAH,OAAAI,eAAAjB,EAAA,KACAmB,cACAG,MAAAhC,IAGAU,EAAAb,EAAAG,EAEAU,EAGA,QAAAuB,GAAAlC,GACA,GAAAc,IAEAqB,yBACAC,yBACAC,iBACAC,iBACAC,oBAGAxB,UACAyB,OAAA,SAAAC,EAAA3D,GACA,sBAAA2D,GACA3B,EAAAuB,qBACA,sBAAAI,GACA3B,EAAAuB,cAAAI,MACA,oBAAAA,GACA,OAAAC,GAAA,EAAoBA,EAAAD,EAAAE,OAAgBD,IACpC5B,EAAAqB,sBAAAM,EAAAC,IAAA5D,MAEAgC,GAAAqB,sBAAAM,GAAA3D,GAEA8D,QAAA,SAAAH,GACA,sBAAAA,GACA3B,EAAAwB,qBACA,oBAAAG,GACA3B,EAAAsB,sBAAAK,UAEA,QAAAC,GAAA,EAAoBA,EAAAD,EAAAE,OAAgBD,IACpC5B,EAAAsB,sBAAAK,EAAAC,QAEAG,QAAA,SAAA/D,GACAgC,EAAAyB,iBAAArB,KAAApC,IAEAgE,kBAAA,SAAAhE,GACAgC,EAAAyB,iBAAArB,KAAApC,IAEAiE,qBAAA,SAAAjE,GACA,GAAAkE,GAAAlC,EAAAyB,iBAAAtB,QAAAnC,EACAkE,IAAA,GAAAlC,EAAAyB,iBAAAU,OAAAD,EAAA,IAIAE,MAAAC,EACAC,MAAAC,EACA5D,OAAA,SAAA6D,GACA,MAAAA,OACAC,GAAArC,KAAAoC,GADApD,GAGAsD,iBAAA,SAAAF,GACAC,EAAArC,KAAAoC,IAEAG,oBAAA,SAAAH,GACA,GAAAN,GAAAO,EAAAtC,QAAAqC,EACAN,IAAA,GAAAO,EAAAN,OAAAD,EAAA,IAIAU,KAAAC,EAAA3D,GAEA,OAAAc,GAMA,QAAAX,GAAAyD,GACA1D,EAAA0D,CACA,QAAAlB,GAAA,EAAiBA,EAAAa,EAAAZ,OAA8BD,IAC/Ca,EAAAb,GAAAhC,KAAA,KAAAkD,GAcA,QAAAC,GAAAC,GACA,GAAAC,IAAAD,EAAA,KAAAA,CACA,OAAAC,IAAAD,IAGA,QAAAX,GAAAC,EAAAtE,GACA,YAAAoB,EAAA,SAAAlB,OAAA,yCACA,mBAAAoE,IACAY,KACAlF,EAAAsE,IAEAY,EAAAZ,EACAtE,KAAA,SAAAQ,GACA,GAAAA,EAAA,KAAAA,KAGAa,EAAA,SACAtB,EAAA,SAAAS,EAAAI,GACA,GAAAJ,EAAA,MAAAR,GAAAQ,EACA,KAAAI,EAGA,MAFAS,GAAA,YACArB,GAAA,UAIAmF,MACAC,KACA5D,IACA,QAAAoC,GAAA,EAAkBA,EAAAhD,EAAAyE,EAAAxB,OAAqBD,IACvCwB,EAAAxE,EAAAyE,EAAAzB,MACA0B,GAAA1E,EAAA2E,EAEAlE,EAAA,WACAmE,EAAAxF,EACAyF,IACA,IAAAvG,GAAA,CAGAuC,GAAAvC,GAEA,YAAAkC,GAAA,IAAAE,GAAA,IAAAI,GACAC,MAKA,QAAA+D,GAAAxG,EAAAyG,GACA,GAAAP,EAAAlG,IAAAiG,EAAAjG,GAAA,CAEAiG,EAAAjG,KACA,QAAAgC,KAAAyE,GACAjD,OAAAC,UAAAC,eAAAhB,KAAA+D,EAAAzE,KACAuE,EAAAvE,GAAAyE,EAAAzE,GAGA,OAAAQ,GAAA,IAAAJ,GACAK,KAIA,QAAAF,GAAAvC,GACAkG,EAAAlG,IAGAiG,EAAAjG,MACAwC,IACAzC,EAAAC,IAJAsC,EAAAtC,MAQA,QAAAyC,KACAN,EAAA,QACA,IAAArB,GAAAwF,CAEA,IADAA,EAAA,KACAxF,EACA,GAAAkF,EACAX,EAAAW,EAAAlF,OACI,CACJ,GAAA4F,KACA,QAAAZ,KAAAS,GACA/C,OAAAC,UAAAC,eAAAhB,KAAA6D,EAAAT,IACAY,EAAAxD,KAAA2C,EAAAC,GAGAhF,GAAA,KAAA4F,IAIA,QAAArB,GAAAsB,EAAA7F,GAgBA,QAAA8F,GAAAC,GAKA,IAJA,GAAAH,IAAAG,GACAC,KAEAC,EAAAL,EAAAM,QACAD,EAAApC,OAAA,IACA,GAAA3C,GAAA+E,EAAAE,MACAJ,EAAAhE,EAAAb,EACA,IAAA6E,MAAA/D,IAAAuB,cAAA,CAEA,GAAAwC,EAAA/D,IAAAwB,cACA,UAAAtD,OAAA,oCAAAgB,EAEA,QAAAA,EACA,MAEA,QAAA0C,GAAA,EAAmBA,EAAAmC,EAAA7D,QAAA2B,OAA2BD,IAAA,CAC9C,GAAAwC,GAAAL,EAAA7D,QAAA0B,GACAyC,EAAAtE,EAAAqE,EACA,IAAAC,EAAArE,IAAAsB,sBAAApC,GACA,UAAAhB,OAAA,2CAAAgB,EAAA,OAAAkF,EAEAR,GAAAzD,QAAAiE,IAAA,IACAC,EAAArE,IAAAqB,sBAAAnC,IACA8E,EAAAI,KACAJ,EAAAI,OACAE,EAAAN,EAAAI,IAAAlF,YAGA8E,GAAAI,GACAR,EAAAxD,KAAAgE,GACAH,EAAA7D,KAAAgE,OAIA,OAAAR,EAAAI,GAGA,QAAAM,GAAAC,EAAAC,GACA,OAAA5C,GAAA,EAAkBA,EAAA4C,EAAA3C,OAAcD,IAAA,CAChC,GAAA6C,GAAAD,EAAA5C,EACA2C,GAAApE,QAAAsE,GAAA,GACAF,EAAAnE,KAAAqE,IAzDA,aAAArF,EAAA,SAAAlB,OAAA,0CACA,mBAAA2F,IACA7F,EAAA6F,EACAA,MACIA,GAAA,gBAAAA,GACJ7F,KAAA,SAAAQ,GACA,GAAAA,EAAA,KAAAA,KAGAqF,KACA7F,KAAA,SAAAQ,GACA,GAAAA,EAAA,KAAAA,IAoDA,IAAAwF,MACAJ,KACAc,IACA,QAAA1B,KAAAS,GACA,GAAA/C,OAAAC,UAAAC,eAAAhB,KAAA6D,EAAAT,GAAA,CACA,GAAA9D,GAAA6D,EAAAC,GACA2B,EAAAb,EAAA5E,EACA,KAAAyF,EAAA,CACA,GAAAd,EAAAe,iBACA,QAEA,OADAvF,GAAA,SACArB,EAAA,GAAAE,OAAA,mBAAAgB,EAAA,qBAEA,GAAAyF,YAAAzG,OAEA,MADAmB,GAAA,SACArB,EAAA2G,EAEAD,GAAAxF,GAAAuE,EAAAvE,GACAoF,EAAAV,EAAAe,EAAA,GACA,QAAAzF,KAAAyF,GAAA,GACAjE,OAAAC,UAAAC,eAAAhB,KAAA+E,EAAA,GAAAzF,KACA8E,EAAA9E,KACA8E,EAAA9E,OACAoF,EAAAN,EAAA9E,GAAAyF,EAAA,GAAAzF,KAQA,OADA2F,MACAjD,EAAA,EAAiBA,EAAAgC,EAAA/B,OAA4BD,IAAA,CAC7C,GAAA1C,GAAA0E,EAAAhC,EACA7B,GAAAb,IAAAa,EAAAb,GAAAc,IAAAuB,eACAsD,EAAAzE,MACA2D,OAAA7E,EACA4F,aAAA/E,EAAAb,GAAAc,IAAAuB,gBAKAlC,EAAA,UAEA,KADA,GAAA4E,GAAAL,EAAAM,QACAD,EAAApC,OAAA,IACA,GAAA3C,GAAA+E,EAAAE,MACAJ,EAAAhE,EAAAb,EACA,IAAA6E,EAAA,CAMA,OAJAnB,MAGAmC,EAAAhB,EAAA/D,IAAAyB,iBACAuD,EAAA,EAAkBA,EAAAD,EAAAlD,OAA4BmD,IAAA,CAC9C,GAAAC,GAAAF,EAAAC,EACAC,GAAArC,GAEAC,EAAA3D,GAAA0D,EAGAmB,EAAA/D,IAAAC,gBAGAF,GAAAb,EAGA,QAAA8F,GAAA,EAAkBA,EAAAjB,EAAA1D,SAAAwB,OAA4BmD,IAAA,CAC9C,GAAAE,GAAAnF,EAAAgE,EAAA1D,SAAA2E,GACA,IAAAE,EAAA,CACA,GAAAhD,GAAAgD,EAAAhF,QAAAC,QAAAjB,EACAgD,IAAA,GACAgD,EAAAhF,QAAAiC,OAAAD,EAAA,MAMA,OAAAhD,KAAA8E,GACA,GAAAtD,OAAAC,UAAAC,eAAAhB,KAAAoE,EAAA9E,GAGA,OAFA6E,GAAAhE,EAAAb,GACAiG,EAAAnB,EAAA9E,GACA8F,EAAA,EAAmBA,EAAAG,EAAAtD,OAAuCmD,IAAA,CAC1D,GAAAI,GAAAD,EAAAH,GACA9C,EAAA6B,EAAA1D,SAAAF,QAAAiF,EACAlD,IAAA,GAAA6B,EAAA1D,SAAA8B,OAAAD,EAAA,GAMA7C,EAAA,SAEAxB,EAAAyF,CAGA,QAAApE,KAAAwF,GACAhE,OAAAC,UAAAC,eAAAhB,KAAA8E,EAAAxF,KACAlC,EAAAkC,GAAAwF,EAAAxF,GAKA,IAAAmG,GAAA,IACA,QAAAnG,KAAA8E,GACA,GAAAtD,OAAAC,UAAAC,eAAAhB,KAAAoE,EAAA9E,GAAA,CAIA,OAHA6E,GAAAhE,EAAAb,GACAiG,EAAAnB,EAAA9E,GACAoG,KACA1D,EAAA,EAAmBA,EAAAuD,EAAAtD,OAAuCD,IAAA,CAC1D,GAAAwD,GAAAD,EAAAvD,GACAqD,EAAAlB,EAAA/D,IAAAqB,sBAAA+D,EACAE,GAAAnF,QAAA8E,IAAA,GACAK,EAAAlF,KAAA6E,GAEA,OAAArD,GAAA,EAAmBA,EAAA0D,EAAAzD,OAAsBD,IAAA,CACzC,GAAAqD,GAAAK,EAAA1D,EACA,KACAqD,EAAAjB,GACO,MAAAxF,GACP6G,IACAA,EAAA7G,KAOA,OAAAoD,GAAA,EAAiBA,EAAAiD,EAAAhD,OAAwCD,IAAA,CACzD,GAAA6C,GAAAI,EAAAjD,GACA1C,EAAAuF,EAAAV,MACAzD,IAAApB,EACA,KACAvB,EAAAuB,GACK,MAAAV,GACL,qBAAAiG,GAAAK,aACA,IACAL,EAAAK,aAAAtG,GACO,MAAAA,GACP6G,IACAA,EAAA7G,OAEM6G,KACNA,EAAA7G,IAKA,MAAA6G,IACAhG,EAAA,QACArB,EAAAqH,KAGAhG,EAAA,YACArB,GAAA,KAAA4F,IAOA,QAAAjG,GAAAuB,GAGA,GAAAa,EAAAb,GACA,MAAAa,GAAAb,GAAAqG,OAGA,IAAAxB,GAAAhE,EAAAb,IACAqG,WACAvC,GAAA9D,EACAsG,UACAxF,IAAAoB,EAAAlC,GACAgB,QAAAI,EACAD,YAUA,OANArD,GAAAkC,GAAAU,KAAAmE,EAAAwB,QAAAxB,IAAAwB,QAAAtG,EAAAC,IAGA6E,EAAAyB,UAGAzB,EAAAwB,QAhjBA,GAAAE,GAAAC,KAAAC,gBACAD,MAAAC,iBACA,SAAAzI,EAAAyG,GACAD,EAAAxG,EAAAyG,GACA8B,KAAAvI,EAAAyG,GAmDA,IAAA9C,KACA,KACAH,OAAAI,kBAA2B,KAC3BG,IAAA,eAEAJ,KACG,MAAA+E,IAIH,GA4JApC,GAGAC,EAAAH,EA/JAJ,KACArF,EAAA,uBACAgF,KACAvC,KA0IAmC,KACArD,EAAA,OASAM,EAAA,EACAJ,EAAA,EACAE,KACA2D,KACAC,KA0TArD,IA2CA,OAZApC,GAAAkI,EAAA7I,EAGAW,EAAA0F,EAAAtD,EAGApC,EAAAC,EAAA,YAGAD,EAAA4F,EAAA,WAAsC,MAAA1F,IAGtCoB,EAAA,QDMM,SAAS8E,EAAQwB,EAAS5H,GAE/BoG,EAAOwB,QAAU5H,EAAoB,KAKhC,SAASoG,EAAQwB,EAAS5H,GAE/B,YAEA+C,QAAOI,eAAeyE,EAAS,cAC3BpE,UE/kBL,IAAI2E,GAAMC,QAAQhC,OAAO,QAAQpG,EAAQ,GAAqBA,EAAQ,GAAoBA,EAAQ,GAAmBA,EAAQ,IACzHmI,GAAI3E,MAAM,cAAc,YAExB2E,EAAIE,QAAQ,oBAAoB,SAASC,GACrCA,EAAkBC,SAASC,QAAQvH,QAC/BwH,OAAS,UFylBpBb,aErlBcO,GFylBT,SAAS/B,EAAQwB,EAAS5H,GGlmBhC,YHonBC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAVvF,GAAIG,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUL,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXI,SAAyBJ,EAAIM,cAAgBF,OAAS,eAAkBJ,IGxmB3OO,EAAAlJ,EAAA,IH4mBKmJ,EAAST,EAAuBQ,GG3mBrCE,EAAApJ,EAAA,GH+mBKqJ,EAAQX,EAAuBU,EG7mBpCC,cAAIC,QAAQ,aAAa,QAAQ,UAAU,WAAW,SAASC,EAAMC,EAAQC,GACzE,GAAIC,IAOAC,OAAO,SAASC,GACZ,MAAOT,cAAKU,KAAK,UAAUD,IAK/BE,UAIIC,OAAO,WACH,MAAsD,OAA/CP,EAAQQ,aAAaC,QAAQ,eAAyB,EAAIC,SAASV,EAAQQ,aAAaC,QAAQ,iBAK3GE,SAAS,WACL,MAAyD,OAAlDX,EAAQQ,aAAaC,QAAQ,kBAA4B,GAAKT,EAAQQ,aAAaC,QAAQ,mBAKtGG,UAAU,WACN,MAA0D,OAAnDZ,EAAQQ,aAAaC,QAAQ,mBAA6B,EAAIC,SAASV,EAAQQ,aAAaC,QAAQ,qBAK/GI,YAAY,WACR,MAA4D,OAArDb,EAAQQ,aAAaC,QAAQ,qBAA+B,EAAIC,SAASV,EAAQQ,aAAaC,QAAQ,uBAOjHK,KAAK,SAASR,GACa,WAAnB,mBAAOA,GAAP,YAAAhB,EAAOgB,MACuB,mBAAnBA,GAASC,QAChBP,EAAQQ,aAAaO,QAAQ,cAAcT,EAASC,QAEpB,mBAAzBD,GAAAU,WACPhB,EAAQQ,aAAaO,QAAQ,iBAAiBT,EAAAU,WAEb,mBAA1BV,GAAAW,YACPjB,EAAQQ,aAAaO,QAAQ,kBAAkBT,EAAAW,YAEZ,mBAA5BX,GAAAY,cACPlB,EAAQQ,aAAaO,QAAQ,oBAAoBT,EAAAY,iBAUjEC,QAAQ,WACJ,MAA0C,IAAnClB,EAASnG,IAAI,oBAAsE,mBAAnCmG,GAASnG,IAAI,oBAI5E,OAAOoG,OHsnBL,SAAStD,EAAQwB;;;;;CIjsBvB,SAAAgD,EAAAxC,GAA4B,YA2Q5B,SAAAyC,GAAAC,EAAAC,EAAAC,GAIA,QAAAC,GAAAnI,EAAAU,EAAA0C,GACA,GAAAgF,GAAAC,CACAjF,SACAiF,EAAAjF,EAAAiF,QACAD,EAAA9C,EAAAgD,UAAAlF,EAAAgF,MAAAhF,EAAAgF,KAAAG,EACAjD,EAAAkD,YAAA9H,KACA2H,EAAA,gCACA3H,EAAA,IAEA4E,EAAAmD,SAAAJ,KACAA,EAAA,GAAAK,MAAAL,GAGA,IAAAM,GAAAC,mBAAA5I,GAAA,IAAA4I,mBAAAlI,EACAiI,IAAAP,EAAA,SAAoBA,EAAA,GACpBO,GAAAvF,EAAAyF,OAAA,WAA8BzF,EAAAyF,OAAA,GAC9BF,GAAAN,EAAA,YAAuBA,EAAAS,cAAA,GACvBH,GAAAvF,EAAA2F,OAAA,UAA8B,EAM9B,IAAAC,GAAAL,EAAAvH,OAAA,CAOA,OANA4H,GAAA,MACAf,EAAAlI,KAAA,WAAAC,EACA,8DACAgJ,EAAA,mBAGAL,EAjCA,GAAAJ,GAAAL,EAAAe,WACAC,EAAAlB,EAAA,EAmCA,iBAAAhI,EAAAU,EAAA0C,GACA8F,EAAAC,OAAAhB,EAAAnI,EAAAU,EAAA0C,IA/RAkC,EAAAhC,OAAA,oBAOA8F,SAAA,uBA0BA,QAAAC,GAAAjG,GACA,MAAAA,GAAAkC,EAAAgE,UAAwC7D,EAAArC,GAAAqC,EAHxC,GAAAA,GAAAR,KAAAQ,WAiCAR,MAAAsE,MAAA,2CAAAC,EAAAC,GACA,OAWAjJ,IAAA,SAAAkJ,GACA,MAAAF,KAAAE,IAaAC,UAAA,SAAAD,GACA,GAAAhJ,GAAAuE,KAAAzE,IAAAkJ,EACA,OAAAhJ,GAAA4E,EAAAsE,SAAAlJ,MAYAmJ,OAAA,WACA,MAAAL,MAeAM,IAAA,SAAAJ,EAAAhJ,EAAA0C,GACAqG,EAAAC,EAAAhJ,EAAA2I,EAAAjG,KAeA2G,UAAA,SAAAL,EAAAhJ,EAAA0C,GACA6B,KAAA6E,IAAAJ,EAAApE,EAAA0E,OAAAtJ,GAAA0C,IAcA6G,OAAA,SAAAP,EAAAtG,GACAqG,EAAAC,EAAAQ,OAAAb,EAAAjG,WAMAkC,EAAAhC,OAAA,aAiCAkD,QAAA,oCAAAG,GAEA,OAWAnG,IAAA,SAAAkJ,GACA,MAAA/C,GAAAgD,UAAAD,IAaAI,IAAA,SAAAJ,EAAAhJ,GACAiG,EAAAoD,UAAAL,EAAAhJ,IAYAuJ,OAAA,SAAAP,GACA/C,EAAAsD,OAAAP,QA2DA3B,EAAAoC,SAAA,+BAEA7E,EAAAhC,OAAA,aAAA8F,SAAA,4BACAnE,KAAAsE,KAAAxB,KAICD,cAAAxC,UJ6sBK,SAAShC,EAAQwB,EAAS5H,GK9gChCA,EAAA,GACAoG,EAAAwB,QAAA,aLqhCM,SAASxB,EAAQwB,GMhhCvB,mBAAAxB,IAAA,mBAAAwB,IAAAxB,EAAAwB,cACAxB,EAAAwB,QAAA,eAEA,SAAAQ,GACAA,EAAAhC,OAAA,+BACAgC,EAAAhC,OAAA,yBACAgC,EAAAhC,OAAA,sFAEAgC,EAAAhC,OAAA,8BAAA8G,OAAA,2BAAAC,GACA,GAAAC,KACA,iBAAAC,EAAAC,GAKA,MAJAF,GAAAC,KACAC,IAAAH,EAAAI,WAAAD,EAAAE,WAAAC,eAAA,GACAL,EAAAC,KAAAF,EAAAI,WAAAF,EAAAG,WAAAC,eAAAH,GAEAF,EAAAC,OAIAjF,EAAAhC,OAAA,yBAAA8G,OAAA,sBAAAC,GACA,gBAAAE,GACA,MAAAA,GAAAF,EAAAI,WAAAF,EAAAG,WAAAC,eAAAJ,MAIAjF,EAAAhC,OAAA,0BAAAkD,QAAA,kBACA,GAAA6D,IACAI,WAAA,SAAA9B,GACA,UAAAA,EACA,WAEA,IAAAiC,GAmFAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAnH,EAAAC,EAAAnB,EAAAsI,EAlFAC,EAAA,SAAAC,EAAAC,GACA,MAAAD,IAAAC,EAAAD,IAAA,GAAAC,GAEAC,EAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,CAMA,OALAF,GAAA,WAAAJ,EACAK,EAAA,WAAAJ,EACAC,EAAA,WAAAF,EACAG,EAAA,WAAAF,EACAK,GAAA,WAAAN,IAAA,WAAAC,GACAC,EAAAC,EACA,WAAAG,EAAAF,EAAAC,EAEAH,EAAAC,EACA,WAAAG,EACA,WAAAA,EAAAF,EAAAC,EAEA,WAAAC,EAAAF,EAAAC,EAGAC,EAAAF,EAAAC,GAGAE,EAAA,SAAA3G,EAAA4G,EAAAC,GACA,MAAA7G,GAAA4G,GAAA5G,EAAA6G,GAEAC,EAAA,SAAA9G,EAAA4G,EAAAC,GACA,MAAA7G,GAAA6G,EAAAD,GAAAC,GAEAE,EAAA,SAAA/G,EAAA4G,EAAAC,GACA,MAAA7G,GAAA4G,EAAAC,GAEAG,EAAA,SAAAhH,EAAA4G,EAAAC,GACA,MAAAD,IAAA5G,GAAA6G,IAEAI,EAAA,SAAAtI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAAkH,EAAAC,GAEA,MADAxI,GAAAwH,EAAAxH,EAAAwH,IAAAQ,EAAA/H,EAAAnB,EAAAsI,GAAA/F,GAAAmH,IACAhB,EAAAH,EAAArH,EAAAuI,GAAAtI,IAEAwI,EAAA,SAAAzI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAAkH,EAAAC,GAEA,MADAxI,GAAAwH,EAAAxH,EAAAwH,IAAAW,EAAAlI,EAAAnB,EAAAsI,GAAA/F,GAAAmH,IACAhB,EAAAH,EAAArH,EAAAuI,GAAAtI,IAEAyI,EAAA,SAAA1I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAAkH,EAAAC,GAEA,MADAxI,GAAAwH,EAAAxH,EAAAwH,IAAAY,EAAAnI,EAAAnB,EAAAsI,GAAA/F,GAAAmH,IACAhB,EAAAH,EAAArH,EAAAuI,GAAAtI,IAEA0I,EAAA,SAAA3I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAAkH,EAAAC,GAEA,MADAxI,GAAAwH,EAAAxH,EAAAwH,IAAAa,EAAApI,EAAAnB,EAAAsI,GAAA/F,GAAAmH,IACAhB,EAAAH,EAAArH,EAAAuI,GAAAtI,IAEA2I,EAAA,SAAA/D,GASA,IARA,GAAAgE,GACAC,EAAAjE,EAAAvH,OACAyL,EAAAD,EAAA,EACAE,GAAAD,IAAA,OACAE,EAAA,IAAAD,EAAA,GACAE,EAAA,GAAAC,OAAAF,EAAA,GACAG,EAAA,EACAC,EAAA,EACAP,EAAAO,GACAR,GAAAQ,IAAA,KACAD,EAAAC,EAAA,IACAH,EAAAL,GAAAK,EAAAL,GAAAhE,EAAAyE,WAAAD,IAAAD,EACAC,GAOA,OALAR,IAAAQ,IAAA,KACAD,EAAAC,EAAA,IACAH,EAAAL,GAAAK,EAAAL,GAAA,KAAAO,EACAF,EAAAD,EAAA,GAAAH,GAAA,EACAI,EAAAD,EAAA,GAAAH,IAAA,GACAI,GAEAK,EAAA,SAAAjC,GACA,GAAAkC,GAAAC,EAAAC,EAAA,GAAAC,EAAA,EACA,KAAAF,EAAA,EAA0B,GAAAA,EAAaA,IACvCD,EAAAlC,IAAA,EAAAmC,EAAA,IACAE,EAAA,IAAAH,EAAA5C,SAAA,IACA8C,GAAAC,EAAAC,OAAAD,EAAArM,OAAA,IAEA,OAAAoM,IAEArI,KAAAwI,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,EAOA,KANAvJ,EAAAuH,EAAA/D,GACA7E,EAAA,WACAC,EAAA,WACAnB,EAAA,WACAsI,EAAA,UACAN,EAAAzF,EAAA/D,OACAyJ,EAAA,EAAmBD,EAAAC,EAAQA,GAAA,GAC3BC,EAAAhH,EACAiH,EAAAhH,EACAiH,EAAApI,EACAqI,EAAAC,EACApH,EAAAsI,EAAAtI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAA8C,EAAA,YACAzC,EAAAkB,EAAAlB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAA+C,EAAA,YACAhL,EAAAwJ,EAAAxJ,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAAgD,EAAA,WACA9J,EAAAqI,EAAArI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAiD,EAAA,YACAhK,EAAAsI,EAAAtI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAA8C,EAAA,YACAzC,EAAAkB,EAAAlB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAA+C,EAAA,YACAhL,EAAAwJ,EAAAxJ,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAAgD,EAAA,YACA9J,EAAAqI,EAAArI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAiD,EAAA,YACAhK,EAAAsI,EAAAtI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAA8C,EAAA,YACAzC,EAAAkB,EAAAlB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAA+C,EAAA,YACAhL,EAAAwJ,EAAAxJ,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAAgD,EAAA,YACA9J,EAAAqI,EAAArI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,IAAAiD,EAAA,YACAhK,EAAAsI,EAAAtI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,IAAA8C,EAAA,YACAzC,EAAAkB,EAAAlB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,IAAA+C,EAAA,YACAhL,EAAAwJ,EAAAxJ,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAAgD,EAAA,YACA9J,EAAAqI,EAAArI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,IAAAiD,EAAA,YACAhK,EAAAyI,EAAAzI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAAkD,EAAA,YACA7C,EAAAqB,EAAArB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAAmD,EAAA,YACApL,EAAA2J,EAAA3J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAAoD,EAAA,WACAlK,EAAAwI,EAAAxI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAqD,EAAA,YACApK,EAAAyI,EAAAzI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAAkD,EAAA,YACA7C,EAAAqB,EAAArB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,IAAAmD,EAAA,UACApL,EAAA2J,EAAA3J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAAoD,EAAA,YACAlK,EAAAwI,EAAAxI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAqD,EAAA,YACApK,EAAAyI,EAAAzI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAAkD,EAAA,WACA7C,EAAAqB,EAAArB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,IAAAmD,EAAA,YACApL,EAAA2J,EAAA3J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAAoD,EAAA,YACAlK,EAAAwI,EAAAxI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAqD,EAAA,YACApK,EAAAyI,EAAAzI,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,IAAAkD,EAAA,YACA7C,EAAAqB,EAAArB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAAmD,EAAA,YACApL,EAAA2J,EAAA3J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAAoD,EAAA,YACAlK,EAAAwI,EAAAxI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,IAAAqD,EAAA,YACApK,EAAA0I,EAAA1I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAAsD,EAAA,YACAjD,EAAAsB,EAAAtB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAAuD,EAAA,YACAxL,EAAA4J,EAAA5J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAAwD,EAAA,YACAtK,EAAAyI,EAAAzI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,IAAAyD,EAAA,YACAxK,EAAA0I,EAAA1I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAAsD,EAAA,YACAjD,EAAAsB,EAAAtB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAAuD,EAAA,YACAxL,EAAA4J,EAAA5J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAAwD,EAAA,YACAtK,EAAAyI,EAAAzI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,IAAAyD,EAAA,YACAxK,EAAA0I,EAAA1I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,IAAAsD,EAAA,WACAjD,EAAAsB,EAAAtB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAAuD,EAAA,YACAxL,EAAA4J,EAAA5J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAAwD,EAAA,YACAtK,EAAAyI,EAAAzI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAyD,EAAA,UACAxK,EAAA0I,EAAA1I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAAsD,EAAA,YACAjD,EAAAsB,EAAAtB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,IAAAuD,EAAA,YACAxL,EAAA4J,EAAA5J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAAwD,EAAA,WACAtK,EAAAyI,EAAAzI,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAAyD,EAAA,YACAxK,EAAA2I,EAAA3I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAA0D,EAAA,YACArD,EAAAuB,EAAAvB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAA2D,EAAA,YACA5L,EAAA6J,EAAA7J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAA4D,EAAA,YACA1K,EAAA0I,EAAA1I,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAA6D,EAAA,YACA5K,EAAA2I,EAAA3I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,IAAA0D,EAAA,YACArD,EAAAuB,EAAAvB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,GAAA2D,EAAA,YACA5L,EAAA6J,EAAA7J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,IAAA4D,EAAA,YACA1K,EAAA0I,EAAA1I,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAA6D,EAAA,YACA5K,EAAA2I,EAAA3I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAA0D,EAAA,YACArD,EAAAuB,EAAAvB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,IAAA2D,EAAA,YACA5L,EAAA6J,EAAA7J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAA4D,EAAA,YACA1K,EAAA0I,EAAA1I,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,IAAA6D,EAAA,YACA5K,EAAA2I,EAAA3I,EAAAC,EAAAnB,EAAAsI,EAAA/F,EAAA0F,EAAA,GAAA0D,EAAA,YACArD,EAAAuB,EAAAvB,EAAApH,EAAAC,EAAAnB,EAAAuC,EAAA0F,EAAA,IAAA2D,EAAA,YACA5L,EAAA6J,EAAA7J,EAAAsI,EAAApH,EAAAC,EAAAoB,EAAA0F,EAAA,GAAA4D,EAAA,WACA1K,EAAA0I,EAAA1I,EAAAnB,EAAAsI,EAAApH,EAAAqB,EAAA0F,EAAA,GAAA6D,EAAA,YACA5K,EAAAwH,EAAAxH,EAAAgH,GACA/G,EAAAuH,EAAAvH,EAAAgH,GACAnI,EAAA0I,EAAA1I,EAAAoI,GACAE,EAAAI,EAAAJ,EAAAD,EAEA,IAAA0D,GAAAtB,EAAAvJ,GAAAuJ,EAAAtJ,GAAAsJ,EAAAzK,GAAAyK,EAAAnC,EACA,OAAAyD,GAAAhE,eAGA,OAAAN,OAEC/E,UN4hCK,SAAShC,EAAQwB;;;;;COtuCvB,SAAAgD,EAAAxC,GAA4B,YAS5B,SAAAsJ,GAAAxG,GACA,aAAAA,GAAA,KAAAA,GAAA,mBAAAA,GACAyG,EAAAC,KAAA,IAAA1G,GAGA,QAAA2G,GAAAlJ,EAAAuC,GACA,IAAAwG,EAAAxG,GACA,KAAA4G,GAAA,oDAAgE5G,EAGhE,QADA6G,GAAA7G,EAAA8G,MAAA,KACA/N,EAAA,EAAAgO,EAAAF,EAAA7N,OAAmC+N,EAAAhO,GAAAmE,EAAAgD,UAAAzC,GAAkC1E,IAAA,CACrE,GAAAuI,GAAAuF,EAAA9N,EACA0E,GAAA,OAAAA,IAAA6D,GAAAQ,OAEA,MAAArE,GAMA,QAAAuJ,GAAAnS,EAAAoS,GACAA,QAEA/J,EAAAgK,QAAAD,EAAA,SAAA3O,EAAAgJ,SACA2F,GAAA3F,IAGA,QAAAA,KAAAzM,IACAA,EAAAkD,eAAAuJ,IAAA,MAAAA,EAAA6F,OAAA,UAAA7F,EAAA6F,OAAA,KACAF,EAAA3F,GAAAzM,EAAAyM,GAIA,OAAA2F,GAxCA,GAAAL,GAAA1J,EAAAkK,SAAA,aAKAX,EAAA,mCAwYAvJ,GAAAhC,OAAA,qBACA8F,SAAA,uBACA,GAAAqG,GAAA,qBACArG,EAAAnE,IAEAA,MAAAQ,UAEAiK,wBAGAhK,SACAlF,KAAgBmF,OAAA,OAChB6B,MAAiB7B,OAAA,QACjBgK,OAAkBhK,OAAA,MAAAiK,YAClB3F,QAAmBtE,OAAA,UACnBkK,UAAmBlK,OAAA,YAInBV,KAAAsE,MAAA,wCAAA9C,EAAAwB,EAAA6H,EAAAC,GAmBA,QAAAC,GAAAC,GACA,MAAAC,GAAAD,MACAE,QAAA,aACAA,QAAA,aACAA,QAAA,aAeA,QAAAD,GAAAD,EAAAG,GACA,MAAAxH,oBAAAqH,GACAE,QAAA,aACAA,QAAA,aACAA,QAAA,YACAA,QAAA,aACAA,QAAA,OAAAC,EAAA,WAGA,QAAAC,GAAAC,EAAA7K,GACAR,KAAAqL,WACArL,KAAAQ,SAAA6D,KAAiCF,EAAA3D,YACjCR,KAAAsL,aA4EA,QAAAC,GAAA1J,EAAA2J,EAAA/K,EAAAtC,GAKA,QAAAsN,GAAAvO,EAAAwO,GACA,GAAAC,KAOA,OANAD,GAAArH,KAAkCmH,EAAAE,GAClCrB,EAAAqB,EAAA,SAAAjQ,EAAAgJ,GACAmH,EAAAnQ,KAAoCA,OACpCkQ,EAAAlH,GAAAhJ,KAAA6O,QAAA,KAAA7O,EAAA6O,OAAA,GACAR,EAAA5M,EAAAzB,EAAAgN,OAAA,IAAAhN,IAEAkQ,EAGA,QAAAE,GAAAC,GACA,MAAAA,GAAAC,SAGA,QAAAC,GAAAvQ,GACA0O,EAAA1O,MAAyCuE,MApBzC,GAAAiM,GAAA,GAAAb,GAAAvJ,EAAA1D,EAiNA,OA/MAsC,GAAA4D,KAA2BF,EAAA3D,SAAAC,WAqB3BuL,EAAA/Q,UAAAiR,OAAA,WACA,GAAAhP,GAAAmH,KAA8BrE,KAG9B,cAFA9C,GAAAiP,eACAjP,GAAAkP,UACAlP,GAGAmN,EAAA5J,EAAA,SAAA4L,EAAAtR,GACA,GAAAuR,GAAA,sBAAAzC,KAAAwC,EAAA3L,QACA6L,EAAAF,EAAAzT,QACA4T,EAAAnM,EAAAgD,UAAAgJ,EAAAG,aAAAH,EAAAG,YACArO,GAAAkC,EAAAgD,UAAAlF,EAAAqO,aAAArO,EAAAqO,YACArI,EAAA3D,SAAAgM,WAEAD,KAAAlM,EAAA9C,SAAAgP,KACAvJ,EAAAyJ,MAAA,wQAKAJ,GAAAzT,QACA2T,EAAA,MAGAP,EAAAjR,GAAA,SAAA2R,EAAAC,EAAAC,EAAAC,GACA,GAA2B3P,GAAA4P,EAAAnN,EAA3BoN,IAGA,QAAAC,UAAA7Q,QACA,OACAwD,EAAAkN,EACAC,EAAAF,CAEA,QACA,OACA,IAAAhB,EAAAe,GAUiB,CACjBI,EAAAL,EACAxP,EAAAyP,EACAG,EAAAF,CACA,OAbA,GAAAhB,EAAAc,GAAA,CACAI,EAAAJ,EACA/M,EAAAgN,CACA,OAGAG,EAAAH,EACAhN,EAAAiN,CAQA,QACAhB,EAAAc,GAAAI,EAAAJ,EACAJ,EAAApP,EAAAwP,EACAK,EAAAL,CACA,MACA,aACA,SACA,KAAA3C,GAAA,UACA,+EACAiD,UAAA7Q,QAIA,GAOA8Q,GACAC,EARAC,EAAAnN,eAAAgM,GACAvQ,EAAA0R,EAAAjQ,EAAAmP,EAAA1B,WAAA,GAAAqB,GAAA9O,GACAkQ,KACAC,EAAAhB,EAAAiB,aAAAjB,EAAAiB,YAAAxB,UACAD,EACA0B,EAAAlB,EAAAiB,aAAAjB,EAAAiB,YAAAE,eACAvI,MAIAoF,GAAAgC,EAAA,SAAA5Q,EAAAgJ,GACA,OAAAA,GACA,QACA2I,EAAA3I,GAAAgJ,EAAAhS,EACA,MACA,cACA,cACA,kBACA,uBAKA0R,GAAAX,IACAS,EAAApC,EAAA6C,QACAN,EAAAxU,QAAAqU,EAAAU,QAEApB,IACAW,EAAApC,EAAAmC,EAAAW,QAAArB,KAIAD,IAAAc,EAAAlQ,QACA+O,EAAA4B,aAAAT,EACA/I,KAAuBoH,EAAAvO,EAAAmP,EAAAU,YAAyCA,GAChEV,EAAAxK,IAEA,IAAA8L,GAAAnM,EAAA4L,GAAAU,KAAA,SAAAhC,GACA,GAAA5O,GAAA4O,EAAA5O,IAEA,IAAAA,EAAA,CAGA,GAAAmD,EAAAsK,QAAAzN,OAAAmP,EAAA1B,QACA,KAAAZ,GAAA,SACA,0HACsEhP,EAAAsR,EAAA1B,QAAA,iBACtEtK,EAAAsK,QAAAzN,GAAA,iBAAAkQ,EAAA1M,OAAA0M,EAAAvL,IAGA,IAAAwK,EAAA1B,QACAlP,EAAAU,OAAA,EACAkO,EAAAnN,EAAA,SAAA6B,GACA,gBAAAA,GACAtD,EAAAf,KAAA,GAAAsR,GAAAjN,IAKAtD,EAAAf,KAAAqE,SAGiB,CACjB,GAAA4O,GAAAlS,EAAA0Q,QACAhC,GAAAjN,EAAAzB,GACAA,EAAA0Q,SAAAwB,GAKA,MAFA7B,GAAAC,SAAAtQ,EAEAqQ,GACa,SAAAA,GAEb,OADAnM,GAAAoO,GAAAjC,GACAjB,EAAAmD,OAAAlC,IAoBA,OAjBA6B,GAAA,sBACAlS,EAAA2Q,cACAe,GAAAX,IACA/Q,EAAAwS,eAAA5N,EAAA0N,KACAjD,EAAAoD,OAAAhB,GACAD,EAAAC,EAAAE,EAAAxU,QAAA,QAIA+U,IAAAG,KACA,SAAAhC,GACA,GAAArQ,GAAA4R,EAAAvB,EAEA,QADAgB,GAAAiB,GAAAtS,EAAAqQ,EAAAqC,SACA1S,GAEA8R,GAEAJ,EAYAQ,GARAlS,EAAA0Q,SAAAwB,EACAlS,EAAA2Q,aACAI,IAAA/Q,EAAAwS,eAAAhB,EAAAW,SAEAnS,IAQAuQ,EAAA/Q,UAAA,IAAAF,GAAA,SAAAgS,EAAAD,EAAAnN,GACAiM,EAAAmB,KACApN,EAAAmN,EAA8BA,EAAAC,EAAkBA,KAEhD,IAAA9N,GAAA+M,EAAAjR,GAAAb,KAAA8F,KAAA+M,EAAA/M,KAAA8M,EAAAnN,EACA,OAAAV,GAAAkN,UAAAlN,KAIA+M,EAAAoC,KAAA,SAAAC,GACA,MAAA9C,GAAA1J,EAAAwC,KAA+CmH,EAAA6C,GAAA5N,IAG/CuL,EA9UA,GAAA+B,GAAA1N,EAAA0N,KACA1D,EAAAhK,EAAAgK,QACAhG,EAAAhE,EAAAgE,OACAoJ,EAAApN,EAAAoN,KACA7B,EAAAvL,EAAAuL,UA6UA,OA9RAR,GAAAnQ,WACA4S,aAAA,SAAAvN,EAAAyM,EAAAuB,GACA,GAEAtD,GACAuD,EAHAC,EAAAxO,KACA6B,EAAAyM,GAAAE,EAAAnD,SAGAoD,EAAA,GAEAnD,EAAAkD,EAAAlD,YACAjB,GAAAxI,EAAAoI,MAAA,eAAAyE,GACA,sBAAAA,EACA,KAAA3E,GAAA,4DAEA,GAAA4E,QAAA,UAAA9E,KAAA6E,OACA,GAAAC,QAAA,eAAAD,EAAA,WAAA7E,KAAAhI,KACAyJ,EAAAoD,IACAE,kBAAA,GAAAD,QAAA,UAAAD,EAAA,aAAA7E,KAAAhI,OAIAA,IAAAqJ,QAAA,YACArJ,IAAAqJ,QAAAV,EAAA,SAAAqE,GAEA,MADAJ,GAAAI,EACA,KAGA9B,QACA1C,EAAAmE,EAAAlD,UAAA,SAAAwD,EAAAC,GACA/D,EAAA+B,EAAA7R,eAAA6T,GAAAhC,EAAAgC,GAAAP,EAAAhO,SAAAuO,GACA1O,EAAAgD,UAAA2H,IAAA,OAAAA,GAEAuD,EADAO,EAAAF,kBACA3D,EAAAD,MAEAD,EAAAC,GAEAnJ,IAAAqJ,QAAA,GAAAyD,QAAA,IAAAI,EAAA,wBAAAF,EAAAG,GACA,MAAAT,GAAAS,KAGAnN,IAAAqJ,QAAA,GAAAyD,QAAA,QAAAI,EAAA,wBAAAF,EACAI,EAAAC,GACA,WAAAA,EAAA5E,OAAA,GACA4E,EAEAD,EAAAC,MAOAV,EAAAhO,SAAAiK,uBACA5I,IAAAqJ,QAAA,iBAKArJ,IAAAqJ,QAAA,yBAEA5K,EAAAuB,IAAA4M,EAAA5M,EAAAqJ,QAAA,eAIAb,EAAA0C,EAAA,SAAAtR,EAAAgJ,GACA+J,EAAAlD,UAAA7G,KACAnE,EAAAyM,OAAAzM,EAAAyM,WACAzM,EAAAyM,OAAAtI,GAAAhJ,OA4NA8P,OAKC1I,cAAAxC,UPkvCK,SAAShC,EAAQwB,EAAS5H,GQj/DhCA,EAAA,GACAoG,EAAAwB,QAAA,cRw/DM,SAASxB,EAAQwB,GSj/DvB,mBAAAxB,IAAA,mBAAAwB,IAAAxB,EAAAwB,cACAxB,EAAAwB,QAAA,aAGA,SAAAgD,EAAAxC,EAAA4E,GAGA,YAYA,SAAAkK,GAAAxQ,EAAAyQ,GACA,MAAA/K,GAAA,IAAAA,EAAA,cAA4CpJ,UAAA0D,KAAoByQ,GAGhE,QAAAC,GAAAjF,GAQA,MAPAC,GAAA2C,UAAA,SAAApM,GACAA,IAAAwJ,GACAC,EAAAzJ,EAAA,SAAAnF,EAAAgJ,GACA2F,EAAAlP,eAAAuJ,KAAA2F,EAAA3F,GAAAhJ,OAIA2O,EAUA,QAAAkF,GAAAC,EAAAC,GACA,GAAArM,KAEA,QAAAsM,KAAAF,GAAApM,KAAA,CACA,GAAAoM,EAAApM,KAAAsM,KAAAD,EAAArM,KAAAsM,GAAA,KACAtM,GAAAzI,KAAA6U,EAAApM,KAAAsM,IAEA,MAAAtM,GASA,QAAAuM,GAAAC,GACA,GAAA3U,OAAAgP,KACA,MAAAhP,QAAAgP,KAAA2F,EAEA,IAAA1Q,KAKA,OAHAoL,GAAAsF,EAAA,SAAA3E,EAAAvG,GACAxF,EAAAvE,KAAA+J,KAEAxF,EAUA,QAAAxE,GAAAmV,EAAAnU,GACA,GAAAuM,MAAA/M,UAAAR,QACA,MAAAmV,GAAAnV,QAAAgB,EAAAoU,OAAA7C,UAAA,OAEA,IAAA8C,GAAAF,EAAAzT,SAAA,EAAA4T,EAAAF,OAAA7C,UAAA,MAKA,KAJA+C,EAAA,EAAAA,EAAAC,KAAAC,KAAAF,GAAAC,KAAAE,MAAAH,GAEA,EAAAA,OAAAD,GAEQA,EAAAC,EAAYA,IACpB,GAAAA,IAAAH,MAAAG,KAAAtU,EAAA,MAAAsU,EAEA,UAYA,QAAAI,GAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAhW,EAAA8U,EAAAgB,EAAAC,GAAAE,KAAsEC,IAEtE,QAAAxU,KAAA1B,GACA,GAAAA,EAAA0B,IAAA1B,EAAA0B,GAAA6Q,SACAyD,EAAAd,EAAAlV,EAAA0B,GAAA6Q,QACAyD,EAAArU,QAEA,OAAAmD,KAAAkR,GACA/V,EAAAiW,EAAAF,EAAAlR,KAAA,IACAoR,EAAAhW,KAAA8V,EAAAlR,IACAmR,EAAAD,EAAAlR,IAAA8Q,EAAAI,EAAAlR,IAGA,OAAA+E,MAAkBoM,EAAAJ,GAYlB,QAAAM,GAAA9R,EAAAC,EAAAkL,GACA,IAAAA,EAAA,CACAA,IACA,QAAAyF,KAAA5Q,GAAAmL,EAAAtP,KAAA+U,GAGA,OAAAvT,GAAA,EAAeA,EAAA8N,EAAA7N,OAAeD,IAAA,CAC9B,GAAA0J,GAAAoE,EAAA9N,EACA,IAAA2C,EAAA+G,IAAA9G,EAAA8G,GAAA,SAEA,SAUA,QAAAgL,GAAA5G,EAAA6G,GACA,GAAAC,KAKA,OAHAzG,GAAAL,EAAA,SAAAjP,GACA+V,EAAA/V,GAAA8V,EAAA9V,KAEA+V,EAeA,QAAAC,GAAAnQ,GACA,GAAA6M,MACAzD,EAAAhC,MAAA/M,UAAA+V,OAAApU,MAAAoL,MAAA/M,UAAA+M,MAAA/M,UAAAuD,MAAAtE,KAAA8S,UAAA,GAIA,OAHA3C,GAAAL,EAAA,SAAAvF,GACAA,IAAA7D,KAAA6M,EAAAhJ,GAAA7D,EAAA6D,MAEAgJ,EAKA,QAAAwD,GAAArQ,GACA,GAAA6M,MACAzD,EAAAhC,MAAA/M,UAAA+V,OAAApU,MAAAoL,MAAA/M,UAAA+M,MAAA/M,UAAAuD,MAAAtE,KAAA8S,UAAA,GACA,QAAAvI,KAAA7D,GACA,IAAAnG,EAAAuP,EAAAvF,KAAAgJ,EAAAhJ,GAAA7D,EAAA6D,GAEA,OAAAgJ,GAYA,QAAAtI,GAAA+L,EAAA5Y,GACA,GAAAsX,GAAAjF,EAAAuG,GACAjS,EAAA2Q,OAMA,OALAvF,GAAA6G,EAAA,SAAAlG,EAAA9O,GACA5D,EAAA0S,EAAA9O,KACA+C,EAAA2Q,EAAA3Q,EAAA9C,OAAAD,GAAA8O,KAGA/L,EAGA,QAAAkS,GAAAD,EAAA5Y,GACA,GAAA2G,GAAA0L,EAAAuG,QAKA,OAHA7G,GAAA6G,EAAA,SAAAlG,EAAA9O,GACA+C,EAAA/C,GAAA5D,EAAA0S,EAAA9O,KAEA+C,EAiGA,QAAAmS,GAAAvG,EAAAwG,GAEA,GAAAC,GAAA,EACAC,EAAA,EACAC,KACAC,KACAC,EAAAF,EACAG,EAAAtN,EAAAwG,EAAA+G,KAAAJ,IAA4CK,WAAAL,EAAAM,SAAAN,GAuB5CxR,MAAA+R,MAAA,SAAAC,GAMA,QAAAC,GAAAxW,EAAAgJ,GACA,GAAAyN,EAAAzN,KAAA8M,EAAA,CAGA,GADAY,EAAAzX,KAAA+J,GACAyN,EAAAzN,KAAA6M,EAEA,KADAa,GAAA1V,OAAA,EAAAhC,EAAA0X,EAAA1N,IACA,GAAAjM,OAAA,sBAAA2Z,EAAArQ,KAAA,QAIA,IAFAoQ,EAAAzN,GAAA6M,EAEA9N,EAAA/H,GACA2W,EAAA1X,KAAA+J,GAAA,WAAqC,MAAA4M,GAAA9V,IAAAE,KAA+BgW,OAC7D,CACP,GAAA1E,GAAAsE,EAAAgB,SAAA5W,EACA4O,GAAA0C,EAAA,SAAA2B,GACAA,IAAAjK,GAAAuN,EAAA9W,eAAAwT,IAAAuD,EAAAD,EAAAtD,QAEA0D,EAAA1X,KAAA+J,EAAAhJ,EAAAsR,GAGAoF,EAAA1T,MACAyT,EAAAzN,GAAA8M,GAKA,QAAAe,GAAA7W,GACA,MAAA8W,GAAA9W,MAAAqS,MAAArS,EAAAoW,WAhCA,IAAAU,EAAAP,GAAA,SAAAxZ,OAAA,iCACA,IAAAga,GAAA9C,EAAAsC,OAGAI,KAAAD,KAAAD,IA+BA,OAPA7H,GAAA2H,EAAAC,GACAD,EAAAG,EAAAD,EAAA,KAMA,SAAAO,EAAA9T,EAAA6P,GAsBA,QAAAkE,OAEAC,IACAC,GAAAvD,EAAAwB,EAAAlS,EAAAmT,UACA7S,EAAA6S,SAAAjB,EACA5R,EAAA4S,WAAA5S,EAAA4S,qBACA5S,GAAA4T,kBACAC,EAAAlF,QAAAiD,IAIA,QAAAkC,GAAAC,GACA/T,EAAAgU,UAAAD,EACAF,EAAA9E,OAAAgF,GAiCA,QAAAE,GAAAzO,EAAA0O,EAAApG,GAGA,QAAAqG,GAAAJ,GACAK,EAAArF,OAAAgF,GACAD,EAAAC,GAcA,QAAAM,KACA,IAAAjQ,EAAApE,EAAAgU,WACA,IACAI,EAAAzF,QAAAyD,EAAA6B,OAAAC,EAAA3E,EAAAqC,IACAwC,EAAA1F,QAAAG,KAAA,SAAA7O,GACA4R,EAAApM,GAAAxF,EACAyT,KACaU,GACF,MAAA9Z,GACX8Z,EAAA9Z,IA1BA,GAAA+Z,GAAAxI,EAAA6C,QAAA6F,EAAA,CAOAlJ,GAAA0C,EAAA,SAAA9Q,GACAuX,EAAAtY,eAAAe,KAAAwW,EAAAvX,eAAAe,KACAsX,IACAC,EAAAvX,GAAA6R,KAAA,SAAA7O,GACA4R,EAAA5U,GAAAgD,IACAsU,GAAAD,KACaF,MAGbG,GAAAD,IAcAE,EAAA/O,GAAA4O,EAAA1F,QAhGA,GAHA2E,EAAAG,IAAAjE,IAAAvJ,IACAuJ,EAAA7P,EAAsBA,EAAA8T,EAAiBA,EAAA,MAEvCA,GACA,IAAAF,EAAAE,GACA,SAAAja,OAAA,kCAFAia,GAAAf,CAIA,IAAA/S,GACA,IAAA2T,EAAA3T,GACA,SAAAnG,OAAA,iEAFAmG,GAAAgT,CAOA,IAAAmB,GAAAjI,EAAA6C,QACAzO,EAAA6T,EAAAnF,QACA6F,EAAAvU,EAAA4S,cACAhB,EAAAxM,KAA4BoO,GAC5BE,EAAA,EAAAP,EAAAjW,OAAA,EACAyW,IAmBA,IAAAvP,EAAA1E,EAAAsU,WAEA,MADAF,GAAApU,EAAAsU,WACAhU,CAGAN,GAAAkU,mBACAxD,EAAAwB,EAAAI,EAAAtS,EAAAkU,kBAAAL,IAKAnO,EAAAmP,EAAA7U,EAAAkT,YACAlT,EAAAmT,UACAc,EAAAvD,EAAAwB,EAAAI,EAAAtS,EAAAmT,SAAAU,IACAvT,EAAA4T,kBAAA5B,EAAAtS,EAAAmT,SAAAU,GACAE,MAEA/T,EAAAkU,oBACA5T,EAAA4T,kBAAA5B,EAAAtS,EAAAkU,kBAAAL,IAEA7T,EAAAmP,KAAA4E,EAAAK,GAIA,QAAA7W,GAAA,EAAAgO,EAAAkI,EAAAjW,OAAmC+N,EAAAhO,EAAMA,GAAA,EACzCuW,EAAAvX,eAAAkX,EAAAlW,IAAAwW,IACAQ,EAAAd,EAAAlW,GAAAkW,EAAAlW,EAAA,GAAAkW,EAAAlW,EAAA,GAsCA,OAAA+C,KAiEAe,KAAA4N,QAAA,SAAAoE,EAAAS,EAAA9T,EAAA6P,GACA,MAAAxO,MAAA+R,MAAAC,GAAAS,EAAA9T,EAAA6P,IAmBA,QAAAiF,GAAAjS,EAAAkS,EAAArC,GA2BArR,KAAA2T,WAAA,SAAArT,EAAAyM,EAAA0F,GACA,MACApP,GAAA/C,EAAA+K,UAAArL,KAAA4T,WAAAtT,EAAA+K,SAAA0B,GACA1J,EAAA/C,EAAAuT,aAAA7T,KAAA8T,QAAAxT,EAAAuT,YAAA9G,GACA1J,EAAA/C,EAAAyT,kBAAA/T,KAAAgU,aAAA1T,EAAAyT,iBAAAhH,EAAA0F,GACA,MAmBAzS,KAAA4T,WAAA,SAAAvI,EAAA0B,GACA,MAAAnB,GAAAP,KAAA0B,GAAA1B,GAiBArL,KAAA8T,QAAA,SAAAjS,EAAAkL,GAEA,MADAnB,GAAA/J,SAAAkL,IACA,MAAAlL,EAAA,KACAL,EACAjG,IAAAsG,GAAmBwD,MAAAqO,EAAAvF,SAAkC8F,OAAA,eACrDnG,KAAA,SAAAhC,GAAkC,MAAAA,GAAA5O,QAkBlC8C,KAAAgU,aAAA,SAAA7P,EAAA4I,EAAA0F,GACA,MAAApB,GAAA6B,OAAA/O,EAAA,KAAAsO,IAAuD1F,YAyEvD,QAAAmH,GAAAC,EAAA7T,EAAA8T,GAwBA,QAAAC,GAAA/W,EAAAxF,EAAAwI,EAAAgU,GAEA,GADAC,EAAA7Z,KAAA4C,GACAkT,EAAAlT,GAAA,MAAAkT,GAAAlT,EACA,iCAAAuM,KAAAvM,GAAA,SAAA9E,OAAA,2BAAA8E,EAAA,iBAAA6W,EAAA,IACA,IAAApH,EAAAzP,GAAA,SAAA9E,OAAA,6BAAA8E,EAAA,iBAAA6W,EAAA,IAEA,OADApH,GAAAzP,GAAA,GAAAkX,GAAAC,MAAAnX,EAAAxF,EAAAwI,EAAAgU,GACAvH,EAAAzP,GAGA,QAAAoX,GAAAC,EAAAR,EAAAS,EAAAC,GACA,GAAAC,IAAA,OAAA7V,EAAA0V,EAAAzJ,QAAA,wBAA+E,OAC/E,KAAAiJ,EAAA,MAAAlV,EACA,QAAA2V,GACA,OAAAE,GAAA,SAAAD,EAAA,QAAuE,MACvE,QACA5V,IAAAiM,QAAA,UACA4J,GAAA,gBACA,MACA,SAAAA,GAAA,IAAAF,EAAA,UAEA,MAAA3V,GAAA6V,EAAA,GAAAX,EAAAW,EAAA,GAOA,QAAAC,GAAA5U,EAAA6U,GACA,GAAA1X,GAAA2X,EAAAC,EAAApd,EAAAqd,CAUA,OATA7X,GAAA6C,EAAA,IAAAA,EAAA,GACAgV,EAAA7U,EAAAyM,OAAAzP,GACA4X,EAAAf,EAAAiB,UAAAC,EAAAlV,EAAAmV,OACAL,EAAAD,EAAA7U,EAAA,GAAAA,EAAA,UAAAA,EAAA,cAEA8U,IACAnd,EAAA0c,EAAA1c,KAAAmd,IAAA9F,EAAAqF,EAAA1c,KAAA,WAAyEqc,QAAA,GAAAxF,QAAAsG,EAAA3U,EAAAiV,gBAAA,IAAAtQ,OAIzE3H,KAAA2X,SAAAC,UAAApd,OAAAqd,OA9DA7U,EAAA+D,GAAmB0I,WAAawF,EAAAjS,QAehC,IAEAH,GAFAqV,EAAA,wFACAC,EAAA,4FACAC,EAAA,IAAAL,EAAA,EACAM,EAAA3V,KAAA2V,YACAnF,EAAA4D,IAAArH,UACAA,EAAA/M,KAAA+M,OAAAqH,IAAArH,OAAA6I,QAAA,GAAApB,GAAAqB,SACAtB,IAyBAvU,MAAA8V,OAAA3B,CAqBA,KADA,GAAAjc,GAAAwW,EAAAwG,GACA/U,EAAAqV,EAAAO,KAAA5B,MACAjc,EAAA6c,EAAA5U,QACAjI,EAAAgd,QAAAza,QAAA,WAEAiU,EAAA2F,EAAAnc,EAAAoF,GAAApF,EAAAJ,KAAAI,EAAAid,IAAA,QACAO,GAAAhB,EAAAxc,EAAAgd,QAAAxG,EAAA5W,KAAAqc,QAAA2B,OAAApH,EAAAkG,OAAAlG,EAAAsH,YACAL,EAAAjb,KAAAxC,EAAAgd,SACAG,EAAAG,EAAAS,SAEAf,GAAAf,EAAAiB,UAAAC,EAGA,IAAAnZ,GAAAgZ,EAAAza,QAAA,IAEA,IAAAyB,GAAA,GACA,GAAAga,GAAAlW,KAAAmW,aAAAjB,EAAAE,UAAAlZ,EAIA,IAHAgZ,IAAAE,UAAA,EAAAlZ,GACA8D,KAAAoW,WAAAjC,EAAAiB,UAAA,EAAAC,EAAAnZ,GAEAga,EAAA/Z,OAAA,EAEA,IADAkZ,EAAA,EACAlV,EAAAsV,EAAAM,KAAAG,IACAhe,EAAA6c,EAAA5U,MACAuO,EAAA2F,EAAAnc,EAAAoF,GAAApF,EAAAJ,KAAAI,EAAAid,IAAA,UACAE,EAAAG,EAAAS,cAKAjW,MAAAoW,WAAAjC,EACAnU,KAAAmW,aAAA,EAGAT,IAAAhB,EAAAQ,IAAA5U,EAAA+V,YAAA,aACAV,EAAAjb,KAAAwa,GAEAlV,KAAAiV,OAAA,GAAAtG,QAAA+G,EAAApV,EAAAiV,gBAAA,IAAAtQ,GACAjF,KAAAsW,OAAAX,EAAA,GACA3V,KAAAuW,aAAAhC,EAsPA,QAAAiC,GAAAlW,GACA+D,EAAArE,KAAAM,GAwKA,QAAAmW,KASA,QAAAC,GAAA1L,GAA6B,aAAAA,IAAAvF,WAAAyF,QAAA,WAAAA,QAAA,aAAAF,EAC7B,QAAA2L,GAAA3L,GAA+B,aAAAA,IAAAvF,WAAAyF,QAAA,YAAAA,QAAA,WAAAF,EAyD/B,QAAA4L,KACA,OACAP,OAAAQ,EACAtB,gBAAAuB,GAIA,QAAAC,GAAAtb,GACA,MAAAmQ,GAAAnQ,IAAAkP,EAAAlP,IAAAmQ,EAAAnQ,IAAAU,OAAA,IAqOA,QAAA6a,KACA,KAAAC,EAAA9a,QAAA,CACA,GAAArE,GAAAmf,EAAAC,OACA,IAAApf,EAAAqc,QAAA,SAAA3b,OAAA,oDACA6H,GAAAgE,OAAA8S,EAAArf,EAAAiD,MAAAqc,EAAAlE,OAAApb,EAAAuf,OA6HA,QAAAxB,GAAA9I,GACA1I,EAAArE,KAAA+M,OAjbAyH,EAAAxU,IAEA,IASiBoX,GATjBN,KAAAD,KAAAS,KASAH,KAAiBI,KAAAN,KAAAO,GACjB7C,QACA8C,OAAAf,EACAgB,OAAAf,EAGAgB,GAAA,SAAA3M,GAAyB,aAAAA,IAAA3H,EAAA2H,IAAA,gBAAAA,IACzBmJ,QAAA,UAEAyD,OACAH,OAAAf,EACAgB,OAAA,SAAA1M,GAA6B,MAAA7I,UAAA6I,EAAA,KAC7B2M,GAAA,SAAA3M,GAAyB,MAAA3H,GAAA2H,IAAAhL,KAAA0X,OAAA1M,EAAAvF,cAAAuF,GACzBmJ,QAAA,OAEA0D,MACAJ,OAAA,SAAAzM,GAA6B,MAAAA,GAAA,KAC7B0M,OAAA,SAAA1M,GAA6B,WAAA7I,SAAA6I,EAAA,KAC7B2M,GAAA,SAAA3M,GAAyB,MAAAA,iBACzBmJ,QAAA,OAEA2D,MACAL,OAAA,SAAAzM,GACA,MAAAhL,MAAA2X,GAAA3M,IAEAA,EAAA+M,eACA,KAAA/M,EAAAgN,WAAA,IAAAxZ,MAAA,KACA,IAAAwM,EAAAiN,WAAAzZ,MAAA,KACAsD,KAAA,KAJAmD,GAMAyS,OAAA,SAAA1M,GACA,GAAAhL,KAAA2X,GAAA3M,GAAA,MAAAA,EACA,IAAA6D,GAAA7O,KAAAkY,QAAAnC,KAAA/K,EACA,OAAA6D,GAAA,GAAApL,MAAAoL,EAAA,GAAAA,EAAA,KAAAA,EAAA,IAAA5J,GAEA0S,GAAA,SAAA3M,GAAyB,MAAAA,aAAAvH,QAAA0U,MAAAnN,EAAAoN,YACzBC,OAAA,SAAAxZ,EAAAC,GAA+B,MAAAkB,MAAA2X,GAAA9Y,IAAAmB,KAAA2X,GAAA7Y,IAAAD,EAAAyZ,gBAAAxZ,EAAAwZ,eAC/BnE,QAAA,0DACA+D,QAAA,yDAEAK,MACAd,OAAApX,EAAA0E,OACA2S,OAAArX,EAAAsE,SACAgT,GAAAtX,EAAAkS,SACA8F,OAAAhY,EAAAgY,OACAlE,QAAA,UAEAqE,KACAf,OAAApX,EAAAoY,SACAf,OAAArX,EAAAoY,SACAJ,OAAAhY,EAAAgY,OACAlE,QAAA,MAkBAsC,GAAAiC,kBAAA,SAAApY,GACA,IAAAyW,EAAAzW,EAAA7E,OAAA,MAAA6E,GAAA7E,KACA,KAAA2b,EAAA,SAAA5e,OAAA,8DACA,OAAA4e,GAAAlE,OAAA5S,EAAA7E,QAcAuE,KAAAuV,gBAAA,SAAA9Z,GAGA,MAFA4H,GAAA5H,KACAqb,EAAArb,GACAqb,GAcA9W,KAAA2Y,WAAA,SAAAld,GAGA,MAFA4H,GAAA5H,KACAob,EAAApb,GACAob,GAkBA7W,KAAAsX,oBAAA,SAAA7b,GACA,IAAA4H,EAAA5H,GAAA,MAAA6b,EACA,IAAA7b,iBAAA+H,EAAA/H,GACA,SAAAjD,OAAA,0BAAAiD,EAAA,kDAEA,OADA6b,GAAA7b,EACAA,GAeAuE,KAAA4Y,QAAA,SAAAzE,EAAA7T,GACA,UAAA4T,GAAAC,EAAA9P,EAAAuS,IAAAtW,KAeAN,KAAA6Y,UAAA,SAAAC,GACA,IAAAvG,EAAAuG,GAAA,QACA,IAAA7Z,KAOA,OALAoL,GAAA6J,EAAAjZ,UAAA,SAAA+P,EAAAjQ,GACA6Q,EAAAZ,KACA/L,KAAAoE,EAAAyV,EAAA/d,KAAA6Q,EAAAkN,EAAA/d,OAGAkE,GA8GAe,KAAAlI,KAAA,SAAAiD,EAAAge,EAAAC,GACA,IAAA3V,EAAA0V,GAAA,MAAA5B,GAAApc,EACA,IAAAoc,EAAAjc,eAAAH,GAAA,SAAAvC,OAAA,iBAAAuC,EAAA,8BAOA,OALAoc,GAAApc,GAAA,GAAAyb,GAAAnS,GAAoCtJ,QAAage,IACjDC,IACA/B,EAAAvc,MAAsBK,OAAAsc,IAAA2B,IACtBzB,GAAAP,KAEAhX,MAaAqK,EAAAmN,EAAA,SAAA1f,EAAAiD,GAA8Coc,EAAApc,GAAA,GAAAyb,GAAAnS,GAAiCtJ,QAAWjD,MAC1Fqf,EAAAhI,EAAAgI,MAGAnX,KAAAsE,MAAA,qBAAA+M,GAQA,MAPA+F,GAAA/F,EACAkG,KACAP,IAEA3M,EAAAmN,EAAA,SAAA1f,EAAAiD,GACAoc,EAAApc,KAAAoc,EAAApc,GAAA,GAAAyb,GAAA1e,MAEAkI,OAGAA,KAAAyU,MAAA,SAAAnX,EAAAxF,EAAAwI,EAAAgU,GAYA,QAAA2E,GAAA3Y,GACA,GAAA0J,GAAAuI,EAAAjS,GAAAoP,EAAApP,MACA4Y,EAAA,KAAAze,EAAAuP,EAAA,eAAAvP,EAAAuP,EAAA,SACA,KAAAvP,EAAAuP,EAAA,gBAAAvP,EAAAuP,EAAA,QAGA,OAFAkP,KAAA5Y,GAAiC7E,MAAA6E,IACjCA,EAAA6Y,KAAApC,EAAAzW,EAAA7E,OAAA6E,EAAA7E,MAAA,WAA6E,MAAA6E,GAAA7E,OAC7E6E,EAGA,QAAA8Y,GAAA9Y,EAAA+Y,EAAA/E,GACA,GAAAhU,EAAAxI,MAAAuhB,EAAA,SAAA7gB,OAAA,UAAA8E,EAAA,iCACA,OAAA+b,KACA/Y,EAAAxI,KAEAuI,EAAAmD,SAAAlD,EAAAxI,MACAqf,EAAA7W,EAAAxI,MACAwI,EAAAxI,eAAA0e,GACAlW,EAAAxI,KACA,GAAA0e,GAAAlW,EAAAxI,MANA,WAAAwc,EAAA6C,EAAAqB,IAAArB,EAAAxC,OAUA,QAAA2E,KACA,GAAAC,IAA2B3J,MAAA,WAAA0E,EAAA,WAC3BkF,EAAAlc,EAAAuR,MAAA,UAAwDe,YACxD,OAAAvL,GAAAkV,EAAAC,EAAAlZ,GAAAsP,MAMA,QAAA6J,GAAAnZ,EAAA0V,GACA,GAAApB,GAAAtU,EAAAsU,MACA,KAAAoB,GAAApB,OAAA,QACA,KAAAvR,EAAAuR,IAAA,MAAAA,EAAA,MAAA0C,EACA,IAAA1C,QAAApR,EAAAoR,GAAA,MAAAA,EACA,UAAApc,OAAA,2BAAAoc,EAAA,uDAGA,QAAA8E,GAAApZ,EAAAqZ,EAAA3D,EAAApB,GACA,GAAA1J,GAAA0O,EAAAC,IACS9J,KAAA,GAAA+J,GAAA9D,GAAA2D,EAAA1U,EAAA,KACA8K,KAAA,KAAA+J,GAAA9D,GAAA2D,EAAA1U,EAAA,IAMT,OAJAiG,GAAAP,EAAArK,EAAA4K,SAAA5K,EAAA4K,WACA1H,EAAAoR,IACA1J,EAAAxQ,MAAsBqV,KAAA6E,EAAAkF,GAAA7U,IACtB2U,EAAAzI,EAAAjG,EAAA,SAAAnM,GAAoD,MAAAA,GAAAgR,OACpD5K,EAAA0U,EAAA,SAAA9a,GAAmD,WAAAtE,EAAAmf,EAAA7a,EAAAgR,QAAoDiB,OAAA9F,GAMvG,QAAAwN,KACA,IAAAtB,EAAA,SAAA5e,OAAA,8DACA,IAAAuhB,GAAA3C,EAAAlE,OAAA5S,EAAA6Y,KACA,WAAAY,OAAA9U,IAAAuJ,EAAA1W,KAAA6f,GAAAoC,GACA,SAAAvhB,OAAA,kBAAAuhB,EAAA,oBAAAvL,EAAAlR,GAAA,iCAAAkR,EAAA1W,KAAAiD,KAAA,IACA,OAAAgf,GAOA,QAAAC,GAAAve,GACA,QAAAwe,GAAAjP,GAAmC,gBAAApK,GAAuB,MAAAA,GAAAmP,OAAA/E,GAC1D,QAAAkP,GAAAze,GACA,GAAA0e,GAAAhJ,EAAAhM,EAAAqJ,EAAAtD,QAAA+O,EAAAxe,IAAA,SAAAmF,GAAyF,MAAAA,GAAAkZ,IACzF,OAAAK,GAAAhe,OAAAge,EAAA,GAAA1e,EAGA,MADAA,GAAAye,EAAAze,GACA4H,EAAA5H,GAAA+S,EAAA1W,KAAAsiB,WAAA3e,GAAAid,IAGA,QAAAjT,KAAyB,gBAAUnI,EAAA,IAAAxF,EAAA,aAAA8c,EAAA,eAAAoB,EAAA,IAvFnC,GAAAxH,GAAAxO,IACAM,GAAA2Y,EAAA3Y,GACAxI,EAAAshB,EAAA9Y,EAAAxI,EAAAwc,EACA,IAAAqF,GAAAL,GACAxhB,GAAA6hB,EAAA7hB,EAAAuiB,SAAAV,EAAA,WAAArF,GAAAxc,EACA,WAAAA,EAAAiD,MAAA4e,GAAA,SAAArF,GAAAhU,EAAA7E,QAAAwJ,IACA3E,EAAA7E,MAAA,GACA,IAAAua,GAAA1V,EAAA7E,QAAAwJ,EACA2P,EAAA6E,EAAAnZ,EAAA0V,GACA9K,EAAAwO,EAAApZ,EAAAqZ,EAAA3D,EAAApB,EAgFAvQ,GAAArE,MACA1C,KACAxF,OACAwc,WACA1E,MAAA+J,EACA/E,SACA1J,UACA8K,aACAva,MAAAue,EACAM,QAAArV,EACA3E,SACAmF,cAQAoQ,EAAA5a,WACA2a,MAAA,WACA,MAAAzG,GAAAnP,KAAAqE,EAAA,GAAAwR,IAAmD0E,SAAAva,SAEnDwa,OAAA,WAGA,IAFA,GAAAxQ,MAAAyQ,KAAA9b,EAAAqB,KACA0a,EAAAhL,EAAAmG,EAAA5a,WACA0D,GAAsB8b,EAAA/f,KAAAiE,GAAoBA,IAAA4b,QAO1C,OANAE,GAAAE,UACAtQ,EAAAoQ,EAAA,SAAAG,GACAvQ,EAAAqF,EAAAkL,GAAA,SAAAnW,GACA,KAAAhK,EAAAuP,EAAAvF,IAAA,KAAAhK,EAAAigB,EAAAjW,IAAAuF,EAAAtP,KAAA+J,OAGAuF,GAEA8H,SAAA,SAAA+I,GACA,GAAAhK,MAAqBrC,EAAAxO,IAIrB,OAHAqK,GAAAmE,EAAAgM,SAAA,SAAA/V,GACAoM,EAAApM,GAAA+J,EAAA/J,GAAAhJ,MAAAof,KAAApW,MAEAoM,GAEAiK,SAAA,SAAAC,EAAAC,GACA,GAAAC,MAAAzM,EAAAxO,IAKA,OAJAqK,GAAAmE,EAAAgM,SAAA,SAAA/V,GACA,GAAAyW,GAAAH,KAAAtW,GAAA0W,EAAAH,KAAAvW,EACA+J,GAAA/J,GAAA3M,KAAAugB,OAAA6C,EAAAC,KAAAF,QAEAA,GAEAG,YAAA,SAAAP,GACA,GAAA3e,GAAAwS,EAAA2M,EAAAC,EAAAC,EAAAvR,EAAAhK,KAAAwa,QACA,KAAAte,EAAA,EAAiBA,EAAA8N,EAAA7N,SACjBuS,EAAA1O,KAAAgK,EAAA9N,IACAmf,EAAAR,EAAA7Q,EAAA9N,IACAmf,IAAApW,GAAA,OAAAoW,IAAA3M,EAAAsH,YAHkC9Z,IAAA,CAMlC,GADAof,EAAA5M,EAAA5W,KAAAsiB,WAAAiB,IACA3M,EAAA5W,KAAA6f,GAAA2D,GACA,QAEA,IADAC,EAAA7M,EAAA5W,KAAA2f,OAAA6D,GACAjb,EAAAmD,SAAA+X,KAAA7M,EAAA5W,KAAAqc,QAAA4B,KAAAwF,GACA,SAEA,UAEAhB,SAAAtV,GAGAjF,KAAA6V,WAwBA,QAAA2F,GAAAC,EAAAC,GAIA,QAAAC,GAAAC,GACA,GAAAtF,GAAA,kDAA4DP,KAAA6F,EAAA9F,OAC5D,cAAAQ,IAAA,GAAApL,QAAA,kBAIA,QAAA2Q,GAAA1H,EAAAtF,GACA,MAAAsF,GAAAjJ,QAAA,iBAAyC,SAAA/K,EAAA2b,GACzC,MAAAjN,GAAA,MAAAiN,EAAA,EAAAjM,OAAAiM,MAmFA,QAAAC,GAAA1K,EAAA2K,EAAAnN,GACA,IAAAA,EAAA,QACA,IAAA5P,GAAAoS,EAAA6B,OAAA8I,KAAqDC,OAAApN,GACrD,OAAAxL,GAAApE,QAwJA,QAAAqF,GAAA4X,EAAAC,EAAA9K,EAAApO,EAAAmZ,GAIA,QAAAC,GAAAxa,EAAAya,EAAAC,GACA,YAAAvY,EAAAnC,EACAya,EAAAtY,EAAAxF,MAAA,MAAAqD,EACA0a,EAAAvY,EAAAxF,MAAA,GAAAqD,EACAA,EAIA,QAAA3I,GAAAsjB,GAOA,QAAA9f,GAAA+f,GACA,GAAAC,GAAAD,EAAApL,EAAA6K,EAEA,OAAAQ,IACAlZ,EAAAkZ,IAAAR,EAAAhR,UAAArJ,IAAA6a,QACA,EAXA,IAAAF,MAAAG,iBAAA,CACAC,GAAAV,EAAAra,QAAA+a,EACAA,EAAA3X,CAWA,IAAA/I,GAAAuT,EAAAoN,EAAA1gB,MAEA,KAAAD,EAAA,EAAiBuT,EAAAvT,EAAOA,IACxB,GAAAQ,EAAAmgB,EAAA3gB,IAAA,MAGA4gB,IAAApgB,EAAAogB,IAGA,QAAAC,KAEA,MADAC,MAAAb,EAAAc,IAAA,yBAAA/jB,GAlCA,GAAA0jB,GAAA5Y,EAAAf,EAAAe,WAAAsQ,EAAA4H,EAAAra,KAwCA,OAFAqb,IAAAH,KA6BAI,KAAA,WACAjkB,KAGA6jB,OAAA,WACA,MAAAA,MAGA7jB,OAAA,SAAAkkB,GACA,MAAAA,QACA9I,EAAA4H,EAAAra,YAGAqa,EAAAra,QAAAyS,IAEA4H,EAAAra,IAAAyS,GACA4H,EAAAhR,aAGAxQ,KAAA,SAAA2iB,EAAAtQ,EAAA5O,GACA,GAAA0D,GAAAwb,EAAAC,OAAAvQ,MAGA,QAAAlL,GAAAkL,KAAA,OACAlL,GAAA,IAAAkL,EAAA,MAGAmP,EAAAra,OACA+a,EAAAze,KAAAof,cAAArB,EAAAra,MAAAoD,EACA9G,KAAA+M,SAAAgR,EAAAhR,WA4BAsS,KAAA,SAAAH,EAAAtQ,EAAA5O,GACA,IAAAkf,EAAAI,UAAA1Q,GAAA,WAEA,IAAAuP,GAAAb,EAAAiC,WACArd,GAAAkS,SAAA+J,KACAA,IAAAqB,SAGArB,KAAAF,EAAAwB,OAEA,IAAA/b,GAAAwb,EAAAC,OAAAvQ,EAcA,IAbA5O,QAEAme,GAAA,OAAAza,IACAA,EAAA,IAAA4Z,EAAAoC,aAAAhc,GAIA,OAAAA,GAAAkL,KAAA,OACAlL,GAAA,IAAAkL,EAAA,MAGAlL,EAAAwa,EAAAxa,EAAAya,EAAAne,EAAAoe,WAEApe,EAAAoe,WAAA1a,EACA,MAAAA,EAGA,IAAAic,IAAAxB,GAAAza,EAAA,OAAAkc,EAAA7B,EAAA6B,MAGA,OAFAA,GAAA,KAAAA,GAAA,MAAAA,EAAA,OAAAA,GAEA7B,EAAA8B,WAAA,MAAA9B,EAAA+B,OAAAF,EAAAD,EAAAjc,GAAAC,KAAA,MAtZA,GAAAkb,GAAAH,KAAAC,EAAA,KAAAI,IA8CAld,MAAAyc,KAAA,SAAAA,GACA,IAAA7Q,EAAA6Q,GAAA,SAAAjkB,OAAA,4BAEA,OADAqkB,GAAAniB,KAAA+hB,GACAzc,MAkCAA,KAAA8c,UAAA,SAAAL,GACA,GAAAjZ,EAAAiZ,GAAA,CACA,GAAAyB,GAAAzB,CACAA,GAAA,WAA0B,MAAAyB,QAE1B,KAAAtS,EAAA6Q,GAAA,SAAAjkB,OAAA,4BAEA,OADAskB,GAAAL,EACAzc,MAiDAA,KAAA4R,KAAA,SAAAkK,EAAAE,GACA,GAAAkC,GAAAC,EAAA3a,EAAAwY,EAGA,IAFAxY,EAAAsY,OAAAJ,EAAA9C,QAAAkD,KAEAqC,IAAAvS,EAAAoQ,KAAArR,EAAAqR,GACA,SAAAxjB,OAAA,8BAEA,IAAA4lB,IACAC,QAAA,SAAAvC,EAAAE,GAKA,MAJAmC,KACAD,EAAAxC,EAAA9C,QAAAoD,GACAA,GAAA,kBAAAC,GAAkD,MAAAiC,GAAAZ,OAAArB,MAElD5X,EAAA,SAAAgN,EAAA6K,GACA,MAAAH,GAAA1K,EAAA2K,EAAAF,EAAA/F,KAAAmG,EAAA/Y,OAAA+Y,EAAAhG,aAEAI,OAAA9S,EAAAsY,EAAAxF,QAAAwF,EAAAxF,OAAA,MAGAgI,MAAA,SAAAxC,EAAAE,GACA,GAAAF,EAAAyC,QAAAzC,EAAA0C,OAAA,SAAAhmB,OAAA,6CAMA,OAJA2lB,KACAD,EAAAlC,EACAA,GAAA,kBAAAC,GAAkD,MAAAJ,GAAAqC,EAAAjC,MAElD5X,EAAA,SAAAgN,EAAA6K,GACA,MAAAH,GAAA1K,EAAA2K,EAAAF,EAAA/F,KAAAmG,EAAA/Y,WAEAmT,OAAAqF,EAAAG,OAKApf,GAAiB2hB,QAAA3C,EAAA7C,UAAAiD,GAAAwC,MAAAxC,YAAAnN,QAEjB,QAAAc,KAAA/S,GACA,GAAAA,EAAA+S,GAAA,MAAAzP,MAAAyc,KAAA2B,EAAA3O,GAAAqM,EAAAE,GAGA,UAAAxjB,OAAA,6BAmDAwH,KAAAye,eAAA,SAAA/Q,GACAA,IAAAzI,IAAAyI,MACAwP,EAAAxP,GAeA1N,KAAAsE,OACAA,EAAAY,SAAA,4DA4LA,QAAAwZ,GAAAC,EAAAjD,GA0FA,QAAAkD,GAAAC,GACA,WAAAA,EAAApkB,QAAA,UAAAokB,EAAApkB,QAAA,KAGA,QAAAqkB,GAAAC,EAAAC,GACA,IAAAD,EAAA,MAAA9Z,EAEA,IAAAga,GAAAzb,EAAAub,GACAhkB,EAAAkkB,EAAAF,IAAAhkB,KACAoI,EAAAyb,EAAA7jB,EAEA,IAAAoI,EAAA,CACA,IAAA6b,EAAA,SAAAxmB,OAAA,sCAAAuC,EAAA,IACAikB,GAAAF,EAAAE,EAIA,KAFA,GAAAE,GAAAnkB,EAAAkP,MAAA,KAAA/N,EAAA,EAAAijB,EAAAD,EAAA/iB,OAAAijB,EAAAJ,EAEYG,EAAAjjB,EAAgBA,IAC5B,QAAAgjB,EAAAhjB,IAAA,IAAAA,EAAA,CAIA,SAAAgjB,EAAAhjB,GAKA,KAJA,KAAAkjB,EAAAzgB,OAAA,SAAAnG,OAAA,SAAAuC,EAAA,0BAAAikB,EAAAjkB,KAAA,IACAqkB,KAAAzgB,WALAygB,GAAAJ,CAUAE,KAAA1gB,MAAAtC,GAAA4F,KAAA,KACA/G,EAAAqkB,EAAArkB,MAAAqkB,EAAArkB,MAAAmkB,EAAA,QAAAA,EAEA,GAAAG,GAAAC,EAAAvkB,EAEA,QAAAskB,IAAAJ,OAAAI,IAAAN,GAAAM,EAAA7Q,OAAAuQ,GAGA9Z,EAFAoa,EAKA,QAAAE,GAAAC,EAAAH,GACA9gB,EAAAihB,KACAjhB,EAAAihB,OAEAjhB,EAAAihB,GAAA9kB,KAAA2kB,GAGA,QAAAI,GAAAD,GAEA,IADA,GAAAE,GAAAnhB,EAAAihB,OACAE,EAAAvjB,QACAwjB,EAAAD,EAAAxI,SAIA,QAAAyI,GAAAN,GAEAA,EAAAlQ,EAAAkQ,GACA7Q,KAAA6Q,EACAzR,QAAAyR,EAAAzR,YACAnI,SAAA,WAA4B,MAAAzF,MAAAjF,OAG5B,IAAAA,GAAAskB,EAAAtkB,IACA,KAAAyI,EAAAzI,MAAAN,QAAA,iBAAAjC,OAAA,+BACA,IAAA8mB,EAAApkB,eAAAH,GAAA,SAAAvC,OAAA,UAAAuC,EAAA,uBAGA,IAAAykB,GAAA,KAAAzkB,EAAAN,QAAA,KAAAM,EAAAqa,UAAA,EAAAra,EAAA6kB,YAAA,MACApc,EAAA6b,EAAA1gB,QAAA0gB,EAAA1gB,OACA4T,EAAA8M,EAAA1gB,SAAA6E,EAAA6b,EAAA1gB,OAAA5D,MAAAskB,EAAA1gB,OAAA5D,KACA,EAGA,IAAAykB,IAAAF,EAAAE,GACA,MAAAD,GAAAC,EAAAH,EAAA7Q,KAGA,QAAA/J,KAAAob,GACAjU,EAAAiU,EAAApb,MAAA4a,EAAA5a,GAAAob,EAAApb,GAAA4a,EAAAQ,EAAAC,WAAArb,IAgBA,OAdA6a,GAAAvkB,GAAAskB,GAGAA,EAAAU,IAAAV,EAAAxd,KACA8c,EAAA/M,KAAAyN,EAAAxd,KAAA,iCAAAoa,EAAA+D,GACAC,EAAA3P,SAAA4P,WAAAb,GAAA1O,EAAAsL,EAAA+D,IACAC,EAAAE,aAAAd,EAAApD,GAA8C9M,WAAAmF,iBAM9CmL,EAAA1kB,GAEAskB,EAIA,QAAAe,GAAA9a,GACA,MAAAA,GAAA7K,QAAA,QAIA,QAAA4lB,GAAAC,GAKA,OAJAC,GAAAD,EAAArW,MAAA,KACA0L,EAAAsK,EAAA3P,SAAAvV,KAAAkP,MAAA,KAGA/N,EAAA,EAAAY,EAAAyjB,EAAApkB,OAA4CW,EAAAZ,EAAOA,IACnD,MAAAqkB,EAAArkB,KACAyZ,EAAAzZ,GAAA,IAeA,OAVA,OAAAqkB,EAAA,KACA5K,IAAAnX,MAAA/D,EAAAkb,EAAA4K,EAAA,KACA5K,EAAA6K,QAAA,OAGA,OAAAD,IAAApkB,OAAA,KACAwZ,EAAAlZ,OAAAhC,EAAAkb,EAAA4K,IAAApkB,OAAA,MAAA0T,OAAA4Q,WACA9K,EAAAjb,KAAA,OAGA6lB,EAAApkB,QAAAwZ,EAAAxZ,UAIAwZ,EAAA7T,KAAA,MAAAye,EAAAze,KAAA,IA0GA,QAAA4e,GAAA3lB,EAAA4lB,GAEA,MAAAnd,GAAAzI,KAAAsI,EAAAsd,GACAd,EAAA9kB,GAEA6Q,EAAA+U,IAAAnd,EAAAzI,IAGA8kB,EAAA9kB,KAAA8kB,EAAAC,WAAA/kB,KACA8kB,EAAAC,WAAA/kB,GAAA8kB,EAAA9kB,IAEA8kB,EAAA9kB,GAAA4lB,EACA3gB,MANAA,KAyUA,QAAAqf,GAAAtkB,EAAAge,GAKA,MAHAxG,GAAAxX,GAAAge,EAAAhe,EACAge,EAAAhe,OACA4kB,EAAA5G,GACA/Y,KA6BA,QAAAsE,GAAA6X,EAAAtR,EAAA+V,EAAAvP,EAAAwP,EAAAb,EAAAc,EAAA5E,EAAAR,GASA,QAAAqF,GAAA7C,EAAAmB,EAAAtS,EAAA5O,GAiCA,GAAAqe,GAAAL,EAAA6E,WAAA,iBAAA9C,EAAAmB,EAAAtS,EAEA,IAAAyP,EAAAG,iBAEA,MADAmE,GAAA5nB,SACA+nB,CAGA,KAAAzE,EAAA0E,MACA,WAIA,IAAA/iB,EAAAgjB,OAEA,MADAL,GAAA5nB,SACAkoB,CAEA,IAAAC,GAAApB,EAAAqB,WAAAzW,EAAA+G,KAAA4K,EAAA0E,MAWA,OATAG,GAAAvT,KAAA,WACA,MAAAuT,KAAApB,EAAAqB,WAAAC,GACArD,EAAA/f,QAAAgjB,UACAlB,EAAAE,aAAAjC,EAAApE,GAAAoE,EAAAsD,SAAAtD,EAAA/f,WACO,WACP,MAAA8iB,KAEAH,EAAA5nB,SAEAmoB,EAwlBA,QAAAI,GAAApC,EAAAtS,EAAA2U,EAAAjR,EAAArG,EAAAjM,GAkBA,QAAAwjB,KACA,GAAAC,KAyBA,OAtBAvX,GAAAgV,EAAAwC,MAAA,SAAAC,EAAA/mB,GACA,GAAAgnB,GAAAD,EAAAlU,SAAAkU,EAAAlU,UAAAyR,EAAAzR,QAAAkU,EAAAlU,UACAmU,GAAAC,WAAA,WACA,MAAApB,GAAAqB,KAAAlnB,GAAqC+mB,OAAArP,OAAArI,EAAA8X,QAAAnV,OAAAiT,EAAAmC,OAAAhkB,EAAAgkB,UAAgF,KAGrHP,EAAAlnB,KAAAmmB,EAAAjT,QAAAmU,EAAA3X,EAAA8X,QAAA9X,EAAAwD,QAAAyR,GAAAvR,KAAA,SAAA7O,GAEA,GAAA2M,EAAAkW,EAAAM,qBAAAzX,EAAAmX,EAAAM,oBAAA,CACA,GAAAC,GAAAhiB,EAAAgE,UAAkD0d,EAAA3X,EAAA8X,QAClDjjB,GAAAqjB,aAAAjR,EAAA6B,OAAA4O,EAAAM,mBAAA,KAAAC,OAEApjB,GAAAqjB,aAAAR,EAAAS,UAGAtjB,GAAAujB,QAAAnD,EACApgB,EAAAwjB,eAAAX,EAAAY,aACAzjB,EAAA0jB,YAAAb,EAAAc,UACAxY,EAAArP,GAAAkE,OAIA4L,EAAAgY,IAAAjB,GAAA9T,KAAA,WACA,MAAA1D,GAAA8X,UAxCA,GAAAlC,GAAAvQ,EAAA1C,EAAA6D,EAAAyO,EAAAtS,OAAAyN,SAAAzN,GACA0F,GAAoBuN,eAMpB5V,GAAAwD,QAAAiT,EAAAjT,QAAAyR,EAAAzR,QAAA6E,EAAArI,EAAAwD,QAAAyR,EACA,IAAA7L,IAAApJ,EAAAwD,QAAAE,KAAA,SAAAoU,GACA9X,EAAA8X,YAoCA,OAlCAzR,IAAA+C,EAAA9Y,KAAA+V,GAkCA5F,EAAAgY,IAAArP,GAAA1F,KAAA6T,GAAA7T,KAAA,SAAA+C,GACA,MAAAzG,KA9sBA,GAAAmX,GAAA1W,EAAAmD,OAAA,GAAAxV,OAAA,0BACAsqB,EAAAjY,EAAAmD,OAAA,GAAAxV,OAAA,yBACAyoB,EAAApW,EAAAmD,OAAA,GAAAxV,OAAA,uBACA4oB,EAAAvW,EAAAmD,OAAA,GAAAxV,OAAA,qBA+sBA,OA5oBAuqB,GAAAtQ,QAAmB7E,QAAA,KAAAsU,SAA0BlC,kBAE7CC,GACAlT,UACAqS,QAAA2D,EAAAvU,KACA8B,SAAAyS,EACAzB,WAAA,MAuDArB,EAAA+C,OAAA,SAAA3D,GACA,MAAAY,GAAAE,aAAAF,EAAAb,QAAAY,GAAgEgD,OAAA3D,MAAAlQ,WAAAgT,aAuEhElC,EAAAgD,GAAA,SAAAnJ,EAAA/M,EAAA5O,GACA,MAAA8hB,GAAAE,aAAArG,EAAA/M,EAAA1I,GAAqD8K,WAAA+T,SAAAjD,EAAA3P,UAA2CnS,KA2ChG8hB,EAAAE,aAAA,SAAArG,EAAA0H,EAAArjB,GACAqjB,QACArjB,EAAAkG,GACAiQ,YAAAnF,WAAA+T,SAAA,KAAAf,UAAAa,UAAA7B,WACOhjB,MAEP,IACAqe,GADAzM,EAAAkQ,EAAA3P,SAAA6S,EAAAlD,EAAAlT,OAAAqW,EAAArT,EAAA5M,KACAkgB,EAAAvE,EAAAhF,EAAA3b,EAAA+kB,UAGAI,EAAA9B,EAAA,IAEA,KAAAne,EAAAggB,GAAA,CACA,GAAAnF,IAAwBpE,KAAA0H,WAAArjB,WACxBolB,EAAAxC,EAAA7C,EAAAnO,EAAAvB,KAAA2U,EAAAhlB,EAEA,IAAAolB,EACA,MAAAA,EAUA,IALAzJ,EAAAoE,EAAApE,GACA0H,EAAAtD,EAAAsD,SACArjB,EAAA+f,EAAA/f,QACAklB,EAAAvE,EAAAhF,EAAA3b,EAAA+kB,WAEA7f,EAAAggB,GAAA,CACA,IAAAllB,EAAA+kB,SAAA,SAAA1qB,OAAA,kBAAAshB,EAAA,IACA,UAAAthB,OAAA,sBAAAshB,EAAA,iBAAA3b,EAAA+kB,SAAA,MAGA,GAAAG,EAAAtD,GAAA,SAAAvnB,OAAA,wCAAAshB,EAAA,IAEA,IADA3b,EAAAgR,UAAAqS,EAAArR,EAAA6P,EAAAwB,MAAgFvB,EAAA3P,SAAA+S,KAChFA,EAAAtW,OAAAqO,YAAAoG,GAAA,MAAAJ,EAEAI,GAAA6B,EAAAtW,OAAA+E,SAAA0P,GACA1H,EAAAuJ,CAEA,IAAAG,GAAA1J,EAAA3W,KAGAsgB,EAAA,EAAApE,EAAAmE,EAAAC,GAAAhR,EAAAsQ,EAAAtQ,OAAAiR,IAEA,IAAAvlB,EAAA6kB,QAMO,GAAAxf,EAAArF,EAAA6kB,SAAAzQ,EAAApU,EAAA6kB,QAAA,CACP,GAAAzQ,EAAApU,EAAA6kB,UAAA7kB,EAAA6kB,OAAAjoB,KACA,SAAAvC,OAAA,8BAGA,IAAAmrB,GAAAxlB,EAAA6kB,YAAAI,EAAA,GAAAtE,EAAA3gB,EAAA6kB,OACA,IAAA7kB,EAAA6kB,SAAAW,EACA,SAAAnrB,OAAA,0BAAAgL,EAAArF,EAAA6kB,QAAA7kB,EAAA6kB,OAAA7kB,EAAA6kB,OAAAjoB,MAAA,IAGA,MAAAskB,OAAA+D,EAAAK,IAAApE,IAAAsE,GACAlR,EAAAiR,EAAAD,GAAApE,EAAA5M,OACAgR,IACApE,EAAAmE,EAAAC,QAlBA,MAAApE,OAAA+D,EAAAK,IAAApE,EAAAuE,UAAA9I,SAAA0G,EAAA2B,IACA1Q,EAAAiR,EAAAD,GAAApE,EAAA5M,OACAgR,IACApE,EAAAmE,EAAAC,EAwBA,IAAAI,EAAA/J,EAAA0H,EAAAzR,EAAAoT,EAAA1Q,EAAAtU,GAYA,MAXAmlB,KAAA9B,EAAA,KAAA8B,GACArD,EAAAlT,OAAAyU,EACA/T,EAAAwS,EAAAlT,OAAAiT,GACAvS,EAAAmD,EAAAkJ,EAAA/M,OAAAyN,SAAAwF,GAAAlG,EAAArH,OAAAyP,QAAAlC,cACA7hB,EAAAmW,UAAAwF,EAAAoG,WAAApG,EAAAoG,UAAAre,MACAif,EAAApmB,KAAAof,EAAAoG,UAAAre,IAAA2f,GACAjE,iBAAArS,QAAA,YAAA/M,EAAAmW,WAEAwM,EAAA5nB,YAEA+mB,EAAAqB,WAAA,KACAzW,EAAA+G,KAAAqO,EAAAb,QAUA,IANAoC,EAAA5Q,EAAAkJ,EAAA/M,OAAAyN,SAAAgH,OAGA8B,IAAA9B,EAAA,KAAA8B,GAGAnlB,EAAAgkB,QA4BAhG,EAAA6E,WAAA,oBAAAlH,EAAAtL,KAAAgT,EAAAzR,EAAAvB,KAAA2U,EAAAhlB,GAAAwe,iBAIA,MAHAR,GAAA6E,WAAA,qBAAAlH,EAAAtL,KAAAgT,EAAAzR,EAAAvB,KAAA2U,GAEA,MAAAlD,EAAAqB,YAAAR,EAAA5nB,SACA4pB,CAaA,QAFAgB,GAAAjZ,EAAA+G,KAAAa,GAEA3V,EAAA2mB,EAAwB3mB,EAAA0mB,EAAArnB,OAAmBW,IAAAuiB,EAAAmE,EAAA1mB,GAC3C2V,EAAAiR,EAAA5mB,GAAAqS,EAAAsD,GACAqR,EAAArC,EAAApC,EAAAmC,EAAAnC,IAAAvF,EAAAgK,EAAArR,EAAAtU,EAOA,IAAAmjB,GAAArB,EAAAqB,WAAAwC,EAAAhW,KAAA,WACA,GAAAhR,GAAAinB,EAAAC,CAEA,IAAA/D,EAAAqB,eAAA,MAAAC,EAGA,KAAAzkB,EAAAsmB,EAAAjnB,OAAA,EAAqCW,GAAA2mB,EAAW3mB,IAChDknB,EAAAZ,EAAAtmB,GACAknB,EAAAxV,KAAAyV,QACA5S,EAAA6B,OAAA8Q,EAAAxV,KAAAyV,OAAAD,EAAAxV,KAAAwV,EAAAvR,OAAAyP,SAEA8B,EAAAvR,OAAA,IAIA,KAAA3V,EAAA2mB,EAAsB3mB,EAAA0mB,EAAArnB,OAAmBW,IACzCinB,EAAAP,EAAA1mB,GACAinB,EAAAtR,OAAAiR,EAAA5mB,GACAinB,EAAAvV,KAAA0V,SACA7S,EAAA6B,OAAA6Q,EAAAvV,KAAA0V,QAAAH,EAAAvV,KAAAuV,EAAAtR,OAAAyP,QAKA,OAAAjC,GAAAqB,eAAAC,GAGAtB,EAAA3P,SAAAwJ,EACAmG,EAAAb,QAAAtF,EAAAtL,KACAyR,EAAAlT,OAAAyU,EACA/T,EAAAwS,EAAAlT,OAAAiT,GACAC,EAAAqB,WAAA,KAEAnjB,EAAAmW,UAAAwF,EAAAoG,WACAY,EAAApmB,KAAAof,EAAAoG,UAAAre,IAAAiY,EAAAoG,UAAAzN,OAAAyP,QAAAlC,cACAzC,iBAAArS,QAAA,YAAA/M,EAAAmW,WAIAnW,EAAAgkB,QAeAhG,EAAA6E,WAAA,sBAAAlH,EAAAtL,KAAAgT,EAAAzR,EAAAvB,KAAA2U,GAEArC,EAAA5nB,WAEA+mB,EAAAb,UACO,SAAAzf,GACP,MAAAsgB,GAAAqB,eAAAC,GAEAtB,EAAAqB,WAAA,KAmBA9E,EAAAL,EAAA6E,WAAA,oBAAAlH,EAAAtL,KAAAgT,EAAAzR,EAAAvB,KAAA2U,EAAAxjB,GAEA6c,EAAAG,kBACAmE,EAAA5nB,SAGA2R,EAAAmD,OAAArO,KAGA,OAAA2hB,IAqCArB,EAAAtI,GAAA,SAAAoH,EAAAhS,EAAA5O,GACAA,EAAAkG,GAAwB6e,SAAAjD,EAAA3P,UAA4BnS,MACpD,IAAAkhB,GAAAP,EAAAC,EAAA5gB,EAAA+kB,SAEA,OAAA7f,GAAAgc,GACAY,EAAA3P,WAAA+O,KACAtS,EAAA4D,EAAA0O,EAAAtS,OAAA+E,SAAA/E,GAAAiT,MAF8B/a,GAwD9Bgb,EAAAkE,SAAA,SAAApF,EAAAhS,EAAA5O,GAEA,GADAA,EAAAkG,GAAwB6e,SAAAjD,EAAA3P,UAA4BnS,OACpDqF,EAAAub,IAAAqB,EAAArB,GAAA,CACA,IAAAsB,EAAAtB,GACA,QAEAA,GAAAkB,EAAA3P,SAAAvV,KAGA,GAAAskB,GAAAP,EAAAC,EAAA5gB,EAAA+kB,SACA,OAAA7f,GAAAgc,GACAhc,EAAA4c,EAAA3P,SAAA6T,SAAA9E,EAAAtkB,OACAgS,EAAA4D,EAAA0O,EAAAtS,OAAA+E,SAAA/E,GAAAiT,EAAAtQ,EAAA3C,QAAA,EAF8B9H,GAiC9Bgb,EAAAzC,KAAA,SAAAuB,EAAAhS,EAAA5O,GACAA,EAAAkG,GACA+f,SACAjV,WACAoN,YACA2G,SAAAjD,EAAA3P,UACOnS,MAEP,IAAAkhB,GAAAP,EAAAC,EAAA5gB,EAAA+kB,SAEA,KAAA7f,EAAAgc,GAAA,WACAlhB,GAAAgR,UAAApC,EAAAoD,EAAA6P,EAAAjT,MAA4EkT,EAAA3P,SAAA+O,GAE5E,IAAAgF,GAAAhF,GAAAlhB,EAAAimB,MAAA/E,EAAAa,UAAAb,CAEA,OAAAgF,MAAAxiB,MAAAoD,GAAA,OAAAof,EAAAxiB,IAGAif,EAAAtD,KAAA6G,EAAAxiB,IAAA+O,EAAAyO,EAAAtS,OAAAyN,SAAAxJ,OAAA,KAAAjE,QACAwP,SAAApe,EAAAoe,WAHA,MAoBA0D,EAAA1kB,IAAA,SAAAwjB,EAAAuF,GACA,OAAAtX,UAAA7Q,OAAA,MAAAgV,GAAAzB,EAAA4P,GAAA,SAAAvkB,GAAiF,MAAAukB,GAAAvkB,GAAAyT,MACjF,IAAA6Q,GAAAP,EAAAC,EAAAuF,GAAArE,EAAA3P,SACA,OAAA+O,MAAA7Q,KAAA6Q,EAAA7Q,KAAA,MA0DAyR,EAGA,QAAA4D,GAAA/J,EAAA0H,EAAAzR,EAAAoT,EAAA1Q,EAAAtU,GAEA,QAAAomB,GAAAC,EAAArB,EAAA3B,GAEA,QAAAiD,GAAAhgB,GACA,gBAAA+f,EAAAzX,OAAAtI,GAAA6P,SAEA,GAAAoQ,GAAAF,EAAAzX,OAAAyN,SAAArV,OAAAsf,GACAE,EAAA5T,EAAAnU,UAAwC4nB,EAAAzX,QAAAiE,OAAA0T,IACxCE,EAAA,GAAApQ,GAAAqB,SAAA8O,EACA,OAAAC,GAAA9J,SAAAqI,EAAA3B,GASA,OAAArjB,EAAA6kB,QAAAlJ,IAAA/J,IACA0C,IAAA1C,EAAA0C,QAAAqH,EAAAtL,KAAAqW,qBAAAN,EAAAxU,EAAAoT,EAAA3B,OADA,OA95CA,GAAAuB,GAAuB9C,EAAvBX,KAAuB/gB,KAAoBwhB,EAAA,WAG3CF,GAKAlhB,OAAA,SAAA0gB,GACA,GAAAhc,EAAAgc,EAAA1gB,SAAA0gB,EAAA1gB,OAAA,MAAAmgB,GAAAO,EAAA1gB,OAGA,IAAAmmB,GAAA,gBAAA/O,KAAAsJ,EAAAtkB,KACA,OAAA+pB,GAAAhG,EAAAgG,EAAA,IAAA/B,GAIA7lB,KAAA,SAAAmiB,GAIA,MAHAA,GAAA1gB,QAAA0gB,EAAA1gB,OAAAzB,OACAmiB,EAAAniB,KAAAmiB,EAAA7Q,KAAAtR,KAAAiS,EAAAkQ,EAAA1gB,OAAAzB,KAAAmiB,EAAAniB,OAEAmiB,EAAAniB,MAIA2E,IAAA,SAAAwd,GACA,GAAAxd,GAAAwd,EAAAxd,IAAAvB,GAAqCyM,OAAAsS,EAAAtS,WAErC,IAAAvJ,EAAA3B,GACA,WAAAA,EAAAyI,OAAA,GAAAoR,EAAA9C,QAAA/W,EAAAuT,UAAA,GAAA9U,IACA+e,EAAA1gB,OAAAuhB,WAAA6C,GAAAlhB,IAAAmP,OAAAnP,EAAAvB,EAGA,KAAAuB,GAAA6Z,EAAA7C,UAAAhX,GAAA,MAAAA,EACA,UAAArJ,OAAA,gBAAAqJ,EAAA,eAAAwd,EAAA,MAIAa,UAAA,SAAAb,GACA,MAAAA,GAAAxd,IAAAwd,IAAA1gB,OAAA0gB,EAAA1gB,OAAAuhB,UAAA,MAIA0D,UAAA,SAAAvE,GACA,GAAAtS,GAAAsS,EAAAxd,KAAAwd,EAAAxd,IAAAkL,QAAA,GAAAyH,GAAAqB,QAIA,OAHAxL,GAAAgV,EAAAtS,WAAgC,SAAAzM,EAAAhD,GAChCyP,EAAAzP,KAAAyP,EAAAzP,GAAA,GAAAkX,GAAAC,MAAAnX,EAAA,KAAAgD,EAAA,aAEAyM,GAIAA,OAAA,SAAAsS,GACA,GAAAuE,GAAA7S,EAAAsO,EAAAuE,UAAAvE,EAAAuE,UAAApJ,SACA,OAAA6E,GAAA1gB,QAAA0gB,EAAA1gB,OAAAoO,OAAA1I,EAAAgb,EAAA1gB,OAAAoO,OAAA6I,QAAAgO,GAAA,GAAApP,GAAAqB,UAQAgM,MAAA,SAAAxC,GACA,GAAAwC,KAOA,OALAxX,GAAAhH,EAAAgc,EAAAwC,OAAAxC,EAAAwC,OAAsDkD,GAAA1F,GAAY,SAAAyC,EAAA/mB,GAClEA,EAAAN,QAAA,SAAAM,GAAA,IAAAskB,EAAA1gB,OAAA5D,MACA+mB,EAAAc,UAAAd,EAAAc,WAAAvD,EAAAuD,WAAA,WACAf,EAAA9mB,GAAA+mB,IAEAD,GAIA1e,KAAA,SAAAkc,GACA,MAAAA,GAAA1gB,OAAA0gB,EAAA1gB,OAAAwE,KAAA6N,OAAAqO,OAIA8E,SAAA,SAAA9E,GACA,GAAA8E,GAAA9E,EAAA1gB,OAAA0F,KAA6Cgb,EAAA1gB,OAAAwlB,YAE7C,OADAA,GAAA9E,EAAAtkB,SACAopB,GAGArE,cAyIAiD,GAAApD,GACA5kB,KAAA,GACA8G,IAAA,IACAggB,MAAA,KACAmD,gBAEAjC,EAAA7C,UAAA,KA8FAlgB,KAAA0gB,YA+UA1gB,KAAAqf,QAiCArf,KAAAsE,OACAA,EAAAY,SAAA,+GAgwBA,QAAA+f,KAcA,QAAA3gB,GAAA6X,EAAA+I,GACA,OAYAjD,KAAA,SAAAlnB,EAAAoD,GACA,GAAAc,GAAAuB,GACA6K,SAAA,KAAAkX,WAAA,KAAAT,KAAA,KAAArP,OAAA,KAAA0P,UAAAgD,SAAApY,UAOA,OALA5O,GAAAkG,EAAA7D,EAAArC,GAEAA,EAAA2jB,OACA7iB,EAAAimB,EAAAvR,WAAAxV,EAAA2jB,KAAA3jB,EAAA4O,OAAA5O,EAAAsU,SAEAxT,IAlCAe,KAAAsE,OAWAA,EAAAY,SAAA,iCAsCA,QAAAkgB,KAEA,GAAAC,KAWArlB,MAAAqlB,gBAAA,WACAA,MAiBArlB,KAAAsE,MAAA,oCAAAghB,EAAAxa,GACA,MAAAua,GACAC,EAGA,SAAAC,GACA,MAAAza,GAAA,WACAya,EAAA,GAAAC,kBACO,SA4IP,QAAAC,GAAAxF,EAAA5O,EAAAqU,EAAAC,EAAA9a,GAEA,QAAA+a,KACA,MAAAvU,GAAAwU,IAAA,SAAAC,GACA,MAAAzU,GAAAwU,IAAAC,GAAAzU,EAAA9V,IAAAuqB,GAAA,MACK,SAAAA,GACL,IACA,MAAAzU,GAAA9V,IAAAuqB,GACO,MAAAxsB,GACP,cAWA,QAAAysB,GAAAC,EAAAC,GACA,GAAAC,GAAA,WACA,OACAC,MAAA,SAAAC,EAAAC,EAAA9mB,GAA+C8mB,EAAAC,MAAAF,GAAuB7mB,KACtEgnB,MAAA,SAAAH,EAAA7mB,GAAuC6mB,EAAAphB,SAAkBzF,MAIzD,IAAAinB,EACA,OACAL,MAAA,SAAAC,EAAAC,EAAA9mB,GACAc,EAAAomB,QAAAC,MAAA,EACAF,EAAAL,MAAAC,EAAA,KAAAC,GAAAvY,KAAAvO,GAEAinB,EAAAL,MAAAC,EAAA,KAAAC,EAAA9mB,IAGAgnB,MAAA,SAAAH,EAAA7mB,GACAc,EAAAomB,QAAAC,MAAA,EACAF,EAAAD,MAAAH,GAAAtY,KAAAvO,GAEAinB,EAAAD,MAAAH,EAAA7mB,IAMA,IAAAonB,EAAA,CACA,GAAAC,GAAAD,KAAAV,EAAAD,EAEA,QACAG,MAAA,SAAAC,EAAAC,EAAA9mB,GAA8CqnB,EAAAT,MAAAC,EAAA,KAAAC,GAAqC9mB,KACnFgnB,MAAA,SAAAH,EAAA7mB,GAAsCqnB,EAAAL,MAAAH,GAAwB7mB,MAI9D,MAAA2mB,KA1CA,GAAAJ,GAAAF,IACAe,EAAAb,EAAA,aACAU,EAAAV,EAAA,YA2CAe,GACAC,SAAA,MACAC,YACAC,SAAA,IACAC,WAAA,UACArO,QAAA,SAAAsO,EAAAC,EAAAC,GACA,gBAAAnB,EAAAV,EAAAS,GAaA,QAAAqB,KAWA,GAVAC,IACAA,EAAAtiB,SACAsiB,EAAA,MAGAC,IACAA,EAAAC,WACAD,EAAA,MAGAE,EAAA,CACA,GAAAC,GAAAD,EAAAvqB,KAAA,UACAyqB,GAAApB,MAAAkB,EAAA,WACAC,EAAAE,YAAAha,UACA0Z,EAAA,OAGAA,EAAAG,EACAA,EAAA,MAIA,QAAAI,GAAAC,GACA,GAAAC,GACAhtB,EAAAitB,EAAA/B,EAAAD,EAAAvV,EAAAkV,GACAsC,EAAAltB,GAAAklB,EAAA3P,UAAA2P,EAAA3P,SAAAmC,OAAA1X,EAEA,IAAA+sB,GAAAG,IAAAC,EAAA,CACAH,EAAA9B,EAAAkC,OACAD,EAAAjI,EAAA3P,SAAAmC,OAAA1X,GAcAgtB,EAAAK,MAAA,sBAAArtB,EAEA,IAAAstB,GAAAjB,EAAAW,EAAA,SAAAM,GACA,GAAAC,GAAAzd,EAAA6C,QAAA6a,EAAA1d,EAAA6C,QACA8a,GACAztB,OACA0tB,WAAAH,EAAA3a,QACA+a,WAAAH,EAAA5a,QACAia,YAAAW,EAGAZ,GAAAxB,MAAAkC,EAAAnrB,KAAA,UAAAsrB,GAAAjD,EAAA,WACA+C,EAAA1a,UACA2Z,GACAA,EAAAa,MAAA,+BAGA/nB,EAAAgD,UAAAslB,QAAA1C,EAAA2C,MAAAD,KACAjD,EAAA2C,KAGAhB,KAGAI,GAAAY,EACAd,EAAAQ,EAYAR,EAAAa,MAAA,qBAAArtB,GACAwsB,EAAAqB,MAAAC,IA9FA,GAAAvB,GAAAG,EAAAF,EAAAW,EACAW,EAAA7C,EAAA8C,QAAA,GACAH,EAAA3C,EAAA+C,WACApB,EAAA5B,EAAAC,EAAAC,GACAxV,EAAA8U,EAAAyD,cAAA,UAEA/C,GAAAhJ,IAAA,iCACA4K,QAGAA,QA0FA,OAAAhB,GAIA,QAAAoC,GAAAC,EAAAC,EAAAlJ,EAAA0F,GACA,OACAmB,SAAA,MACAE,SAAA,KACApO,QAAA,SAAAsO,GACA,GAAAkC,GAAAlC,EAAAmC,MACA,iBAAApD,EAAAV,EAAAS,GACA,GAAA5G,GAAAa,EAAA3P,SACAoX,EAAAnC,EAAAroB,KAAA,WACAuV,EAAA2M,KAAA3M,OAAAiV,EAAA3sB,KAEA,IAAA0X,EAAA,CAIApO,EAAAqjB,GAA6BrI,MAAA5M,EAAA+P,UAC7B+C,EAAA8D,KAAA5W,EAAAuP,UAAAvP,EAAAuP,UAAAoH,EAEA,IAAAE,GAAAjpB,EAAAgE,UAA2CoO,EAC3CwT,GAAAxT,EAAAkQ,aAAA2G,CAEA,IAAAC,GAAAL,EAAA3D,EAAAiE,WAEA,IAAA/W,EAAA6P,aAAA,CACA7P,EAAAgX,OAAAxD,EACAxT,EAAA8S,UACA,IAAAhD,GAAA4G,EAAA1W,EAAA6P,aAAA7P,EACAA,GAAAgQ,iBACAwD,EAAAxT,EAAAgQ,gBAAAF,EACA0D,EAAAxT,EAAAgQ,gBAAAhQ,EAAAkQ,aAAA2G,GAEA1d,EAAA2W,EAAAmH,UAAAnH,EAAAmH,UACAnE,EAAAroB,KAAA,0BAAAqlB,GACAgD,EAAA5qB,WAAAuC,KAAA,0BAAAqlB,GAGAgH,EAAAtD,OAUA,QAAA+B,GAAA/B,EAAAD,EAAAvV,EAAAkV,GACA,GAAA5qB,GAAA4qB,EAAAK,EAAA2D,QAAA3D,EAAAjrB,MAAA,IAAAkrB,EACA,OAAAlrB,GAAAN,QAAA,QAAAM,IAAA,KAAA0V,IAAA4O,MAAAtkB,KAAA,IAMA,QAAA6uB,GAAAC,EAAAzK,GACA,GAAyC0K,GAAzCC,EAAAF,EAAAhb,MAAA,oBAGA,IAFAkb,IAAAF,EAAAzK,EAAA,IAAA2K,EAAA,QACAD,EAAAD,EAAA3e,QAAA,WAAA2D,MAAA,6BACAib,GAAA,IAAAA,EAAA3tB,OAAA,SAAA3D,OAAA,sBAAAqxB,EAAA,IACA,QAAUxK,MAAAyK,EAAA,GAAAE,UAAAF,EAAA,UAGV,QAAAG,GAAAC,GACA,GAAAC,GAAAD,EAAAvrB,SAAAqqB,cAAA,UAEA,OAAAmB,MAAA9K,OAAA8K,EAAA9K,MAAAtkB,KACAovB,EAAA9K,MADA,OAKA,QAAA+K,GAAAF,GAEA,GAAAG,GAAA,+BAAArvB,OAAAC,UAAAwK,SAAAvL,KAAAgwB,EAAAI,KAAA,SACAC,EAAA,SAAAL,EAAA,GAAAM,QAEA,QACAC,KAAAF,EAAA,SAAAF,EAAA,oBACAK,SAAA,MAAAR,EAAAI,KAAA,WAAAK,cACAC,WAAAL,GAIA,QAAAM,GAAAX,EAAAjK,EAAAnV,EAAAhT,EAAAsnB,GACA,gBAAA9lB,GACA,GAAAwxB,GAAAxxB,EAAAyxB,OAAAzxB,EAAAwxB,OAAAzE,EAAAjH,GAEA,MAAA0L,EAAA,GAAAxxB,EAAA0xB,SAAA1xB,EAAA2xB,SAAA3xB,EAAA4xB,UAAAhB,EAAAO,KAAA,YAEA,GAAAnJ,GAAAxW,EAAA,WACAmV,EAAAgD,GAAAoD,EAAAhH,MAAAgH,EAAAtZ,OAAAsZ,EAAAloB,UAEA7E,GAAA6xB,gBAGA,IAAAC,GAAAtzB,EAAA4yB,WAAArE,EAAA7I,KAAA,GAEAlkB,GAAA6xB,eAAA,WACAC,KAAA,GAAAtgB,EAAAoD,OAAAoT,MAMA,QAAA+J,GAAAnB,EAAAjK,GACA,OAAUiD,SAAA+G,EAAAC,IAAAjK,EAAA3P,SAAAnB,YAkEV,QAAAmc,GAAArL,EAAAnV,GACA,OACAgc,SAAA,IACAyE,SAAA,qCACAhC,KAAA,SAAAtD,EAAAG,EAAAJ,EAAAwF,GACA,GAKAC,GALA5B,EAAAD,EAAA5D,EAAA0F,OAAAzL,EAAAb,QAAArkB,MACAsc,GAAoBgI,MAAAwK,EAAAxK,MAAA7B,KAAA,KAAAzQ,OAAA,MACpBjV,EAAAsyB,EAAAhE,GACA7rB,EAAAixB,EAAA,IAAAA,EAAA,GACAG,EAAA,IAGAtU,GAAAlZ,QAAAkG,EAAAgnB,EAAAjF,EAAAnG,GAAA+F,EAAA4F,WAAA3F,EAAA2C,MAAA5C,EAAA4F,eAEA,IAAA1yB,GAAA,SAAA8R,GACAA,IAAAqM,EAAAtK,OAAA1M,EAAAoN,KAAAzC,IACAqM,EAAAmG,KAAAyC,EAAAzC,KAAAqM,EAAAxK,MAAAhI,EAAAtK,OAAAsK,EAAAlZ,SAEAwtB,OACApxB,IAAAoxB,EAAApxB,EAAAsxB,eAAAhC,EAAAxK,MAAAhI,EAAAtK,SACA,OAAAsK,EAAAmG,MAAAwI,EAAA8F,KAAAh0B,EAAA2yB,KAAApT,EAAAmG,MAGAqM,GAAAG,YACA/D,EAAA8F,OAAAlC,EAAAG,UAAA,SAAAhf,GAAmDA,IAAAqM,EAAAtK,QAAA7T,EAAA8R,QACnDqM,EAAAtK,OAAA1M,EAAAoN,KAAAwY,EAAA2C,MAAAiB,EAAAG,aAEA9wB,IAEApB,EAAA8yB,YACAa,EAAAZ,EAAAzE,EAAAnG,EAAAnV,EAAAhT,EAAA,WAAsE,MAAAuf,KACtE+O,EAAAhY,KAAA,QAAAqd,GACAxF,EAAAhJ,IAAA,sBACAmJ,EAAA4F,OAAA,QAAAP,QAuBA,QAAAQ,GAAAhM,EAAAnV,GACA,OACAgc,SAAA,IACAyE,SAAA,qCACAhC,KAAA,SAAAtD,EAAAG,EAAAJ,EAAAwF,GASA,QAAAU,GAAAC,GACA9U,EAAAgI,MAAA8M,EAAA,GAA6B9U,EAAAtK,OAAAof,EAAA,GAAuB9U,EAAAlZ,QAAAguB,EAAA,GACpD9U,EAAAmG,KAAAyC,EAAAzC,KAAAnG,EAAAgI,MAAAhI,EAAAtK,OAAAsK,EAAAlZ,SAEAwtB,OACApxB,IAAAoxB,EAAApxB,EAAAsxB,eAAAxU,EAAAgI,MAAAhI,EAAAtK,SACAsK,EAAAmG,MAAAwI,EAAA8F,KAAAh0B,EAAA2yB,KAAApT,EAAAmG,MAdA,GAMAiO,GANA3zB,EAAAsyB,EAAAhE,GACA7rB,EAAAixB,EAAA,IAAAA,EAAA,GACAW,GAAAnG,EAAAoG,QAAApG,EAAAqG,eAAA,KAAArG,EAAAsG,aAAA,MACAC,EAAA,IAAAJ,EAAAhb,IAAA,SAAAnG,GAAkD,MAAAA,IAAA,SAAwBlJ,KAAA,UAC1EuV,GAAoBgI,MAAA,KAAAtS,OAAA,KAAA5O,QAAA,KAAAqf,KAAA,MACpBmO,EAAA,IAYA1F,GAAA8F,OAAAQ,EAAAL,MACAA,EAAAjG,EAAA2C,MAAA2D,IAEAz0B,EAAA8yB,YACAa,EAAAZ,EAAAzE,EAAAnG,EAAAnV,EAAAhT,EAAA,WAAsE,MAAAuf,KACtE+O,EAAAhY,KAAA,QAAAqd,GACAxF,EAAAhJ,IAAA,sBACAmJ,EAAA4F,OAAA,QAAAP,QAoGA,QAAAe,GAAAvM,EAAAD,EAAA2F,GACA,OACAmB,SAAA,IACAvE,YAAA,iDAAAkH,EAAAlE,EAAAkH,EAAA3hB,GAsCA,QAAA4hB,GAAA7N,EAAA8N,EAAAC,GACA,GAAAvN,GAAAY,EAAA1kB,IAAAsjB,EAAAoL,EAAA1E,IACAsH,EAAAC,EAAAjO,EAAA8N,GAEAI,GACA1N,UAA2BtkB,KAAA8jB,GAC3B9R,OAAA4f,EACArJ,KAAAuJ,EAMA,OAHAvN,GAAA5kB,KAAAqyB,GACAC,EAAAH,GAAAD,EAEA,WACA,GAAApwB,GAAA8iB,EAAA7kB,QAAAsyB,EACA,MAAAvwB,GAAA8iB,EAAA7iB,OAAAD,EAAA,IASA,QAAAswB,GAAAzN,EAAAtS,GACA,IAAAvJ,EAAA6b,GACA,SAAA7mB,OAAA,2BAEA,OAAA+Z,GAAAxF,GACAsS,EAAAta,EAAAgI,IAEAA,EAAA0c,EAAAb,MAAA7b,GACAwF,EAAAxF,GACAsS,EAAAta,EAAAgI,GAEAsS,GAIA,QAAAnmB,KACA,OAAAgD,GAAA,EAAuBA,EAAAojB,EAAAnjB,OAAmBD,IAC1C+wB,EAAA3N,EAAApjB,GAAAmjB,MAAAC,EAAApjB,GAAA6Q,QACAmgB,EAAA3H,EAAAyH,EAAA1N,EAAApjB,GAAAonB,OAEA6J,EAAA5H,EAAAyH,EAAA1N,EAAApjB,GAAAonB,OAGA8J,EAAA9N,EAAApjB,GAAAmjB,MAAAC,EAAApjB,GAAA6Q,QACAmgB,EAAA3H,EAAA8H,GAEAF,EAAA5H,EAAA8H,GAKA,QAAAH,GAAAhD,EAAAoD,GAAwCxiB,EAAA,WAAuBof,EAAAgD,SAAAI,KAC/D,QAAAH,GAAAjD,EAAAoD,GAA2CpD,EAAAiD,YAAAG,GAC3C,QAAAL,GAAA5N,EAAAtS,GAAwC,MAAAkT,GAAAkE,SAAA9E,EAAAtkB,KAAAgS,GACxC,QAAAqgB,GAAA/N,EAAAtS,GAA0C,MAAAkT,GAAAtI,GAAA0H,EAAAtkB,KAAAgS,GA/F1C,GAAyCsgB,GAAA7B,EAAzClM,KAAA0N,IAKAK,GAAA1H,EAAA8G,EAAAc,gBAAA,OAAA9D,EAEA,KACA+B,EAAA/B,EAAAb,MAAA6D,EAAAjB,cACO,MAAAlyB,IAIPkyB,KAAA7F,EAAA8G,EAAAjB,cAAA,OAAA/B,GACAlX,EAAAiZ,IACAnhB,EAAAmhB,EAAA,SAAAzM,EAAA6N,GACA,GAAAppB,EAAAub,GAAA,CACA,GAAA8K,GAAAD,EAAA7K,EAAAkB,EAAAb,QAAArkB,KACA2xB,GAAA7C,EAAAxK,MAAAoK,EAAAb,MAAAiB,EAAAG,WAAA4C;IAMA5sB,KAAA6rB,eAAA,SAAA2B,EAAAnd,GAGA,KAAAkC,EAAAiZ,IAAAlM,EAAAnjB,OAAA,IAGA,GAAAsxB,GAAAf,EAAAc,EAAAnd,EAAAmb,EAEA,OADAtyB,KACAu0B,IAGAhE,EAAAxM,IAAA,sBAAA/jB,GA8DAA,OAqBA,QAAAw0B,GAAAzN,GACA,GAAA0N,GAAA,SAAAtO,EAAAtS,GACA,MAAAkT,GAAAtI,GAAA0H,EAAAtS,GAGA,OADA4gB,GAAAC,aACAD,EAaA,QAAAE,GAAA5N,GACA,GAAA6N,GAAA,SAAAzO,EAAAtS,EAAA5O,GACA,MAAA8hB,GAAAkE,SAAA9E,EAAAtS,EAAA5O,GAGA,OADA2vB,GAAAF,aACAE,EAv8IA,GAAAzqB,GAAAhD,EAAAgD,UACAuI,EAAAvL,EAAAuL,WACApI,EAAAnD,EAAAmD,SACA+O,EAAAlS,EAAAkS,SACA5H,EAAAtK,EAAAsK,QACAN,EAAAhK,EAAAgK,QACAhG,EAAAhE,EAAAgE,OACAoJ,EAAApN,EAAAoN,KACA1I,EAAA1E,EAAA0E,MAkNA1E,GAAAhC,OAAA,yBAcAgC,EAAAhC,OAAA,uCAgBAgC,EAAAhC,OAAA,yDAsCAgC,EAAAhC,OAAA,iCAEAgC,EAAAhC,OAAA,kCAYA+S,EAAAlM,SAAA,kBAgPA7E,EAAAhC,OAAA,kBAAAynB,QAAA,WAAA1U,GAcAqC,EAAAvO,SAAA,sCAkGA7E,EAAAhC,OAAA,kBAAAynB,QAAA,mBAAArS,EAEA,IAAAe,EAsMAN,GAAAjZ,UAAA+V,OAAA,SAAAmD,EAAA7T,GAIA,GAAAytB,IACAxY,gBAAAf,EAAAe,kBACAc,OAAA7B,EAAAmE,aACA/D,OAAAJ,EAAA8C,sBAEA,WAAApD,GAAAlU,KAAAoW,WAAAjC,EAAAnU,KAAAmW,aAAA9R,EAAA0pB,EAAAztB,GAAAN,OAGAkU,EAAAjZ,UAAAwK,SAAA,WACA,MAAAzF,MAAA8V,QA2BA5B,EAAAjZ,UAAA8a,KAAA,SAAA5S,EAAA6qB,GAWA,QAAAC,GAAAtZ,GACA,QAAAuZ,GAAAxqB,GAAiC,MAAAA,GAAAuG,MAAA,IAAA0Q,UAAA7Y,KAAA,IACjC,QAAAqsB,GAAAzqB,GAAiC,MAAAA,GAAAwH,QAAA,YAEjC,GAAAjB,GAAAikB,EAAAvZ,GAAA1K,MAAA,WACAmkB,EAAAjd,EAAAlH,EAAAikB,EACA,OAAA/c,GAAAid,EAAAD,GAAAxT,UAhBA,GAAAxa,GAAAH,KAAAiV,OAAAc,KAAA5S,EACA,KAAAhD,EAAA,WACA6tB,QAEA,IAEe9xB,GAAAoD,EAAA+uB,EAFf9Z,EAAAvU,KAAAsuB,aAAAC,EAAAha,EAAApY,OACAqyB,EAAAxuB,KAAA2V,SAAAxZ,OAAA,EACA0U,IAEA,IAAA2d,IAAAruB,EAAAhE,OAAA,WAAA3D,OAAA,sCAAAwH,KAAA8V,OAAA,IAWA,IAAApH,GAAA+f,CACA,KAAAvyB,EAAA,EAAasyB,EAAAtyB,EAAWA,IAAA,CAKxB,IAJAmyB,EAAA9Z,EAAArY,GACAwS,EAAA1O,KAAA+M,OAAAshB,GACAI,EAAAtuB,EAAAjE,EAAA,GAEAoD,EAAA,EAAeA,EAAAoP,EAAAxD,QAAA/O,OAA0BmD,IACzCoP,EAAAxD,QAAA5L,GAAAyQ,OAAA0e,MAAA/f,EAAAxD,QAAA5L,GAAAwa,GAEA2U,IAAA/f,EAAAkB,aAAA6e,EAAAR,EAAAQ,IACAprB,EAAAorB,OAAA/f,EAAA5W,KAAA4f,OAAA+W,IACA5d,EAAAwd,GAAA3f,EAAAjT,MAAAgzB,GAEA,KAAYF,EAAAryB,EAAYA,IAAA,CAKxB,IAJAmyB,EAAA9Z,EAAArY,GACA2U,EAAAwd,GAAAruB,KAAA+M,OAAAshB,GAAA5yB,MAAAuyB,EAAAK,IACA3f,EAAA1O,KAAA+M,OAAAshB,GACAI,EAAAT,EAAAK,GACA/uB,EAAA,EAAeA,EAAAoP,EAAAxD,QAAA/O,OAA0BmD,IACzCoP,EAAAxD,QAAA5L,GAAAyQ,OAAA0e,MAAA/f,EAAAxD,QAAA5L,GAAAwa,GAEAzW,GAAAorB,OAAA/f,EAAA5W,KAAA4f,OAAA+W,IACA5d,EAAAwd,GAAA3f,EAAAjT,MAAAgzB,GAGA,MAAA5d,IAcAqD,EAAAjZ,UAAAqzB,WAAA,SAAA5f,GACA,MAAArL,GAAAqL,GACA1O,KAAA+M,OAAA2B,IAAA,KADA1O,KAAAuW,cAgBArC,EAAAjZ,UAAAwiB,UAAA,SAAA1Q,GACA,MAAA/M,MAAA+M,OAAAqO,YAAArO,IAsBAmH,EAAAjZ,UAAAqiB,OAAA,SAAAzM,GAOA,QAAA6d,GAAAhrB,GACA,MAAAC,oBAAAD,GAAAwH,QAAA,cAAAvN,GAA8D,aAAAA,EAAAwK,WAAA,GAAA1C,SAAA,IAAAklB,gBAP9D9Z,OACA,IAAA8E,GAAA3V,KAAA2V,SAAA5I,EAAA/M,KAAAsuB,aAAA1T,EAAA5a,KAAA+M,MACA,KAAA/M,KAAAyd,UAAA5M,GAAA,WAEA,IAAA3U,GAAAga,KAAAsY,EAAA7Y,EAAAxZ,OAAA,EAAAoyB,EAAAxhB,EAAA5Q,OAAA8C,EAAA0W,EAAA,EAMA,KAAAzZ,EAAA,EAAaqyB,EAAAryB,EAAYA,IAAA,CACzB,GAAAyyB,GAAAH,EAAAtyB,EACAnB,EAAAgS,EAAA7Q,GAAAwS,EAAAkM,EAAA7f,GAAAU,EAAAiT,EAAAjT,MAAAoV,EAAA9V,IACA6zB,EAAAlgB,EAAAsH,YAAAtH,EAAA5W,KAAAugB,OAAA3J,EAAAjT,WACAmZ,EAAAga,EAAAlgB,EAAAkG,UACA2G,EAAA7M,EAAA5W,KAAA2f,OAAAhc,EAEA,IAAAkzB,EAAA,CACA,GAAAE,GAAAlZ,EAAAzZ,EAAA,GACA4yB,EAAA5yB,EAAA,IAAAsyB,CAEA,IAAA5Z,OACA,MAAA2G,IAEAtc,GADA0L,EAAA4Q,GACApK,EAAAoK,EAAAmT,GAAA5sB,KAAA,KAEA6B,mBAAA4X,IAGAtc,GAAA4vB,MACO,IAAAja,OAAA,CACP,GAAAsD,GAAAjZ,EAAA4P,MAAA,uBACA5P,IAAA4vB,EAAAhgB,MAAAqJ,GAAA,OACO1U,GAAAoR,KACP3V,GAAA2V,EAAAia,EAGAC,IAAApgB,EAAAkG,aAAA,MAAA3V,EAAAT,MAAA,MAAAS,IAAAT,MAAA,WACK,CACL,SAAA+c,GAAAqT,GAAAha,OAAA,QAEA,IADAjK,EAAA4Q,YACA,IAAAA,EAAApf,OAAA,QACAof,GAAApK,EAAAoK,EAAA5X,oBAAA7B,KAAA,IAAA/G,EAAA,KACAkE,IAAAiX,EAAA,UAAAnb,EAAA,IAAAwgB,GACArF,MAIA,MAAAjX,IAoDAuX,EAAAvb,UAAA0c,GAAA,SAAA3M,EAAAvG,GACA,UAkBA+R,EAAAvb,UAAAwc,OAAA,SAAAzM,EAAAvG,GACA,MAAAuG,IAgBAwL,EAAAvb,UAAAyc,OAAA,SAAA1M,EAAAvG,GACA,MAAAuG,IAeAwL,EAAAvb,UAAAod,OAAA,SAAAxZ,EAAAC,GACA,MAAAD,IAAAC,GAGA0X,EAAAvb,UAAA8zB,YAAA,WACA,GAAAC,GAAAhvB,KAAAmU,QAAA1O,UACA,OAAAupB,GAAAvmB,OAAA,EAAAumB,EAAA7yB,OAAA,IAGAqa,EAAAvb,UAAAkZ,QAAA,KAEAqC,EAAAvb,UAAAwK,SAAA,WAAsC,eAAUzF,KAAAjF,KAAA,KAGhDyb,EAAAvb,UAAAmf,WAAA,SAAApP,GACA,MAAAhL,MAAA2X,GAAA3M,KAAAhL,KAAA0X,OAAA1M,IAaAwL,EAAAvb,UAAAof,SAAA,SAAA4U,EAAAja,GAIA,QAAAka,GAAAp3B,EAAAm3B,GACA,QAAAE,GAAAr3B,EAAAs3B,GACA,kBACA,MAAAt3B,GAAAs3B,GAAAxyB,MAAA9E,EAAAkV,YAKA,QAAAqiB,GAAArkB,GAA6B,MAAAL,GAAAK,KAAA3H,EAAA2H,UAE7B,QAAAskB,GAAAtkB,GACA,OAAAA,EAAA7O,QACA,aAAA8I,EACA,uBAAAgqB,EAAAjkB,EAAA,GAAAA,CACA,eAAAA,IAGA,QAAAukB,GAAAvkB,GAA0B,OAAAA,EAG1B,QAAAwkB,GAAAl3B,EAAAm3B,GACA,gBAAAzkB,GACA,GAAAL,EAAAK,IAAA,IAAAA,EAAA7O,OAAA,MAAA6O,EACAA,GAAAqkB,EAAArkB,EACA,IAAA/L,GAAAkS,EAAAnG,EAAA1S,EACA,OAAAm3B,QACA,IAAAtqB,EAAAlG,EAAAswB,GAAApzB,OACAmzB,EAAArwB,IAKA,QAAAywB,GAAAp3B,GACA,gBAAAq3B,EAAAC,GACA,GAAA1U,GAAAmU,EAAAM,GAAAxU,EAAAkU,EAAAO,EACA,IAAA1U,EAAA/e,SAAAgf,EAAAhf,OAAA,QACA,QAAAD,GAAA,EAAuBA,EAAAgf,EAAA/e,OAAiBD,IACxC,IAAA5D,EAAA4iB,EAAAhf,GAAAif,EAAAjf,IAAA,QAEA,WAIA8D,KAAAyX,OAAA+X,EAAAL,EAAAr3B,EAAA,WACAkI,KAAA0X,OAAA8X,EAAAL,EAAAr3B,EAAA,WACAkI,KAAA2X,GAAA6X,EAAAL,EAAAr3B,EAAA,UACAkI,KAAAqY,OAAAqX,EAAAP,EAAAr3B,EAAA,WACAkI,KAAAmU,QAAArc,EAAAqc,QACAnU,KAAAoa,WAAAoV,EAAAL,EAAAr3B,EAAA,eACAkI,KAAAjF,KAAAjD,EAAAiD,KACAiF,KAAA6vB,WAAAZ,EArDA,IAAAA,EAAA,MAAAjvB,KACA,aAAAivB,IAAAja,EAAA,SAAAxc,OAAA,iDAuDA,WAAA02B,GAAAlvB,KAAAivB,IAwfA5uB,EAAAhC,OAAA,kBAAA8F,SAAA,qBAAAsS,GACApW,EAAAhC,OAAA,kBAAAyxB,KAAA,8BAAApU,OAkBAF,EAAAtW,SAAA,kDA8ZA7E,EAAAhC,OAAA,oBAAA8F,SAAA,aAAAqX,GAuBAkD,EAAAxZ,SAAA,mDAw6CA7E,EAAAhC,OAAA,mBACAkD,QAAA,0BAAwC,WACxCwuB,SAAA,kBAA+BC,gBAC/B7rB,SAAA,SAAAua,GAEAoR,KAAA,qBAAAze,GAEAA,EAAA9V,IAAA,kBAAAy0B,YACA3e,EAAA9V,IAAA,aAKA0pB,EAAA/f,WA2CA7E,EAAAhC,OAAA,mBAAA8F,SAAA,QAAA8gB,GAqDA5kB,EAAAhC,OAAA,mBAAA8F,SAAA,gBAAAihB,GAsIAK,EAAAvgB,SAAA,0DA0KA+jB,EAAA/jB,SAAA,kDAoDA7E,EAAAhC,OAAA,mBAAAwoB,UAAA,SAAApB,GACAplB,EAAAhC,OAAA,mBAAAwoB,UAAA,SAAAoC,GAqHAqC,EAAApmB,SAAA,qBAwDA+mB,EAAA/mB,SAAA,qBAiIAsnB,EAAAtnB,SAAA,wCA2GA7E,EAAAhC,OAAA,mBACAwoB,UAAA,SAAAyE,GACAzE,UAAA,eAAA2F,GACA3F,UAAA,iBAAA2F,GACA3F,UAAA,UAAAoF,GAWAyB,EAAAxoB,SAAA,UAkBA2oB,EAAA3oB,SAAA,UASA7E,EAAAhC,OAAA,mBACA8G,OAAA,UAAAuoB,GACAvoB,OAAA,kBAAA0oB,IACChrB,cAAAxC,UT8/DM,CACC,CAEF,SAAShC,EAAQwB,EAAS5H,GU59MhC,YV++MC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAZvF,GAAIG,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUL,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXI,SAAyBJ,EAAIM,cAAgBF,OAAS,eAAkBJ,IUl+M3OS,EAAApJ,EAAA,GVs+MKqJ,EAAQX,EAAuBU,EUp+MpCpJ,GAAA,IACAA,EAAA,GACAA,EAAA,IAKAqJ,aAAIihB,WAAW,kBAAkB,SAAS,UAAU,YAAY,YAAY,SAAS,eAAe,cAAc,SAASkH,EAAOhoB,EAAQwuB,EAAUC,EAAUjQ,EAAOD,EAAamQ,GAE9K1G,EAAO2G,YAEP3G,EAAO4G,cAGP5G,EAAO6G,QAAU,EAEjB7G,EAAO8G,MAAQ,KAGf9G,EAAO+G,WAGP/G,EAAOnnB,YAAc,EAKrBmnB,EAAOgH,YAAc,WACjBhH,EAAO+G,SACHE,UAAUP,EAAWQ,iBACrB3uB,OAAsC,GAA/BiuB,EAAUluB,SAASC,SAAgB,EAAIG,SAAS8tB,EAAUluB,SAASC,UAC1E4uB,WAAWT,EAAWU,mBACtB53B,OAAOk3B,EAAWW,mBAClBC,OAAO,KAKftH,EAAOuH,qBAAuBb,EAAWc,kBACzCxH,EAAOyH,cAAgBf,EAAWc,kBAAkB,GAAG3zB,GAGvDmsB,EAAO0H,WAEP1H,EAAOkD,YAAc3M,EAErByJ,EAAO2H,UACHC,IAAI,GACJ1xB,OACI+wB,aACAK,UACAO,cACAC,cAOR9H,EAAO+H,UAAY,WACmB,GAA/BvB,EAAUluB,SAASC,UAClBkuB,EAAUuB,KAAKxB,EAAUluB,SAASC,QAAQ8L,KAAK,SAAS5Q,GACpDusB,EAAO0H,WACP1H,EAAO4G,WAAa5G,EAAO2G,SAAWlzB,EAAKu0B,IAC3C,KAAI,GAAIv1B,GAAE,EAAE4T,EAAI2Z,EAAO2G,SAASj0B,OAAS2T,EAAF5T,EAAMA,IACf,GAAvBgB,EAAKu0B,KAAKv1B,GAAGjD,SACZwwB,EAAOnnB,aAAe,IAGhC,WACEmnB,EAAO0H,cASnB1H,EAAOiI,iBAAoB,SAACz4B,GACxBwwB,EAAOyH,cAAgBj4B,EACvBwwB,EAAO4G,WAAa5G,EAAO2G,SAASjrB,OAAQ,SAACpG,GACzC,OAAO0qB,EAAOyH,eACV,IAAK,GACD,QACJ,KAAK,GACD,MAAsB,IAAfnyB,EAAK9F,MAChB,KAAK,GACL,QACI,MAAsB,IAAf8F,EAAK9F,WAQ5BwwB,EAAOkI,UAAY,WACkB,mBAAvB3R,GAAa4R,QACnBnI,EAAO8G,MAAQ,KACfL,EAAU2B,QACN7vB,OAAQiuB,EAAUluB,SAASC,SAC3B1E,GAAG0iB,EAAa4R,SACjB9jB,KAAM,SAAC5Q,GACNusB,EAAO+G,QAAUtzB,EACgB,GAA7BusB,EAAO+G,QAAQc,aACf7H,EAAO+G,QAAQc,WAAa,GAAI7tB,MAAiC,IAA5BgmB,EAAO+G,QAAQc,aAEzB,GAA3B7H,EAAO+G,QAAQe,WACf9H,EAAO+G,QAAQe,SAAW,GAAI9tB,MAA+B,IAA1BgmB,EAAO+G,QAAQe,YAEvD,SAACzlB,GACA,GAAIgmB,GAAS,MACc,WAAxB/wB,EAAO+K,EAAS5O,OAAmD,mBAAxB4O,GAAS5O,KAAK60B,SACxDD,EAAShmB,EAAS5O,KAAK60B,OAAS,SAAWjmB,EAAS5O,KAAK80B,QAAU,KAEvEvwB,EAAQwwB,MAAMH,GACd7R,EAAOgD,GAAG,iBAGdwG,EAAOgH,cACPhH,EAAO8G,MAAQ,OAQvB9G,EAAOyI,eAAiB,SAACN,GACrB3R,EAAOgD,GAAG,aACNjhB,OAAOiuB,EAAUluB,SAASC,SAC1B4vB,OAAOA,KAOfnI,EAAO0I,SAAW,WACd,GAAG1I,EAAO+G,QAAQE,UAAUv0B,OAAO,GAAIstB,EAAO+G,QAAQE,UAAUv0B,OAAO,GAGnE,MAFAstB,GAAO2H,SAASC,IAAM,8BACtB5H,EAAO2H,SAASzxB,MAAM+wB,aAI1B,IAAI0B,GAAiB,EACjBC,EAAe,CAKnB,IAHAD,EAAiBjwB,SAASsB,KAAKrK,MAAM,GAAIqK,MAAKgmB,EAAO+G,QAAQc,aAAe,KAC5Ee,EAAelwB,SAASsB,KAAKrK,MAAM,GAAIqK,MAAKgmB,EAAO+G,QAAQe,WAAa,KAElD,GAAlBa,GAAuC,GAAhBC,GACnBD,EAAiBC,EAIjB,MAHA5I,GAAO2H,SAASzxB,MAAM2xB,cACtB7H,EAAO2H,SAASzxB,MAAM4xB,iBACtB9H,EAAO2H,SAASC,IAAM,eAK9B5H,GAAO+G,QAAQc,WAAac,EAC5B3I,EAAO+G,QAAQe,SAAWc,CAE1B,IAAI1kB,GAAU,IAEVA,GAD6B,mBAAvBqS,GAAa4R,OACT1B,EAAUh3B,OAAOuwB,EAAO+G,SAExBN,EAAUoC,OAAO7I,EAAO+G,SAGtC7iB,EAAQG,KAAK,SAAC5Q,GACVusB,EAAO2H,SAASC,IAAM,GACtB5H,EAAO2H,SAASzxB,MAAM+wB,aACtBjH,EAAO2H,SAASzxB,MAAMoxB,UACtBtH,EAAO2G,SAAS3zB,OAAO,EAAE,EAAES,GAC3B+iB,EAAOgD,GAAG,cACZ,SAACsP,GACC,MAAkB,MAAfA,EAAKt5B,WACJgnB,GAAOgD,GAAG,UAGdwG,EAAO2H,SAASC,IAAM,GACtB5H,EAAO2H,SAASzxB,MAAM+wB,aACtBjH,EAAO2H,SAASzxB,MAAMoxB,cACtBtvB,GAAQwwB,MAAMM,EAAKr1B,KAAK60B,YAQhCtI,EAAO+I,aAAe,SAACZ,GACnB/2B,QAAQ43B,IAAIb,EACZ,IAAIc,GAAWjJ,EAAO4G,WAAWsC,KAAK,SAAC5zB,GASnC,MARIA,GAAKzB,IAAMs0B,IACX7yB,EAAK9F,OAAwB,GAAf8F,EAAK9F,OAAc,EAAI,EACrB,GAAb8F,EAAK9F,OACJwwB,EAAOnnB,cAEPmnB,EAAOnnB,eAGRvD,EAAKzB,KAAOs0B,GAGvB1B,GAAUh3B,OAAOw5B,GAAU5kB,KAAM,SAAC5Q,KAC/B,SAAC4O,GACA,MAAsB,MAAnBA,EAAS7S,WACRgnB,GAAOgD,GAAG,aAGdxhB,GAAQwwB,MAAMnmB,EAAS5O,KAAK60B,WAQpCtI,EAAOmJ,WAAa,SAAChB,GACbnwB,EAAQoxB,QAAQ,iBAGpB3C,aACIluB,OAAOiuB,EAAUluB,SAASC,SAC1B1E,GAAGs0B,IACJ9jB,KAAM,SAAC5Q,GACN+iB,EAAOgD,GAAG,cACX,SAACnX,GACA,GAAsB,KAAnBA,EAAS7S,OAER,WADAgnB,GAAOgD,GAAG,QAGd,IAAI6O,GAAS,MACc,WAAxB/wB,EAAO+K,EAAS5O,OAAmD,mBAAxB4O,GAAS5O,KAAK60B,SACxDD,EAAShmB,EAAS5O,KAAK60B,OAAS,SAAWjmB,EAAS5O,KAAK80B,QAAU,KAEvEvwB,EAAQwwB,MAAMH,MAStBrI,EAAOqJ,gBAAkB,SAACC,GACtB,GAAIC,GAAU,GAAIvvB,MAAe,IAAVsvB,GACnBjb,EAAO,EAKX,OAHAA,GAAOkb,EAAQjb,cACfD,GAAQ,KAAO3V,SAAS6wB,EAAQhb,YAAY,GAC5CF,GAAQ,IAAMkb,EAAQ/a,eVg/MxB,SAAS5Z,EAAQwB,EAAS5H,GWjvNhC,YXgwNC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GW9vNxF,GAAAS,GAAApJ,EAAA,GXwvNKqJ,EAAQX,EAAuBU,EWvvNpCpJ,GAAA,IACAA,EAAA,GAKAqJ,aAAIihB,WAAW,kBAAkB,SAAS,YAAY,MAAM,SAAS,YAAY,SAASkH,EAAOwJ,EAAU7tB,EAAI6a,EAAOgQ,GAElHxG,EAAO1nB,UACHC,OAAO,EACPS,UAAU,GACVywB,YAAY,EACZxwB,WAAW,EACXC,aAAa,GAIjB8mB,EAAO0J,eACH1wB,UAAU,GACV2wB,SAAS,IAGb3J,EAAO2H,UACHC,IAAI,GACJ1xB,OACI8C,aACA2wB,cAKR3J,EAAOqI,OAAS,GAGhBrI,EAAO4J,MAAQ,WAEX,IAAK,sBAAsBxpB,KAAK4f,EAAO0J,cAAc1wB,WAGjD,MAFAgnB,GAAO2H,SAASC,IAAM,0BACtB5H,EAAO2H,SAASzxB,MAAM8C,aAG1B,IAAIgnB,EAAO0J,cAAcC,SAASj3B,OAAS,GAAKstB,EAAO0J,cAAcC,SAASj3B,OAAS,GAGnF,MAFAstB,GAAO2H,SAASC,IAAM,oBACtB5H,EAAO2H,SAASzxB,MAAMyzB,YAI1B,IAAIE,IACA7wB,UAAUgnB,EAAO0J,cAAc1wB,UAC/B2wB,SAAShuB,EAAII,WAAWikB,EAAO0J,cAAcC,UAGjDH,GAAUI,MAAMC,GAAWxlB,KAAK,SAAC5Q,GAC7BusB,EAAO2H,SAASC,IAAM,GACtB5H,EAAO2H,SAASzxB,MAAM8C,aACtBgnB,EAAO2H,SAASzxB,MAAMyzB,YAEtBnD,EAAUluB,SAASQ,KAAKrF,GAExB+iB,EAAOgD,GAAG,cACX,SAACnX,GACA2d,EAAO2H,SAASzxB,MAAM8C,aACtBgnB,EAAO2H,SAASzxB,MAAMyzB,YACtB3J,EAAO2H,SAASC,IAAMvlB,EAAS5O,KAAK60B,OAAS,SAAgBjmB,EAAS5O,KAAK80B,QAAU,OAI1F/B,EAAUrtB,WACTqd,EAAOgD,GAAG,iBXkwNZ,SAAS5kB,EAAQwB,EAAS5H,GYx0NhC,YZo1NC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GYl1NxF,GAAAS,GAAApJ,EAAA,GZg1NKqJ,EAAQX,EAAuBU,EY90NpCC,cAAIC,QAAQ,cAAc,WACtB,GAAIgyB,IACA1C,mBAAmB,EACnBF,iBAAiB,GACjBG,mBAAmB,EACnBG,oBAEQ3zB,GAAG,EACHvC,KAAK,OAGLuC,GAAG,EACHvC,KAAK,QAGLuC,GAAG,EACHvC,KAAK,QAKjB,OAAOw4B,MZm1NL,SAASl1B,EAAQwB,EAAS5H,Ga72NhC,Yb03NC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,Gax3NxF,GAAAS,GAAApJ,EAAA,Gbo3NKqJ,EAAQX,EAAuBU,Ean3NpCpJ,GAAA,GAKAqJ,aAAIC,QAAQ,aAAa,YAAY,YAAY,SAASiyB,EAAUvD,GAChE,OAOIwB,KAAK,SAASzvB,GACV,MAAOwxB,GAAUvD,EAAUruB,OAAO,iBAAiBI,OAAOA,IAASzG,MAAM4Q,UAM7EmmB,OAAO,SAASp1B,GACZ,MAAOs2B,GAAUvD,EAAUruB,OAAO,iBAAiBI,OAAO9E,EAAK8E,SAASO,KAAKrF,GAAMiP,UAMvFjT,OAAO,SAASgE,GACZ,MAAOs2B,GAAUvD,EAAUruB,OAAO,yBAAyBI,OAAO9E,EAAK8E,OAAO4vB,OAAO10B,EAAKI,KAAKpE,OAAOgE,GAAMiP,UAMhHvB,SAAO,SAAS1N,GACZ,MAAOs2B,GAAUvD,EAAUruB,OAAO,yBAAyBI,OAAO9E,EAAK8E,OAAO4vB,OAAO10B,EAAKI,KAAnFk2B,YAAiGrnB,UAO5G0lB,OAAO,SAAS30B,GACZ,MAAOs2B,GAAUvD,EAAUruB,OAAO,yBAAyBI,OAAO9E,EAAK8E,OAAO4vB,OAAO10B,EAAKI,KAAK/B,MAAM4Q,eb83N3G,SAAS9N,EAAQwB,EAAS5H,Gc56NhC,Ydy7NC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,Gcv7NxF,GAAAS,GAAApJ,EAAA,Gdm7NKqJ,EAAQX,EAAuBU,Ecl7NpCpJ,GAAA,GAKAqJ,aAAIC,QAAQ,aAAa,YAAY,YAAY,SAAUiyB,EAAUvD,GACjE,OAMIoD,MAAM,SAASn2B,GACX,MAAOs2B,GAAUvD,EAAUruB,OAAO,UAAUW,KAAKrF,GAAMiP,ed67N7D,SAAS9N,EAAQwB,EAAS5H,Ge78NhC,Yf89NC,SAAS0I,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,Ge59NxF,GAAAS,GAAApJ,EAAA,Gfo9NKqJ,EAAQX,EAAuBU,Eel9NpCpJ,GAAA,IACAA,EAAA,IAEAA,EAAA,GAEAqJ,aAAIhB,QAAQ,iBAAiB,qBAAqB,SAASmzB,EAAe9U,GACtEA,EAAmB7B,UAAU,cAE7B2W,EAECpU,MAAM,QACH2F,cACAnjB,IAAI,QACJwJ,SAAS,wBAEZgU,MAAM,aACHxd,IAAI,QACJgS,YAAY,+BACZ0O,WAAW,mBAGdlD,MAAM,eACHxd,IAAI,kBACJgS,YAAY,iCACZ0O,WAAW,mBAGdlD,MAAM,eACHxd,IAAI,UACJgS,YAAY,+BACZ0O,WAAW,mBAGdlD,MAAM,aACHxd,IAAI,gBACJgS,YAAY,+BACZ0O,WAAW,mBAGdlD,MAAM,eACHxd,IAAI,kBACJgS,YAAY,iCACZ0O,WAAW,mBAGdlD,MAAM,SACHxd,IAAI,cACJgS,YAAY,gCACZ0O,WAAW,sBAInBjhB,aAAIwuB,KAAK,aAAa,SAAS,YAAY,SAAS3T,EAAW8D,EAAOgQ,GAElE,GAAIyD,IAAc,OAAO,YAAY,aACrCvX,GAAWc,IAAI,sBAAuB,SAAC0W,EAAOtQ,EAAS7B,EAAUoS,EAAWzQ,EAAWxjB,GACnFwc,EAAW0X,cAAgBD,EAAU74B,KAEG,IAApC24B,EAAWj5B,QAAQ4oB,EAAQtoB,QACtBk1B,EAAUrtB,WACXqd,EAAOgD,GAAG,gBf89NpB,SAAS5kB,EAAQwB,EAAS5H,agBjiOhC67B,GAyBA,QAAAC,GAAAC,EAAAC,GAGA,OADAC,GAAA,EACAh4B,EAAA83B,EAAA73B,OAAA,EAAgCD,GAAA,EAAQA,IAAA,CACxC,GAAAmZ,GAAA2e,EAAA93B,EACA,OAAAmZ,EACA2e,EAAAv3B,OAAAP,EAAA,GACK,OAAAmZ,GACL2e,EAAAv3B,OAAAP,EAAA,GACAg4B,KACKA,IACLF,EAAAv3B,OAAAP,EAAA,GACAg4B,KAKA,GAAAD,EACA,KAAUC,IAAMA,EAChBF,EAAAxT,QAAA,KAIA,OAAAwT,GA+JA,QAAA7uB,GAAAgvB,EAAAC,GACA,GAAAD,EAAAhvB,OAAA,MAAAgvB,GAAAhvB,OAAAivB,EAEA,QADAC,MACAn4B,EAAA,EAAmBA,EAAAi4B,EAAAh4B,OAAeD,IAClCk4B,EAAAD,EAAAj4B,KAAAi4B,IAAAE,EAAA35B,KAAAy5B,EAAAj4B,GAEA,OAAAm4B,GAhKA,GAAAC,GACA,gEACAC,EAAA,SAAAC,GACA,MAAAF,GAAAve,KAAAye,GAAAh2B,MAAA,GAKAqB,GAAA+N,QAAA,WAIA,OAHA6mB,GAAA,GACAC,KAEAx4B,EAAA8Q,UAAA7Q,OAAA,EAAoCD,GAAA,KAAAw4B,EAA8Bx4B,IAAA,CAClE,GAAAiH,GAAAjH,GAAA,EAAA8Q,UAAA9Q,GAAA43B,EAAAa,KAGA,oBAAAxxB,GACA,SAAAyxB,WAAA,4CACKzxB,KAILsxB,EAAAtxB,EAAA,IAAAsxB,EACAC,EAAA,MAAAvxB,EAAAmH,OAAA,IAWA,MAJAmqB,GAAAV,EAAA5uB,EAAAsvB,EAAAxqB,MAAA,cAAA/R,GACA,QAAAA,KACGw8B,GAAA5yB,KAAA,MAEH4yB,EAAA,QAAAD,GAAA,KAKA50B,EAAAg1B,UAAA,SAAA1xB,GACA,GAAA2xB,GAAAj1B,EAAAi1B,WAAA3xB,GACA4xB,EAAA,MAAAtsB,EAAAtF,EAAA,GAcA,OAXAA,GAAA4wB,EAAA5uB,EAAAhC,EAAA8G,MAAA,cAAA/R,GACA,QAAAA,KACG48B,GAAAhzB,KAAA,KAEHqB,GAAA2xB,IACA3xB,EAAA,KAEAA,GAAA4xB,IACA5xB,GAAA,MAGA2xB,EAAA,QAAA3xB,GAIAtD,EAAAi1B,WAAA,SAAA3xB,GACA,YAAAA,EAAAmH,OAAA,IAIAzK,EAAAiC,KAAA,WACA,GAAAkzB,GAAAhtB,MAAA/M,UAAAuD,MAAAtE,KAAA8S,UAAA,EACA,OAAAnN,GAAAg1B,UAAA1vB,EAAA6vB,EAAA,SAAA98B,EAAAod,GACA,mBAAApd,GACA,SAAA08B,WAAA,yCAEA,OAAA18B,KACG4J,KAAA,OAMHjC,EAAAqjB,SAAA,SAAAnT,EAAA+J,GAIA,QAAAmb,GAAAC,GAEA,IADA,GAAAC,GAAA,EACUA,EAAAD,EAAA/4B,QACV,KAAA+4B,EAAAC,GAD8BA,KAK9B,IADA,GAAAC,GAAAF,EAAA/4B,OAAA,EACUi5B,GAAA,GACV,KAAAF,EAAAE,GADoBA,KAIpB,MAAAD,GAAAC,KACAF,EAAA12B,MAAA22B,EAAAC,EAAAD,EAAA,GAfAplB,EAAAlQ,EAAA+N,QAAAmC,GAAAtH,OAAA,GACAqR,EAAAja,EAAA+N,QAAAkM,GAAArR,OAAA,EAsBA,QALA4sB,GAAAJ,EAAAllB,EAAA9F,MAAA,MACAqrB,EAAAL,EAAAnb,EAAA7P,MAAA,MAEA9N,EAAA6T,KAAAulB,IAAAF,EAAAl5B,OAAAm5B,EAAAn5B,QACAq5B,EAAAr5B,EACAD,EAAA,EAAiBC,EAAAD,EAAYA,IAC7B,GAAAm5B,EAAAn5B,KAAAo5B,EAAAp5B,GAAA,CACAs5B,EAAAt5B,CACA,OAKA,OADAu5B,MACAv5B,EAAAs5B,EAA+Bt5B,EAAAm5B,EAAAl5B,OAAsBD,IACrDu5B,EAAA/6B,KAAA,KAKA,OAFA+6B,KAAAzkB,OAAAskB,EAAA92B,MAAAg3B,IAEAC,EAAA3zB,KAAA,MAGAjC,EAAA61B,IAAA,IACA71B,EAAA81B,UAAA,IAEA91B,EAAA+1B,QAAA,SAAAzyB,GACA,GAAAlE,GAAAs1B,EAAApxB,GACA4f,EAAA9jB,EAAA,GACA42B,EAAA52B,EAAA,EAEA,OAAA8jB,IAAA8S,GAKAA,IAEAA,IAAAptB,OAAA,EAAAotB,EAAA15B,OAAA,IAGA4mB,EAAA8S,GARA,KAYAh2B,EAAAi2B,SAAA,SAAA3yB,EAAA4yB,GACA,GAAA3B,GAAAG,EAAApxB,GAAA,EAKA,OAHA4yB,IAAA3B,EAAA3rB,OAAA,GAAAstB,EAAA55B,UAAA45B,IACA3B,IAAA3rB,OAAA,EAAA2rB,EAAAj4B,OAAA45B,EAAA55B,SAEAi4B,GAIAv0B,EAAAm2B,QAAA,SAAA7yB,GACA,MAAAoxB,GAAApxB,GAAA,GAaA,IAAAsF,GAAA,WAAAA,OAAA,IACA,SAAA/E,EAAAyxB,EAAArlB,GAAkC,MAAApM,GAAA+E,OAAA0sB,EAAArlB,IAClC,SAAApM,EAAAyxB,EAAArlB,GAEA,MADA,GAAAqlB,MAAAzxB,EAAAvH,OAAAg5B,GACAzxB,EAAA+E,OAAA0sB,EAAArlB,MhBuiO8B5V,KAAK2F,EAAS5H,EAAoB,MAI1D,SAASoG,EAAQwB,GiBhwOvB,QAAAo2B,KACAC,GAAAC,IAGAD,KACAC,EAAAh6B,OACAoC,EAAA43B,EAAAnlB,OAAAzS,GAEA63B,EAAA,GAEA73B,EAAApC,QACAk6B,KAIA,QAAAA,KACA,IAAAH,EAAA,CAGA,GAAAt9B,GAAA09B,WAAAL,EACAC,KAGA,KADA,GAAApmB,GAAAvR,EAAApC,OACA2T,GAAA,CAGA,IAFAqmB,EAAA53B,EACAA,OACA63B,EAAAtmB,GACAqmB,GACAA,EAAAC,GAAAtG,KAGAsG,GAAA,GACAtmB,EAAAvR,EAAApC,OAEAg6B,EAAA,KACAD,KACAK,aAAA39B,IAiBA,QAAA49B,GAAAC,EAAA7mB,GACA5P,KAAAy2B,MACAz2B,KAAA4P,QAYA,QAAA7B,MAzEA,GAGAooB,GAHArC,EAAAz1B,EAAAwB,WACAtB,KACA23B,KAEAE,EAAA,EAyCAtC,GAAA4C,SAAA,SAAAD,GACA,GAAAE,GAAA,GAAA3uB,OAAAgF,UAAA7Q,OAAA,EACA,IAAA6Q,UAAA7Q,OAAA,EACA,OAAAD,GAAA,EAAuBA,EAAA8Q,UAAA7Q,OAAsBD,IAC7Cy6B,EAAAz6B,EAAA,GAAA8Q,UAAA9Q,EAGAqC,GAAA7D,KAAA,GAAA87B,GAAAC,EAAAE,IACA,IAAAp4B,EAAApC,QAAA+5B,GACAI,WAAAD,EAAA,IASAG,EAAAv7B,UAAA60B,IAAA,WACA9vB,KAAAy2B,IAAA75B,MAAA,KAAAoD,KAAA4P,QAEAkkB,EAAAvD,MAAA,UACAuD,EAAA8C,WACA9C,EAAA+C,OACA/C,EAAAgD,QACAhD,EAAArN,QAAA,GACAqN,EAAAiD,YAIAjD,EAAAkD,GAAAjpB,EACA+lB,EAAAmD,YAAAlpB,EACA+lB,EAAAoD,KAAAnpB,EACA+lB,EAAAqD,IAAAppB,EACA+lB,EAAAsD,eAAArpB,EACA+lB,EAAAuD,mBAAAtpB,EACA+lB,EAAAwD,KAAAvpB,EAEA+lB,EAAAyD,QAAA,SAAAx8B,GACA,SAAAvC,OAAA,qCAGAs7B,EAAAa,IAAA,WAA2B,WAC3Bb,EAAA0D,MAAA,SAAA3B,GACA,SAAAr9B,OAAA,mCAEAs7B,EAAA2D,MAAA,WAA4B","file":"app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \tvar parentHotUpdateCallback = this[\"webpackHotUpdate\"];\n/******/ \tthis[\"webpackHotUpdate\"] = \r\n/******/ \tfunction webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n/******/ \t\thotAddUpdateChunk(chunkId, moreModules);\r\n/******/ \t\tif(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n/******/ \t\tvar script = document.createElement(\"script\");\r\n/******/ \t\tscript.type = \"text/javascript\";\r\n/******/ \t\tscript.charset = \"utf-8\";\r\n/******/ \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\";\r\n/******/ \t\thead.appendChild(script);\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tif(typeof XMLHttpRequest === \"undefined\")\r\n/******/ \t\t\treturn callback(new Error(\"No browser support\"));\r\n/******/ \t\ttry {\r\n/******/ \t\t\tvar request = new XMLHttpRequest();\r\n/******/ \t\t\tvar requestPath = __webpack_require__.p + \"\" + hotCurrentHash + \".hot-update.json\";\r\n/******/ \t\t\trequest.open(\"GET\", requestPath, true);\r\n/******/ \t\t\trequest.timeout = 10000;\r\n/******/ \t\t\trequest.send(null);\r\n/******/ \t\t} catch(err) {\r\n/******/ \t\t\treturn callback(err);\r\n/******/ \t\t}\r\n/******/ \t\trequest.onreadystatechange = function() {\r\n/******/ \t\t\tif(request.readyState !== 4) return;\r\n/******/ \t\t\tif(request.status === 0) {\r\n/******/ \t\t\t\t// timeout\r\n/******/ \t\t\t\tcallback(new Error(\"Manifest request to \" + requestPath + \" timed out.\"));\r\n/******/ \t\t\t} else if(request.status === 404) {\r\n/******/ \t\t\t\t// no update available\r\n/******/ \t\t\t\tcallback();\r\n/******/ \t\t\t} else if(request.status !== 200 && request.status !== 304) {\r\n/******/ \t\t\t\t// other failure\r\n/******/ \t\t\t\tcallback(new Error(\"Manifest request to \" + requestPath + \" failed.\"));\r\n/******/ \t\t\t} else {\r\n/******/ \t\t\t\t// success\r\n/******/ \t\t\t\ttry {\r\n/******/ \t\t\t\t\tvar update = JSON.parse(request.responseText);\r\n/******/ \t\t\t\t} catch(e) {\r\n/******/ \t\t\t\t\tcallback(e);\r\n/******/ \t\t\t\t\treturn;\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tcallback(null, update);\r\n/******/ \t\t\t}\r\n/******/ \t\t};\r\n/******/ \t}\r\n/******/\n/******/ \t\r\n/******/ \t\r\n/******/ \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n/******/ \tvar canDefineProperty = false;\r\n/******/ \ttry {\r\n/******/ \t\tObject.defineProperty({}, \"x\", {\r\n/******/ \t\t\tget: function() {}\r\n/******/ \t\t});\r\n/******/ \t\tcanDefineProperty = true;\r\n/******/ \t} catch(x) {\r\n/******/ \t\t// IE will fail on defineProperty\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotApplyOnUpdate = true;\r\n/******/ \tvar hotCurrentHash = \"26a4502983c84f9af9cd\"; // eslint-disable-line no-unused-vars\r\n/******/ \tvar hotCurrentModuleData = {};\r\n/******/ \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n/******/ \t\r\n/******/ \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar me = installedModules[moduleId];\r\n/******/ \t\tif(!me) return __webpack_require__;\r\n/******/ \t\tvar fn = function(request) {\r\n/******/ \t\t\tif(me.hot.active) {\r\n/******/ \t\t\t\tif(installedModules[request]) {\r\n/******/ \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n/******/ \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n/******/ \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n/******/ \t\t\t\t\t\tme.children.push(request);\r\n/******/ \t\t\t\t} else hotCurrentParents = [moduleId];\r\n/******/ \t\t\t} else {\r\n/******/ \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n/******/ \t\t\t\thotCurrentParents = [];\r\n/******/ \t\t\t}\r\n/******/ \t\t\treturn __webpack_require__(request);\r\n/******/ \t\t};\r\n/******/ \t\tfor(var name in __webpack_require__) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n/******/ \t\t\t\tif(canDefineProperty) {\r\n/******/ \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n/******/ \t\t\t\t\t\treturn {\r\n/******/ \t\t\t\t\t\t\tconfigurable: true,\r\n/******/ \t\t\t\t\t\t\tenumerable: true,\r\n/******/ \t\t\t\t\t\t\tget: function() {\r\n/******/ \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n/******/ \t\t\t\t\t\t\t},\r\n/******/ \t\t\t\t\t\t\tset: function(value) {\r\n/******/ \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n/******/ \t\t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\t};\r\n/******/ \t\t\t\t\t}(name)));\r\n/******/ \t\t\t\t} else {\r\n/******/ \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction ensure(chunkId, callback) {\r\n/******/ \t\t\tif(hotStatus === \"ready\")\r\n/******/ \t\t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotChunksLoading++;\r\n/******/ \t\t\t__webpack_require__.e(chunkId, function() {\r\n/******/ \t\t\t\ttry {\r\n/******/ \t\t\t\t\tcallback.call(null, fn);\r\n/******/ \t\t\t\t} finally {\r\n/******/ \t\t\t\t\tfinishChunkLoading();\r\n/******/ \t\t\t\t}\r\n/******/ \t\r\n/******/ \t\t\t\tfunction finishChunkLoading() {\r\n/******/ \t\t\t\t\thotChunksLoading--;\r\n/******/ \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n/******/ \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n/******/ \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t\t\t\t}\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\tif(canDefineProperty) {\r\n/******/ \t\t\tObject.defineProperty(fn, \"e\", {\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tvalue: ensure\r\n/******/ \t\t\t});\r\n/******/ \t\t} else {\r\n/******/ \t\t\tfn.e = ensure;\r\n/******/ \t\t}\r\n/******/ \t\treturn fn;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tvar hot = {\r\n/******/ \t\t\t// private stuff\r\n/******/ \t\t\t_acceptedDependencies: {},\r\n/******/ \t\t\t_declinedDependencies: {},\r\n/******/ \t\t\t_selfAccepted: false,\r\n/******/ \t\t\t_selfDeclined: false,\r\n/******/ \t\t\t_disposeHandlers: [],\r\n/******/ \t\r\n/******/ \t\t\t// Module API\r\n/******/ \t\t\tactive: true,\r\n/******/ \t\t\taccept: function(dep, callback) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfAccepted = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"function\")\r\n/******/ \t\t\t\t\thot._selfAccepted = dep;\r\n/******/ \t\t\t\telse if(typeof dep === \"object\")\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdecline: function(dep) {\r\n/******/ \t\t\t\tif(typeof dep === \"undefined\")\r\n/******/ \t\t\t\t\thot._selfDeclined = true;\r\n/******/ \t\t\t\telse if(typeof dep === \"number\")\r\n/******/ \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n/******/ \t\t\t\telse\r\n/******/ \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n/******/ \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n/******/ \t\t\t},\r\n/******/ \t\t\tdispose: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddDisposeHandler: function(callback) {\r\n/******/ \t\t\t\thot._disposeHandlers.push(callback);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveDisposeHandler: function(callback) {\r\n/******/ \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n/******/ \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t// Management API\r\n/******/ \t\t\tcheck: hotCheck,\r\n/******/ \t\t\tapply: hotApply,\r\n/******/ \t\t\tstatus: function(l) {\r\n/******/ \t\t\t\tif(!l) return hotStatus;\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\taddStatusHandler: function(l) {\r\n/******/ \t\t\t\thotStatusHandlers.push(l);\r\n/******/ \t\t\t},\r\n/******/ \t\t\tremoveStatusHandler: function(l) {\r\n/******/ \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n/******/ \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n/******/ \t\t\t},\r\n/******/ \t\r\n/******/ \t\t\t//inherit from previous dispose call\r\n/******/ \t\t\tdata: hotCurrentModuleData[moduleId]\r\n/******/ \t\t};\r\n/******/ \t\treturn hot;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tvar hotStatusHandlers = [];\r\n/******/ \tvar hotStatus = \"idle\";\r\n/******/ \t\r\n/******/ \tfunction hotSetStatus(newStatus) {\r\n/******/ \t\thotStatus = newStatus;\r\n/******/ \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n/******/ \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \t// while downloading\r\n/******/ \tvar hotWaitingFiles = 0;\r\n/******/ \tvar hotChunksLoading = 0;\r\n/******/ \tvar hotWaitingFilesMap = {};\r\n/******/ \tvar hotRequestedFilesMap = {};\r\n/******/ \tvar hotAvailibleFilesMap = {};\r\n/******/ \tvar hotCallback;\r\n/******/ \t\r\n/******/ \t// The update info\r\n/******/ \tvar hotUpdate, hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \tfunction toModuleId(id) {\r\n/******/ \t\tvar isNumber = (+id) + \"\" === id;\r\n/******/ \t\treturn isNumber ? +id : id;\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotCheck(apply, callback) {\r\n/******/ \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n/******/ \t\tif(typeof apply === \"function\") {\r\n/******/ \t\t\thotApplyOnUpdate = false;\r\n/******/ \t\t\tcallback = apply;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotApplyOnUpdate = apply;\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\thotSetStatus(\"check\");\r\n/******/ \t\thotDownloadManifest(function(err, update) {\r\n/******/ \t\t\tif(err) return callback(err);\r\n/******/ \t\t\tif(!update) {\r\n/******/ \t\t\t\thotSetStatus(\"idle\");\r\n/******/ \t\t\t\tcallback(null, null);\r\n/******/ \t\t\t\treturn;\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\thotRequestedFilesMap = {};\r\n/******/ \t\t\thotAvailibleFilesMap = {};\r\n/******/ \t\t\thotWaitingFilesMap = {};\r\n/******/ \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n/******/ \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n/******/ \t\t\thotUpdateNewHash = update.h;\r\n/******/ \t\r\n/******/ \t\t\thotSetStatus(\"prepare\");\r\n/******/ \t\t\thotCallback = callback;\r\n/******/ \t\t\thotUpdate = {};\r\n/******/ \t\t\tvar chunkId = 0;\r\n/******/ \t\t\t{ // eslint-disable-line no-lone-blocks\r\n/******/ \t\t\t\t/*globals chunkId */\r\n/******/ \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n/******/ \t\t\t}\r\n/******/ \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n/******/ \t\t\t\thotUpdateDownloaded();\r\n/******/ \t\t\t}\r\n/******/ \t\t});\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n/******/ \t\t\treturn;\r\n/******/ \t\thotRequestedFilesMap[chunkId] = false;\r\n/******/ \t\tfor(var moduleId in moreModules) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n/******/ \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n/******/ \t\t\thotUpdateDownloaded();\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotEnsureUpdateChunk(chunkId) {\r\n/******/ \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n/******/ \t\t\thotWaitingFilesMap[chunkId] = true;\r\n/******/ \t\t} else {\r\n/******/ \t\t\thotRequestedFilesMap[chunkId] = true;\r\n/******/ \t\t\thotWaitingFiles++;\r\n/******/ \t\t\thotDownloadUpdateChunk(chunkId);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotUpdateDownloaded() {\r\n/******/ \t\thotSetStatus(\"ready\");\r\n/******/ \t\tvar callback = hotCallback;\r\n/******/ \t\thotCallback = null;\r\n/******/ \t\tif(!callback) return;\r\n/******/ \t\tif(hotApplyOnUpdate) {\r\n/******/ \t\t\thotApply(hotApplyOnUpdate, callback);\r\n/******/ \t\t} else {\r\n/******/ \t\t\tvar outdatedModules = [];\r\n/******/ \t\t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t\tcallback(null, outdatedModules);\r\n/******/ \t\t}\r\n/******/ \t}\r\n/******/ \t\r\n/******/ \tfunction hotApply(options, callback) {\r\n/******/ \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n/******/ \t\tif(typeof options === \"function\") {\r\n/******/ \t\t\tcallback = options;\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t} else if(options && typeof options === \"object\") {\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t} else {\r\n/******/ \t\t\toptions = {};\r\n/******/ \t\t\tcallback = callback || function(err) {\r\n/******/ \t\t\t\tif(err) throw err;\r\n/******/ \t\t\t};\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction getAffectedStuff(module) {\r\n/******/ \t\t\tvar outdatedModules = [module];\r\n/******/ \t\t\tvar outdatedDependencies = {};\r\n/******/ \t\r\n/******/ \t\t\tvar queue = outdatedModules.slice();\r\n/******/ \t\t\twhile(queue.length > 0) {\r\n/******/ \t\t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tif(!module || module.hot._selfAccepted)\r\n/******/ \t\t\t\t\tcontinue;\r\n/******/ \t\t\t\tif(module.hot._selfDeclined) {\r\n/******/ \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(moduleId === 0) {\r\n/******/ \t\t\t\t\treturn;\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n/******/ \t\t\t\t\tvar parentId = module.parents[i];\r\n/******/ \t\t\t\t\tvar parent = installedModules[parentId];\r\n/******/ \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n/******/ \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n/******/ \t\t\t\t\toutdatedModules.push(parentId);\r\n/******/ \t\t\t\t\tqueue.push(parentId);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\r\n/******/ \t\t\treturn [outdatedModules, outdatedDependencies];\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\tfunction addAllToSet(a, b) {\r\n/******/ \t\t\tfor(var i = 0; i < b.length; i++) {\r\n/******/ \t\t\t\tvar item = b[i];\r\n/******/ \t\t\t\tif(a.indexOf(item) < 0)\r\n/******/ \t\t\t\t\ta.push(item);\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// at begin all updates modules are outdated\r\n/******/ \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n/******/ \t\tvar outdatedDependencies = {};\r\n/******/ \t\tvar outdatedModules = [];\r\n/******/ \t\tvar appliedUpdate = {};\r\n/******/ \t\tfor(var id in hotUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n/******/ \t\t\t\tvar moduleId = toModuleId(id);\r\n/******/ \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n/******/ \t\t\t\tif(!result) {\r\n/******/ \t\t\t\t\tif(options.ignoreUnaccepted)\r\n/******/ \t\t\t\t\t\tcontinue;\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tif(result instanceof Error) {\r\n/******/ \t\t\t\t\thotSetStatus(\"abort\");\r\n/******/ \t\t\t\t\treturn callback(result);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n/******/ \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n/******/ \t\t\t\tfor(var moduleId in result[1]) {\r\n/******/ \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n/******/ \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n/******/ \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n/******/ \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Store self accepted outdated modules to require them later by the module system\r\n/******/ \t\tvar outdatedSelfAcceptedModules = [];\r\n/******/ \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n/******/ \t\t\tvar moduleId = outdatedModules[i];\r\n/******/ \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n/******/ \t\t\t\toutdatedSelfAcceptedModules.push({\r\n/******/ \t\t\t\t\tmodule: moduleId,\r\n/******/ \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n/******/ \t\t\t\t});\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Now in \"dispose\" phase\r\n/******/ \t\thotSetStatus(\"dispose\");\r\n/******/ \t\tvar queue = outdatedModules.slice();\r\n/******/ \t\twhile(queue.length > 0) {\r\n/******/ \t\t\tvar moduleId = queue.pop();\r\n/******/ \t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\tif(!module) continue;\r\n/******/ \t\r\n/******/ \t\t\tvar data = {};\r\n/******/ \t\r\n/******/ \t\t\t// Call dispose handlers\r\n/******/ \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n/******/ \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n/******/ \t\t\t\tvar cb = disposeHandlers[j];\r\n/******/ \t\t\t\tcb(data);\r\n/******/ \t\t\t}\r\n/******/ \t\t\thotCurrentModuleData[moduleId] = data;\r\n/******/ \t\r\n/******/ \t\t\t// disable module (this disables requires from this module)\r\n/******/ \t\t\tmodule.hot.active = false;\r\n/******/ \t\r\n/******/ \t\t\t// remove module from cache\r\n/******/ \t\t\tdelete installedModules[moduleId];\r\n/******/ \t\r\n/******/ \t\t\t// remove \"parents\" references from all children\r\n/******/ \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n/******/ \t\t\t\tvar child = installedModules[module.children[j]];\r\n/******/ \t\t\t\tif(!child) continue;\r\n/******/ \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n/******/ \t\t\t\tif(idx >= 0) {\r\n/******/ \t\t\t\t\tchild.parents.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// remove outdated dependency from module children\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n/******/ \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n/******/ \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Not in \"apply\" phase\r\n/******/ \t\thotSetStatus(\"apply\");\r\n/******/ \t\r\n/******/ \t\thotCurrentHash = hotUpdateNewHash;\r\n/******/ \t\r\n/******/ \t\t// insert new code\r\n/******/ \t\tfor(var moduleId in appliedUpdate) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n/******/ \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// call accept handlers\r\n/******/ \t\tvar error = null;\r\n/******/ \t\tfor(var moduleId in outdatedDependencies) {\r\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n/******/ \t\t\t\tvar module = installedModules[moduleId];\r\n/******/ \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n/******/ \t\t\t\tvar callbacks = [];\r\n/******/ \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n/******/ \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n/******/ \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n/******/ \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n/******/ \t\t\t\t\tcallbacks.push(cb);\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n/******/ \t\t\t\t\tvar cb = callbacks[i];\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\tcb(outdatedDependencies);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t}\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// Load self accepted modules\r\n/******/ \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n/******/ \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n/******/ \t\t\tvar moduleId = item.module;\r\n/******/ \t\t\thotCurrentParents = [moduleId];\r\n/******/ \t\t\ttry {\r\n/******/ \t\t\t\t__webpack_require__(moduleId);\r\n/******/ \t\t\t} catch(err) {\r\n/******/ \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n/******/ \t\t\t\t\ttry {\r\n/******/ \t\t\t\t\t\titem.errorHandler(err);\r\n/******/ \t\t\t\t\t} catch(err) {\r\n/******/ \t\t\t\t\t\tif(!error)\r\n/******/ \t\t\t\t\t\t\terror = err;\r\n/******/ \t\t\t\t\t}\r\n/******/ \t\t\t\t} else if(!error)\r\n/******/ \t\t\t\t\terror = err;\r\n/******/ \t\t\t}\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\t// handle errors in accept handlers and self accepted module load\r\n/******/ \t\tif(error) {\r\n/******/ \t\t\thotSetStatus(\"fail\");\r\n/******/ \t\t\treturn callback(error);\r\n/******/ \t\t}\r\n/******/ \t\r\n/******/ \t\thotSetStatus(\"idle\");\r\n/******/ \t\tcallback(null, outdatedModules);\r\n/******/ \t}\r\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\thot: hotCreateModule(moduleId),\n/******/ \t\t\tparents: hotCurrentParents,\n/******/ \t\t\tchildren: []\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/statics/\";\n/******/\n/******/ \t// __webpack_hash__\n/******/ \t__webpack_require__.h = function() { return hotCurrentHash; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn hotCreateRequire(0)(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(16);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t\n\tvar app = angular.module(\"todo\", [__webpack_require__(8), __webpack_require__(7), __webpack_require__(4), __webpack_require__(5)]);\n\tapp.value('TODO_VERSON', 'beta 1.0');\n\t\n\tapp.config([\"$resourceProvider\", function ($resourceProvider) {\n\t    $resourceProvider.defaults.actions.update = {\n\t        \"method\": \"PUT\"\n\t    };\n\t}]);\n\t\n\texports.default = app;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _path = __webpack_require__(17);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_app2.default.factory(\"todoTools\", [\"$http\", \"$window\", \"$cookies\", function ($http, $window, $cookies) {\n\t    var tools = {\n\t        /**1w\n\t         * 生成api请求地址\n\t         *\n\t         * @param url 请求的api地址\n\t         * @returns {string|*} 返回完整的api请求地址\n\t         */\n\t        apiUrl: function apiUrl(url) {\n\t            return _path2.default.join(\"/api/v1\", url);\n\t        },\n\t        /**\n\t         * userInfo 获取用户信息(从localStorage)\n\t         */\n\t        userInfo: {\n\t            /**\n\t             * 获取用户userid\n\t             */\n\t            userid: function userid() {\n\t                return $window.localStorage.getItem(\"TODO-userid\") == null ? 1 : parseInt($window.localStorage.getItem(\"TODO-userid\"));\n\t            },\n\t            /**\n\t             * 获取用户user_name\n\t             */\n\t            userName: function userName() {\n\t                return $window.localStorage.getItem(\"TODO-user_name\") == null ? \"\" : $window.localStorage.getItem(\"TODO-user_name\");\n\t            },\n\t            /**\n\t             * 获取用户上次登录时间\n\t             */\n\t            lastLogin: function lastLogin() {\n\t                return $window.localStorage.getItem(\"TODO-last_login\") == null ? 0 : parseInt($window.localStorage.getItem(\"TODO-last_login\"));\n\t            },\n\t            /**\n\t             * 获取用户未完成数量\n\t             */\n\t            unfinishNum: function unfinishNum() {\n\t                return $window.localStorage.getItem(\"TODO-unfinish_num\") == null ? 0 : parseInt($window.localStorage.getItem(\"TODO-unfinish_num\"));\n\t            },\n\t            /**\n\t             * 保存用户信息\n\t             *\n\t             * @param userInfo\n\t             */\n\t            save: function save(userInfo) {\n\t                if ((typeof userInfo === \"undefined\" ? \"undefined\" : _typeof(userInfo)) == \"object\") {\n\t                    if (typeof userInfo.userid != 'undefined') {\n\t                        $window.localStorage.setItem(\"TODO-userid\", userInfo.userid);\n\t                    }\n\t                    if (typeof userInfo['user_name'] != 'undefined') {\n\t                        $window.localStorage.setItem(\"TODO-user_name\", userInfo['user_name']);\n\t                    }\n\t                    if (typeof userInfo['last_login'] != 'undefined') {\n\t                        $window.localStorage.setItem(\"TODO-last_login\", userInfo['last_login']);\n\t                    }\n\t                    if (typeof userInfo['unfinish_num'] != 'undefined') {\n\t                        $window.localStorage.setItem(\"TODO-unfinish_num\", userInfo['unfinish_num']);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        /**\n\t         * 用户是否登录\n\t         *\n\t         * @returns {boolean}\n\t         */\n\t        isLogin: function isLogin() {\n\t            return $cookies.get('todo_logintoken') != \"\" && typeof $cookies.get('todo_logintoken') != 'undefined';\n\t        }\n\t    };\n\t\n\t    return tools;\n\t}]);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.6\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngCookies\n\t * @description\n\t *\n\t * # ngCookies\n\t *\n\t * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies.\n\t *\n\t *\n\t * <div doc-module-components=\"ngCookies\"></div>\n\t *\n\t * See {@link ngCookies.$cookies `$cookies`} for usage.\n\t */\n\t\n\t\n\tangular.module('ngCookies', ['ng']).\n\t  /**\n\t   * @ngdoc provider\n\t   * @name $cookiesProvider\n\t   * @description\n\t   * Use `$cookiesProvider` to change the default behavior of the {@link ngCookies.$cookies $cookies} service.\n\t   * */\n\t   provider('$cookies', [function $CookiesProvider() {\n\t    /**\n\t     * @ngdoc property\n\t     * @name $cookiesProvider#defaults\n\t     * @description\n\t     *\n\t     * Object containing default options to pass when setting cookies.\n\t     *\n\t     * The object may have following properties:\n\t     *\n\t     * - **path** - `{string}` - The cookie will be available only for this path and its\n\t     *   sub-paths. By default, this is the URL that appears in your `<base>` tag.\n\t     * - **domain** - `{string}` - The cookie will be available only for this domain and\n\t     *   its sub-domains. For security reasons the user agent will not accept the cookie\n\t     *   if the current domain is not a sub-domain of this domain or equal to it.\n\t     * - **expires** - `{string|Date}` - String of the form \"Wdy, DD Mon YYYY HH:MM:SS GMT\"\n\t     *   or a Date object indicating the exact date/time this cookie will expire.\n\t     * - **secure** - `{boolean}` - If `true`, then the cookie will only be available through a\n\t     *   secured connection.\n\t     *\n\t     * Note: By default, the address that appears in your `<base>` tag will be used as the path.\n\t     * This is important so that cookies will be visible for all routes when html5mode is enabled.\n\t     *\n\t     **/\n\t    var defaults = this.defaults = {};\n\t\n\t    function calcOptions(options) {\n\t      return options ? angular.extend({}, defaults, options) : defaults;\n\t    }\n\t\n\t    /**\n\t     * @ngdoc service\n\t     * @name $cookies\n\t     *\n\t     * @description\n\t     * Provides read/write access to browser's cookies.\n\t     *\n\t     * <div class=\"alert alert-info\">\n\t     * Up until Angular 1.3, `$cookies` exposed properties that represented the\n\t     * current browser cookie values. In version 1.4, this behavior has changed, and\n\t     * `$cookies` now provides a standard api of getters, setters etc.\n\t     * </div>\n\t     *\n\t     * Requires the {@link ngCookies `ngCookies`} module to be installed.\n\t     *\n\t     * @example\n\t     *\n\t     * ```js\n\t     * angular.module('cookiesExample', ['ngCookies'])\n\t     *   .controller('ExampleController', ['$cookies', function($cookies) {\n\t     *     // Retrieving a cookie\n\t     *     var favoriteCookie = $cookies.get('myFavorite');\n\t     *     // Setting a cookie\n\t     *     $cookies.put('myFavorite', 'oatmeal');\n\t     *   }]);\n\t     * ```\n\t     */\n\t    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {\n\t      return {\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#get\n\t         *\n\t         * @description\n\t         * Returns the value of given cookie key\n\t         *\n\t         * @param {string} key Id to use for lookup.\n\t         * @returns {string} Raw cookie value.\n\t         */\n\t        get: function(key) {\n\t          return $$cookieReader()[key];\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#getObject\n\t         *\n\t         * @description\n\t         * Returns the deserialized value of given cookie key\n\t         *\n\t         * @param {string} key Id to use for lookup.\n\t         * @returns {Object} Deserialized cookie value.\n\t         */\n\t        getObject: function(key) {\n\t          var value = this.get(key);\n\t          return value ? angular.fromJson(value) : value;\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#getAll\n\t         *\n\t         * @description\n\t         * Returns a key value object with all the cookies\n\t         *\n\t         * @returns {Object} All cookies\n\t         */\n\t        getAll: function() {\n\t          return $$cookieReader();\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#put\n\t         *\n\t         * @description\n\t         * Sets a value for given cookie key\n\t         *\n\t         * @param {string} key Id for the `value`.\n\t         * @param {string} value Raw value to be stored.\n\t         * @param {Object=} options Options object.\n\t         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n\t         */\n\t        put: function(key, value, options) {\n\t          $$cookieWriter(key, value, calcOptions(options));\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#putObject\n\t         *\n\t         * @description\n\t         * Serializes and sets a value for given cookie key\n\t         *\n\t         * @param {string} key Id for the `value`.\n\t         * @param {Object} value Value to be stored.\n\t         * @param {Object=} options Options object.\n\t         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n\t         */\n\t        putObject: function(key, value, options) {\n\t          this.put(key, angular.toJson(value), options);\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $cookies#remove\n\t         *\n\t         * @description\n\t         * Remove given cookie\n\t         *\n\t         * @param {string} key Id of the key-value pair to delete.\n\t         * @param {Object=} options Options object.\n\t         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n\t         */\n\t        remove: function(key, options) {\n\t          $$cookieWriter(key, undefined, calcOptions(options));\n\t        }\n\t      };\n\t    }];\n\t  }]);\n\t\n\tangular.module('ngCookies').\n\t/**\n\t * @ngdoc service\n\t * @name $cookieStore\n\t * @deprecated\n\t * @requires $cookies\n\t *\n\t * @description\n\t * Provides a key-value (string-object) storage, that is backed by session cookies.\n\t * Objects put or retrieved from this storage are automatically serialized or\n\t * deserialized by angular's toJson/fromJson.\n\t *\n\t * Requires the {@link ngCookies `ngCookies`} module to be installed.\n\t *\n\t * <div class=\"alert alert-danger\">\n\t * **Note:** The $cookieStore service is **deprecated**.\n\t * Please use the {@link ngCookies.$cookies `$cookies`} service instead.\n\t * </div>\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * angular.module('cookieStoreExample', ['ngCookies'])\n\t *   .controller('ExampleController', ['$cookieStore', function($cookieStore) {\n\t *     // Put cookie\n\t *     $cookieStore.put('myFavorite','oatmeal');\n\t *     // Get cookie\n\t *     var favoriteCookie = $cookieStore.get('myFavorite');\n\t *     // Removing a cookie\n\t *     $cookieStore.remove('myFavorite');\n\t *   }]);\n\t * ```\n\t */\n\t factory('$cookieStore', ['$cookies', function($cookies) {\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc method\n\t       * @name $cookieStore#get\n\t       *\n\t       * @description\n\t       * Returns the value of given cookie key\n\t       *\n\t       * @param {string} key Id to use for lookup.\n\t       * @returns {Object} Deserialized cookie value, undefined if the cookie does not exist.\n\t       */\n\t      get: function(key) {\n\t        return $cookies.getObject(key);\n\t      },\n\t\n\t      /**\n\t       * @ngdoc method\n\t       * @name $cookieStore#put\n\t       *\n\t       * @description\n\t       * Sets a value for given cookie key\n\t       *\n\t       * @param {string} key Id for the `value`.\n\t       * @param {Object} value Value to be stored.\n\t       */\n\t      put: function(key, value) {\n\t        $cookies.putObject(key, value);\n\t      },\n\t\n\t      /**\n\t       * @ngdoc method\n\t       * @name $cookieStore#remove\n\t       *\n\t       * @description\n\t       * Remove given cookie\n\t       *\n\t       * @param {string} key Id of the key-value pair to delete.\n\t       */\n\t      remove: function(key) {\n\t        $cookies.remove(key);\n\t      }\n\t    };\n\t\n\t  }]);\n\t\n\t/**\n\t * @name $$cookieWriter\n\t * @requires $document\n\t *\n\t * @description\n\t * This is a private service for writing cookies\n\t *\n\t * @param {string} name Cookie name\n\t * @param {string=} value Cookie value (if undefined, cookie will be deleted)\n\t * @param {Object=} options Object with options that need to be stored for the cookie.\n\t */\n\tfunction $$CookieWriter($document, $log, $browser) {\n\t  var cookiePath = $browser.baseHref();\n\t  var rawDocument = $document[0];\n\t\n\t  function buildCookieString(name, value, options) {\n\t    var path, expires;\n\t    options = options || {};\n\t    expires = options.expires;\n\t    path = angular.isDefined(options.path) ? options.path : cookiePath;\n\t    if (angular.isUndefined(value)) {\n\t      expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n\t      value = '';\n\t    }\n\t    if (angular.isString(expires)) {\n\t      expires = new Date(expires);\n\t    }\n\t\n\t    var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n\t    str += path ? ';path=' + path : '';\n\t    str += options.domain ? ';domain=' + options.domain : '';\n\t    str += expires ? ';expires=' + expires.toUTCString() : '';\n\t    str += options.secure ? ';secure' : '';\n\t\n\t    // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n\t    // - 300 cookies\n\t    // - 20 cookies per unique domain\n\t    // - 4096 bytes per cookie\n\t    var cookieLength = str.length + 1;\n\t    if (cookieLength > 4096) {\n\t      $log.warn(\"Cookie '\" + name +\n\t        \"' possibly not set or overflowed because it was too large (\" +\n\t        cookieLength + \" > 4096 bytes)!\");\n\t    }\n\t\n\t    return str;\n\t  }\n\t\n\t  return function(name, value, options) {\n\t    rawDocument.cookie = buildCookieString(name, value, options);\n\t  };\n\t}\n\t\n\t$$CookieWriter.$inject = ['$document', '$log', '$browser'];\n\t\n\tangular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {\n\t  this.$get = $$CookieWriter;\n\t});\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(3);\n\tmodule.exports = 'ngCookies';\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/*\n\t  angular-md5 - v0.1.8 \n\t  2015-11-17\n\t*/\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports) {\n\t  module.exports = \"angular-md5\";\n\t}\n\t(function(angular) {\n\t  angular.module(\"angular-md5\", [ \"gdi2290.md5\" ]);\n\t  angular.module(\"ngMd5\", [ \"gdi2290.md5\" ]);\n\t  angular.module(\"gdi2290.md5\", [ \"gdi2290.gravatar-filter\", \"gdi2290.md5-service\", \"gdi2290.md5-filter\" ]);\n\t  \"use strict\";\n\t  angular.module(\"gdi2290.gravatar-filter\", []).filter(\"gravatar\", [ \"md5\", function(md5) {\n\t    var cache = {};\n\t    return function(text, defaultText) {\n\t      if (!cache[text]) {\n\t        defaultText = defaultText ? md5.createHash(defaultText.toString().toLowerCase()) : \"\";\n\t        cache[text] = text ? md5.createHash(text.toString().toLowerCase()) : defaultText;\n\t      }\n\t      return cache[text];\n\t    };\n\t  } ]);\n\t  \"use strict\";\n\t  angular.module(\"gdi2290.md5-filter\", []).filter(\"md5\", [ \"md5\", function(md5) {\n\t    return function(text) {\n\t      return text ? md5.createHash(text.toString().toLowerCase()) : text;\n\t    };\n\t  } ]);\n\t  \"use strict\";\n\t  angular.module(\"gdi2290.md5-service\", []).factory(\"md5\", [ function() {\n\t    var md5 = {\n\t      createHash: function(str) {\n\t        if (null === str) {\n\t          return null;\n\t        }\n\t        var xl;\n\t        var rotateLeft = function(lValue, iShiftBits) {\n\t          return lValue << iShiftBits | lValue >>> 32 - iShiftBits;\n\t        };\n\t        var addUnsigned = function(lX, lY) {\n\t          var lX4, lY4, lX8, lY8, lResult;\n\t          lX8 = lX & 2147483648;\n\t          lY8 = lY & 2147483648;\n\t          lX4 = lX & 1073741824;\n\t          lY4 = lY & 1073741824;\n\t          lResult = (lX & 1073741823) + (lY & 1073741823);\n\t          if (lX4 & lY4) {\n\t            return lResult ^ 2147483648 ^ lX8 ^ lY8;\n\t          }\n\t          if (lX4 | lY4) {\n\t            if (lResult & 1073741824) {\n\t              return lResult ^ 3221225472 ^ lX8 ^ lY8;\n\t            } else {\n\t              return lResult ^ 1073741824 ^ lX8 ^ lY8;\n\t            }\n\t          } else {\n\t            return lResult ^ lX8 ^ lY8;\n\t          }\n\t        };\n\t        var _F = function(x, y, z) {\n\t          return x & y | ~x & z;\n\t        };\n\t        var _G = function(x, y, z) {\n\t          return x & z | y & ~z;\n\t        };\n\t        var _H = function(x, y, z) {\n\t          return x ^ y ^ z;\n\t        };\n\t        var _I = function(x, y, z) {\n\t          return y ^ (x | ~z);\n\t        };\n\t        var _FF = function(a, b, c, d, x, s, ac) {\n\t          a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));\n\t          return addUnsigned(rotateLeft(a, s), b);\n\t        };\n\t        var _GG = function(a, b, c, d, x, s, ac) {\n\t          a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));\n\t          return addUnsigned(rotateLeft(a, s), b);\n\t        };\n\t        var _HH = function(a, b, c, d, x, s, ac) {\n\t          a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));\n\t          return addUnsigned(rotateLeft(a, s), b);\n\t        };\n\t        var _II = function(a, b, c, d, x, s, ac) {\n\t          a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));\n\t          return addUnsigned(rotateLeft(a, s), b);\n\t        };\n\t        var convertToWordArray = function(str) {\n\t          var lWordCount;\n\t          var lMessageLength = str.length;\n\t          var lNumberOfWords_temp1 = lMessageLength + 8;\n\t          var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;\n\t          var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n\t          var lWordArray = new Array(lNumberOfWords - 1);\n\t          var lBytePosition = 0;\n\t          var lByteCount = 0;\n\t          while (lByteCount < lMessageLength) {\n\t            lWordCount = (lByteCount - lByteCount % 4) / 4;\n\t            lBytePosition = lByteCount % 4 * 8;\n\t            lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition;\n\t            lByteCount++;\n\t          }\n\t          lWordCount = (lByteCount - lByteCount % 4) / 4;\n\t          lBytePosition = lByteCount % 4 * 8;\n\t          lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition;\n\t          lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n\t          lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n\t          return lWordArray;\n\t        };\n\t        var wordToHex = function(lValue) {\n\t          var wordToHexValue = \"\", wordToHexValue_temp = \"\", lByte, lCount;\n\t          for (lCount = 0; lCount <= 3; lCount++) {\n\t            lByte = lValue >>> lCount * 8 & 255;\n\t            wordToHexValue_temp = \"0\" + lByte.toString(16);\n\t            wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);\n\t          }\n\t          return wordToHexValue;\n\t        };\n\t        var x = [], k, AA, BB, CC, DD, a, b, c, d, S11 = 7, S12 = 12, S13 = 17, S14 = 22, S21 = 5, S22 = 9, S23 = 14, S24 = 20, S31 = 4, S32 = 11, S33 = 16, S34 = 23, S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\t        x = convertToWordArray(str);\n\t        a = 1732584193;\n\t        b = 4023233417;\n\t        c = 2562383102;\n\t        d = 271733878;\n\t        xl = x.length;\n\t        for (k = 0; k < xl; k += 16) {\n\t          AA = a;\n\t          BB = b;\n\t          CC = c;\n\t          DD = d;\n\t          a = _FF(a, b, c, d, x[k + 0], S11, 3614090360);\n\t          d = _FF(d, a, b, c, x[k + 1], S12, 3905402710);\n\t          c = _FF(c, d, a, b, x[k + 2], S13, 606105819);\n\t          b = _FF(b, c, d, a, x[k + 3], S14, 3250441966);\n\t          a = _FF(a, b, c, d, x[k + 4], S11, 4118548399);\n\t          d = _FF(d, a, b, c, x[k + 5], S12, 1200080426);\n\t          c = _FF(c, d, a, b, x[k + 6], S13, 2821735955);\n\t          b = _FF(b, c, d, a, x[k + 7], S14, 4249261313);\n\t          a = _FF(a, b, c, d, x[k + 8], S11, 1770035416);\n\t          d = _FF(d, a, b, c, x[k + 9], S12, 2336552879);\n\t          c = _FF(c, d, a, b, x[k + 10], S13, 4294925233);\n\t          b = _FF(b, c, d, a, x[k + 11], S14, 2304563134);\n\t          a = _FF(a, b, c, d, x[k + 12], S11, 1804603682);\n\t          d = _FF(d, a, b, c, x[k + 13], S12, 4254626195);\n\t          c = _FF(c, d, a, b, x[k + 14], S13, 2792965006);\n\t          b = _FF(b, c, d, a, x[k + 15], S14, 1236535329);\n\t          a = _GG(a, b, c, d, x[k + 1], S21, 4129170786);\n\t          d = _GG(d, a, b, c, x[k + 6], S22, 3225465664);\n\t          c = _GG(c, d, a, b, x[k + 11], S23, 643717713);\n\t          b = _GG(b, c, d, a, x[k + 0], S24, 3921069994);\n\t          a = _GG(a, b, c, d, x[k + 5], S21, 3593408605);\n\t          d = _GG(d, a, b, c, x[k + 10], S22, 38016083);\n\t          c = _GG(c, d, a, b, x[k + 15], S23, 3634488961);\n\t          b = _GG(b, c, d, a, x[k + 4], S24, 3889429448);\n\t          a = _GG(a, b, c, d, x[k + 9], S21, 568446438);\n\t          d = _GG(d, a, b, c, x[k + 14], S22, 3275163606);\n\t          c = _GG(c, d, a, b, x[k + 3], S23, 4107603335);\n\t          b = _GG(b, c, d, a, x[k + 8], S24, 1163531501);\n\t          a = _GG(a, b, c, d, x[k + 13], S21, 2850285829);\n\t          d = _GG(d, a, b, c, x[k + 2], S22, 4243563512);\n\t          c = _GG(c, d, a, b, x[k + 7], S23, 1735328473);\n\t          b = _GG(b, c, d, a, x[k + 12], S24, 2368359562);\n\t          a = _HH(a, b, c, d, x[k + 5], S31, 4294588738);\n\t          d = _HH(d, a, b, c, x[k + 8], S32, 2272392833);\n\t          c = _HH(c, d, a, b, x[k + 11], S33, 1839030562);\n\t          b = _HH(b, c, d, a, x[k + 14], S34, 4259657740);\n\t          a = _HH(a, b, c, d, x[k + 1], S31, 2763975236);\n\t          d = _HH(d, a, b, c, x[k + 4], S32, 1272893353);\n\t          c = _HH(c, d, a, b, x[k + 7], S33, 4139469664);\n\t          b = _HH(b, c, d, a, x[k + 10], S34, 3200236656);\n\t          a = _HH(a, b, c, d, x[k + 13], S31, 681279174);\n\t          d = _HH(d, a, b, c, x[k + 0], S32, 3936430074);\n\t          c = _HH(c, d, a, b, x[k + 3], S33, 3572445317);\n\t          b = _HH(b, c, d, a, x[k + 6], S34, 76029189);\n\t          a = _HH(a, b, c, d, x[k + 9], S31, 3654602809);\n\t          d = _HH(d, a, b, c, x[k + 12], S32, 3873151461);\n\t          c = _HH(c, d, a, b, x[k + 15], S33, 530742520);\n\t          b = _HH(b, c, d, a, x[k + 2], S34, 3299628645);\n\t          a = _II(a, b, c, d, x[k + 0], S41, 4096336452);\n\t          d = _II(d, a, b, c, x[k + 7], S42, 1126891415);\n\t          c = _II(c, d, a, b, x[k + 14], S43, 2878612391);\n\t          b = _II(b, c, d, a, x[k + 5], S44, 4237533241);\n\t          a = _II(a, b, c, d, x[k + 12], S41, 1700485571);\n\t          d = _II(d, a, b, c, x[k + 3], S42, 2399980690);\n\t          c = _II(c, d, a, b, x[k + 10], S43, 4293915773);\n\t          b = _II(b, c, d, a, x[k + 1], S44, 2240044497);\n\t          a = _II(a, b, c, d, x[k + 8], S41, 1873313359);\n\t          d = _II(d, a, b, c, x[k + 15], S42, 4264355552);\n\t          c = _II(c, d, a, b, x[k + 6], S43, 2734768916);\n\t          b = _II(b, c, d, a, x[k + 13], S44, 1309151649);\n\t          a = _II(a, b, c, d, x[k + 4], S41, 4149444226);\n\t          d = _II(d, a, b, c, x[k + 11], S42, 3174756917);\n\t          c = _II(c, d, a, b, x[k + 2], S43, 718787259);\n\t          b = _II(b, c, d, a, x[k + 9], S44, 3951481745);\n\t          a = addUnsigned(a, AA);\n\t          b = addUnsigned(b, BB);\n\t          c = addUnsigned(c, CC);\n\t          d = addUnsigned(d, DD);\n\t        }\n\t        var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n\t        return temp.toLowerCase();\n\t      }\n\t    };\n\t    return md5;\n\t  } ]);\n\t})(angular);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.6\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\tvar $resourceMinErr = angular.$$minErr('$resource');\n\t\n\t// Helper functions and regex to lookup a dotted path on an object\n\t// stopping at undefined/null.  The path must be composed of ASCII\n\t// identifiers (just like $parse)\n\tvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\t\n\tfunction isValidDottedPath(path) {\n\t  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n\t      MEMBER_NAME_REGEX.test('.' + path));\n\t}\n\t\n\tfunction lookupDottedPath(obj, path) {\n\t  if (!isValidDottedPath(path)) {\n\t    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n\t  }\n\t  var keys = path.split('.');\n\t  for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {\n\t    var key = keys[i];\n\t    obj = (obj !== null) ? obj[key] : undefined;\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Create a shallow copy of an object and clear other fields from the destination\n\t */\n\tfunction shallowClearAndCopy(src, dst) {\n\t  dst = dst || {};\n\t\n\t  angular.forEach(dst, function(value, key) {\n\t    delete dst[key];\n\t  });\n\t\n\t  for (var key in src) {\n\t    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n\t      dst[key] = src[key];\n\t    }\n\t  }\n\t\n\t  return dst;\n\t}\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngResource\n\t * @description\n\t *\n\t * # ngResource\n\t *\n\t * The `ngResource` module provides interaction support with RESTful services\n\t * via the $resource service.\n\t *\n\t *\n\t * <div doc-module-components=\"ngResource\"></div>\n\t *\n\t * See {@link ngResource.$resource `$resource`} for usage.\n\t */\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $resource\n\t * @requires $http\n\t * @requires ng.$log\n\t * @requires $q\n\t * @requires ng.$timeout\n\t *\n\t * @description\n\t * A factory which creates a resource object that lets you interact with\n\t * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n\t *\n\t * The returned resource object has action methods which provide high-level behaviors without\n\t * the need to interact with the low level {@link ng.$http $http} service.\n\t *\n\t * Requires the {@link ngResource `ngResource`} module to be installed.\n\t *\n\t * By default, trailing slashes will be stripped from the calculated URLs,\n\t * which can pose problems with server backends that do not expect that\n\t * behavior.  This can be disabled by configuring the `$resourceProvider` like\n\t * this:\n\t *\n\t * ```js\n\t     app.config(['$resourceProvider', function($resourceProvider) {\n\t       // Don't strip trailing slashes from calculated URLs\n\t       $resourceProvider.defaults.stripTrailingSlashes = false;\n\t     }]);\n\t * ```\n\t *\n\t * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n\t *   `/user/:username`. If you are using a URL with a port number (e.g.\n\t *   `http://example.com:8080/api`), it will be respected.\n\t *\n\t *   If you are using a url with a suffix, just add the suffix, like this:\n\t *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n\t *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n\t *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n\t *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n\t *   can escape it with `/\\.`.\n\t *\n\t * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n\t *   `actions` methods. If a parameter value is a function, it will be executed every time\n\t *   when a param value needs to be obtained for a request (unless the param was overridden).\n\t *\n\t *   Each key value in the parameter object is first bound to url template if present and then any\n\t *   excess keys are appended to the url search query after the `?`.\n\t *\n\t *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n\t *   URL `/path/greet?salutation=Hello`.\n\t *\n\t *   If the parameter value is prefixed with `@` then the value for that parameter will be extracted\n\t *   from the corresponding property on the `data` object (provided when calling an action method).\n\t *   For example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of\n\t *   `someParam` will be `data.someProp`.\n\t *\n\t * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n\t *   the default set of resource actions. The declaration should be created in the format of {@link\n\t *   ng.$http#usage $http.config}:\n\t *\n\t *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n\t *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n\t *        ...}\n\t *\n\t *   Where:\n\t *\n\t *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n\t *     your resource object.\n\t *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n\t *     `DELETE`, `JSONP`, etc).\n\t *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n\t *     the parameter value is a function, it will be executed every time when a param value needs to\n\t *     be obtained for a request (unless the param was overridden).\n\t *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n\t *     like for the resource-level urls.\n\t *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n\t *     see `returns` section.\n\t *   - **`transformRequest`** –\n\t *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n\t *     transform function or an array of such functions. The transform function takes the http\n\t *     request body and headers and returns its transformed (typically serialized) version.\n\t *     By default, transformRequest will contain one function that checks if the request data is\n\t *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n\t *     `transformRequest` to an empty array: `transformRequest: []`\n\t *   - **`transformResponse`** –\n\t *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n\t *     transform function or an array of such functions. The transform function takes the http\n\t *     response body and headers and returns its transformed (typically deserialized) version.\n\t *     By default, transformResponse will contain one function that checks if the response looks\n\t *     like a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior,\n\t *     set `transformResponse` to an empty array: `transformResponse: []`\n\t *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n\t *     GET request, otherwise if a cache instance built with\n\t *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n\t *     caching.\n\t *   - **`timeout`** – `{number}` – timeout in milliseconds.<br />\n\t *     **Note:** In contrast to {@link ng.$http#usage $http.config}, {@link ng.$q promises} are\n\t *     **not** supported in $resource, because the same value would be used for multiple requests.\n\t *     If you are looking for a way to cancel requests, you should use the `cancellable` option.\n\t *   - **`cancellable`** – `{boolean}` – if set to true, the request made by a \"non-instance\" call\n\t *     will be cancelled (if not already completed) by calling `$cancelRequest()` on the call's\n\t *     return value. Calling `$cancelRequest()` for a non-cancellable or an already\n\t *     completed/cancelled request will have no effect.<br />\n\t *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n\t *     XHR object. See\n\t *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n\t *     for more information.\n\t *   - **`responseType`** - `{string}` - see\n\t *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n\t *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n\t *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n\t *     with `http response` object. See {@link ng.$http $http interceptors}.\n\t *\n\t * @param {Object} options Hash with custom settings that should extend the\n\t *   default `$resourceProvider` behavior.  The supported options are:\n\t *\n\t *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n\t *   slashes from any calculated URL will be stripped. (Defaults to true.)\n\t *   - **`cancellable`** – {boolean} – If true, the request made by a \"non-instance\" call will be\n\t *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return value.\n\t *   This can be overwritten per action. (Defaults to false.)\n\t *\n\t * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n\t *   optionally extended with custom `actions`. The default set contains these actions:\n\t *   ```js\n\t *   { 'get':    {method:'GET'},\n\t *     'save':   {method:'POST'},\n\t *     'query':  {method:'GET', isArray:true},\n\t *     'remove': {method:'DELETE'},\n\t *     'delete': {method:'DELETE'} };\n\t *   ```\n\t *\n\t *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n\t *   destination and parameters. When the data is returned from the server then the object is an\n\t *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n\t *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n\t *   read, update, delete) on server-side data like this:\n\t *   ```js\n\t *   var User = $resource('/user/:userId', {userId:'@id'});\n\t *   var user = User.get({userId:123}, function() {\n\t *     user.abc = true;\n\t *     user.$save();\n\t *   });\n\t *   ```\n\t *\n\t *   It is important to realize that invoking a $resource object method immediately returns an\n\t *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n\t *   server the existing reference is populated with the actual data. This is a useful trick since\n\t *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n\t *   object results in no rendering, once the data arrives from the server then the object is\n\t *   populated with the data and the view automatically re-renders itself showing the new data. This\n\t *   means that in most cases one never has to write a callback function for the action methods.\n\t *\n\t *   The action methods on the class object or instance object can be invoked with the following\n\t *   parameters:\n\t *\n\t *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n\t *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n\t *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n\t *\n\t *\n\t *   Success callback is called with (value, responseHeaders) arguments, where the value is\n\t *   the populated resource instance or collection object. The error callback is called\n\t *   with (httpResponse) argument.\n\t *\n\t *   Class actions return empty instance (with additional properties below).\n\t *   Instance actions return promise of the action.\n\t *\n\t *   The Resource instances and collections have these additional properties:\n\t *\n\t *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n\t *     instance or collection.\n\t *\n\t *     On success, the promise is resolved with the same resource instance or collection object,\n\t *     updated with data from server. This makes it easy to use in\n\t *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n\t *     rendering until the resource(s) are loaded.\n\t *\n\t *     On failure, the promise is rejected with the {@link ng.$http http response} object, without\n\t *     the `resource` property.\n\t *\n\t *     If an interceptor object was provided, the promise will instead be resolved with the value\n\t *     returned by the interceptor.\n\t *\n\t *   - `$resolved`: `true` after first server interaction is completed (either with success or\n\t *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n\t *      data-binding.\n\t *\n\t *   The Resource instances and collections have these additional methods:\n\t *\n\t *   - `$cancelRequest`: If there is a cancellable, pending request related to the instance or\n\t *      collection, calling this method will abort the request.\n\t *\n\t * @example\n\t *\n\t * # Credit card resource\n\t *\n\t * ```js\n\t     // Define CreditCard class\n\t     var CreditCard = $resource('/user/:userId/card/:cardId',\n\t      {userId:123, cardId:'@id'}, {\n\t       charge: {method:'POST', params:{charge:true}}\n\t      });\n\t\n\t     // We can retrieve a collection from the server\n\t     var cards = CreditCard.query(function() {\n\t       // GET: /user/123/card\n\t       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\t\n\t       var card = cards[0];\n\t       // each item is an instance of CreditCard\n\t       expect(card instanceof CreditCard).toEqual(true);\n\t       card.name = \"J. Smith\";\n\t       // non GET methods are mapped onto the instances\n\t       card.$save();\n\t       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n\t       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\t\n\t       // our custom method is mapped as well.\n\t       card.$charge({amount:9.99});\n\t       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n\t     });\n\t\n\t     // we can create an instance as well\n\t     var newCard = new CreditCard({number:'0123'});\n\t     newCard.name = \"Mike Smith\";\n\t     newCard.$save();\n\t     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n\t     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n\t     expect(newCard.id).toEqual(789);\n\t * ```\n\t *\n\t * The object returned from this function execution is a resource \"class\" which has \"static\" method\n\t * for each action in the definition.\n\t *\n\t * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n\t * `headers`.\n\t *\n\t * @example\n\t *\n\t * # User resource\n\t *\n\t * When the data is returned from the server then the object is an instance of the resource type and\n\t * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n\t * operations (create, read, update, delete) on server-side data.\n\t\n\t   ```js\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123}, function(user) {\n\t       user.abc = true;\n\t       user.$save();\n\t     });\n\t   ```\n\t *\n\t * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n\t * in the response that came from the server as well as $http header getter function, so one\n\t * could rewrite the above example and get access to http headers as:\n\t *\n\t   ```js\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123}, function(user, getResponseHeaders){\n\t       user.abc = true;\n\t       user.$save(function(user, putResponseHeaders) {\n\t         //user => saved user object\n\t         //putResponseHeaders => $http header getter\n\t       });\n\t     });\n\t   ```\n\t *\n\t * You can also access the raw `$http` promise via the `$promise` property on the object returned\n\t *\n\t   ```\n\t     var User = $resource('/user/:userId', {userId:'@id'});\n\t     User.get({userId:123})\n\t         .$promise.then(function(user) {\n\t           $scope.user = user;\n\t         });\n\t   ```\n\t *\n\t * @example\n\t *\n\t * # Creating a custom 'PUT' request\n\t *\n\t * In this example we create a custom method on our resource to make a PUT request\n\t * ```js\n\t *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n\t *\n\t *    // Some APIs expect a PUT request in the format URL/object/ID\n\t *    // Here we are creating an 'update' method\n\t *    app.factory('Notes', ['$resource', function($resource) {\n\t *    return $resource('/notes/:id', null,\n\t *        {\n\t *            'update': { method:'PUT' }\n\t *        });\n\t *    }]);\n\t *\n\t *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n\t *    // We pass in $routeParams and our Notes factory along with $scope\n\t *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n\t                                      function($scope, $routeParams, Notes) {\n\t *    // First get a note object from the factory\n\t *    var note = Notes.get({ id:$routeParams.id });\n\t *    $id = note.id;\n\t *\n\t *    // Now call update passing in the ID first then the object you are updating\n\t *    Notes.update({ id:$id }, note);\n\t *\n\t *    // This will PUT /notes/ID with the note object in the request payload\n\t *    }]);\n\t * ```\n\t *\n\t * @example\n\t *\n\t * # Cancelling requests\n\t *\n\t * If an action's configuration specifies that it is cancellable, you can cancel the request related\n\t * to an instance or collection (as long as it is a result of a \"non-instance\" call):\n\t *\n\t   ```js\n\t     // ...defining the `Hotel` resource...\n\t     var Hotel = $resource('/api/hotel/:id', {id: '@id'}, {\n\t       // Let's make the `query()` method cancellable\n\t       query: {method: 'get', isArray: true, cancellable: true}\n\t     });\n\t\n\t     // ...somewhere in the PlanVacationController...\n\t     ...\n\t     this.onDestinationChanged = function onDestinationChanged(destination) {\n\t       // We don't care about any pending request for hotels\n\t       // in a different destination any more\n\t       this.availableHotels.$cancelRequest();\n\t\n\t       // Let's query for hotels in '<destination>'\n\t       // (calls: /api/hotel?location=<destination>)\n\t       this.availableHotels = Hotel.query({location: destination});\n\t     };\n\t   ```\n\t *\n\t */\n\tangular.module('ngResource', ['ng']).\n\t  provider('$resource', function() {\n\t    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\\/\\/[^\\/]*/;\n\t    var provider = this;\n\t\n\t    this.defaults = {\n\t      // Strip slashes by default\n\t      stripTrailingSlashes: true,\n\t\n\t      // Default actions configuration\n\t      actions: {\n\t        'get': {method: 'GET'},\n\t        'save': {method: 'POST'},\n\t        'query': {method: 'GET', isArray: true},\n\t        'remove': {method: 'DELETE'},\n\t        'delete': {method: 'DELETE'}\n\t      }\n\t    };\n\t\n\t    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {\n\t\n\t      var noop = angular.noop,\n\t        forEach = angular.forEach,\n\t        extend = angular.extend,\n\t        copy = angular.copy,\n\t        isFunction = angular.isFunction;\n\t\n\t      /**\n\t       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n\t       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n\t       * (pchar) allowed in path segments:\n\t       *    segment       = *pchar\n\t       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n\t       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t       */\n\t      function encodeUriSegment(val) {\n\t        return encodeUriQuery(val, true).\n\t          replace(/%26/gi, '&').\n\t          replace(/%3D/gi, '=').\n\t          replace(/%2B/gi, '+');\n\t      }\n\t\n\t\n\t      /**\n\t       * This method is intended for encoding *key* or *value* parts of query component. We need a\n\t       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n\t       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n\t       *    query       = *( pchar / \"/\" / \"?\" )\n\t       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n\t       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t       */\n\t      function encodeUriQuery(val, pctEncodeSpaces) {\n\t        return encodeURIComponent(val).\n\t          replace(/%40/gi, '@').\n\t          replace(/%3A/gi, ':').\n\t          replace(/%24/g, '$').\n\t          replace(/%2C/gi, ',').\n\t          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n\t      }\n\t\n\t      function Route(template, defaults) {\n\t        this.template = template;\n\t        this.defaults = extend({}, provider.defaults, defaults);\n\t        this.urlParams = {};\n\t      }\n\t\n\t      Route.prototype = {\n\t        setUrlParams: function(config, params, actionUrl) {\n\t          var self = this,\n\t            url = actionUrl || self.template,\n\t            val,\n\t            encodedVal,\n\t            protocolAndDomain = '';\n\t\n\t          var urlParams = self.urlParams = {};\n\t          forEach(url.split(/\\W/), function(param) {\n\t            if (param === 'hasOwnProperty') {\n\t              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n\t            }\n\t            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n\t              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n\t              urlParams[param] = {\n\t                isQueryParamValue: (new RegExp(\"\\\\?.*=:\" + param + \"(?:\\\\W|$)\")).test(url)\n\t              };\n\t            }\n\t          });\n\t          url = url.replace(/\\\\:/g, ':');\n\t          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {\n\t            protocolAndDomain = match;\n\t            return '';\n\t          });\n\t\n\t          params = params || {};\n\t          forEach(self.urlParams, function(paramInfo, urlParam) {\n\t            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n\t            if (angular.isDefined(val) && val !== null) {\n\t              if (paramInfo.isQueryParamValue) {\n\t                encodedVal = encodeUriQuery(val, true);\n\t              } else {\n\t                encodedVal = encodeUriSegment(val);\n\t              }\n\t              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n\t                return encodedVal + p1;\n\t              });\n\t            } else {\n\t              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n\t                  leadingSlashes, tail) {\n\t                if (tail.charAt(0) == '/') {\n\t                  return tail;\n\t                } else {\n\t                  return leadingSlashes + tail;\n\t                }\n\t              });\n\t            }\n\t          });\n\t\n\t          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n\t          if (self.defaults.stripTrailingSlashes) {\n\t            url = url.replace(/\\/+$/, '') || '/';\n\t          }\n\t\n\t          // then replace collapse `/.` if found in the last URL path segment before the query\n\t          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n\t          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n\t          // replace escaped `/\\.` with `/.`\n\t          config.url = protocolAndDomain + url.replace(/\\/\\\\\\./, '/.');\n\t\n\t\n\t          // set params - delegate param encoding to $http\n\t          forEach(params, function(value, key) {\n\t            if (!self.urlParams[key]) {\n\t              config.params = config.params || {};\n\t              config.params[key] = value;\n\t            }\n\t          });\n\t        }\n\t      };\n\t\n\t\n\t      function resourceFactory(url, paramDefaults, actions, options) {\n\t        var route = new Route(url, options);\n\t\n\t        actions = extend({}, provider.defaults.actions, actions);\n\t\n\t        function extractParams(data, actionParams) {\n\t          var ids = {};\n\t          actionParams = extend({}, paramDefaults, actionParams);\n\t          forEach(actionParams, function(value, key) {\n\t            if (isFunction(value)) { value = value(); }\n\t            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n\t              lookupDottedPath(data, value.substr(1)) : value;\n\t          });\n\t          return ids;\n\t        }\n\t\n\t        function defaultResponseInterceptor(response) {\n\t          return response.resource;\n\t        }\n\t\n\t        function Resource(value) {\n\t          shallowClearAndCopy(value || {}, this);\n\t        }\n\t\n\t        Resource.prototype.toJSON = function() {\n\t          var data = extend({}, this);\n\t          delete data.$promise;\n\t          delete data.$resolved;\n\t          return data;\n\t        };\n\t\n\t        forEach(actions, function(action, name) {\n\t          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n\t          var numericTimeout = action.timeout;\n\t          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :\n\t              (options && angular.isDefined(options.cancellable)) ? options.cancellable :\n\t              provider.defaults.cancellable;\n\t\n\t          if (numericTimeout && !angular.isNumber(numericTimeout)) {\n\t            $log.debug('ngResource:\\n' +\n\t                       '  Only numeric values are allowed as `timeout`.\\n' +\n\t                       '  Promises are not supported in $resource, because the same value would ' +\n\t                       'be used for multiple requests. If you are looking for a way to cancel ' +\n\t                       'requests, you should use the `cancellable` option.');\n\t            delete action.timeout;\n\t            numericTimeout = null;\n\t          }\n\t\n\t          Resource[name] = function(a1, a2, a3, a4) {\n\t            var params = {}, data, success, error;\n\t\n\t            /* jshint -W086 */ /* (purposefully fall through case statements) */\n\t            switch (arguments.length) {\n\t              case 4:\n\t                error = a4;\n\t                success = a3;\n\t              //fallthrough\n\t              case 3:\n\t              case 2:\n\t                if (isFunction(a2)) {\n\t                  if (isFunction(a1)) {\n\t                    success = a1;\n\t                    error = a2;\n\t                    break;\n\t                  }\n\t\n\t                  success = a2;\n\t                  error = a3;\n\t                  //fallthrough\n\t                } else {\n\t                  params = a1;\n\t                  data = a2;\n\t                  success = a3;\n\t                  break;\n\t                }\n\t              case 1:\n\t                if (isFunction(a1)) success = a1;\n\t                else if (hasBody) data = a1;\n\t                else params = a1;\n\t                break;\n\t              case 0: break;\n\t              default:\n\t                throw $resourceMinErr('badargs',\n\t                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n\t                  arguments.length);\n\t            }\n\t            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\t\n\t            var isInstanceCall = this instanceof Resource;\n\t            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n\t            var httpConfig = {};\n\t            var responseInterceptor = action.interceptor && action.interceptor.response ||\n\t              defaultResponseInterceptor;\n\t            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n\t              undefined;\n\t            var timeoutDeferred;\n\t            var numericTimeoutPromise;\n\t\n\t            forEach(action, function(value, key) {\n\t              switch (key) {\n\t                default:\n\t                  httpConfig[key] = copy(value);\n\t                  break;\n\t                case 'params':\n\t                case 'isArray':\n\t                case 'interceptor':\n\t                case 'cancellable':\n\t                  break;\n\t              }\n\t            });\n\t\n\t            if (!isInstanceCall && cancellable) {\n\t              timeoutDeferred = $q.defer();\n\t              httpConfig.timeout = timeoutDeferred.promise;\n\t\n\t              if (numericTimeout) {\n\t                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);\n\t              }\n\t            }\n\t\n\t            if (hasBody) httpConfig.data = data;\n\t            route.setUrlParams(httpConfig,\n\t              extend({}, extractParams(data, action.params || {}), params),\n\t              action.url);\n\t\n\t            var promise = $http(httpConfig).then(function(response) {\n\t              var data = response.data;\n\t\n\t              if (data) {\n\t                // Need to convert action.isArray to boolean in case it is undefined\n\t                // jshint -W018\n\t                if (angular.isArray(data) !== (!!action.isArray)) {\n\t                  throw $resourceMinErr('badcfg',\n\t                      'Error in resource configuration for action `{0}`. Expected response to ' +\n\t                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n\t                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n\t                }\n\t                // jshint +W018\n\t                if (action.isArray) {\n\t                  value.length = 0;\n\t                  forEach(data, function(item) {\n\t                    if (typeof item === \"object\") {\n\t                      value.push(new Resource(item));\n\t                    } else {\n\t                      // Valid JSON values may be string literals, and these should not be converted\n\t                      // into objects. These items will not have access to the Resource prototype\n\t                      // methods, but unfortunately there\n\t                      value.push(item);\n\t                    }\n\t                  });\n\t                } else {\n\t                  var promise = value.$promise;     // Save the promise\n\t                  shallowClearAndCopy(data, value);\n\t                  value.$promise = promise;         // Restore the promise\n\t                }\n\t              }\n\t              response.resource = value;\n\t\n\t              return response;\n\t            }, function(response) {\n\t              (error || noop)(response);\n\t              return $q.reject(response);\n\t            });\n\t\n\t            promise['finally'](function() {\n\t              value.$resolved = true;\n\t              if (!isInstanceCall && cancellable) {\n\t                value.$cancelRequest = angular.noop;\n\t                $timeout.cancel(numericTimeoutPromise);\n\t                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;\n\t              }\n\t            });\n\t\n\t            promise = promise.then(\n\t              function(response) {\n\t                var value = responseInterceptor(response);\n\t                (success || noop)(value, response.headers);\n\t                return value;\n\t              },\n\t              responseErrorInterceptor);\n\t\n\t            if (!isInstanceCall) {\n\t              // we are creating instance / collection\n\t              // - set the initial promise\n\t              // - return the instance / collection\n\t              value.$promise = promise;\n\t              value.$resolved = false;\n\t              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;\n\t\n\t              return value;\n\t            }\n\t\n\t            // instance call\n\t            return promise;\n\t          };\n\t\n\t\n\t          Resource.prototype['$' + name] = function(params, success, error) {\n\t            if (isFunction(params)) {\n\t              error = success; success = params; params = {};\n\t            }\n\t            var result = Resource[name].call(this, params, this, success, error);\n\t            return result.$promise || result;\n\t          };\n\t        });\n\t\n\t        Resource.bind = function(additionalParamDefaults) {\n\t          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n\t        };\n\t\n\t        return Resource;\n\t      }\n\t\n\t      return resourceFactory;\n\t    }];\n\t  });\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(6);\n\tmodule.exports = 'ngResource';\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.3.0\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy,\n\t    toJson = angular.toJson;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i] || !parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:\n\t        result = result.replace(/\\/$/, '');\n\t        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t      break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t\n\t    if (regexp) {\n\t      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    }\n\t\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  var param, paramVal;\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    param = this.params[paramName];\n\t    paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t    param = this.params[paramName];\n\t    paramVal = searchParams[paramName];\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validates\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      var isFinalPathParam = i + 1 === nPath;\n\t\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t\n\t      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      if (encoded.length === 0) continue;\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        if (isArray(val) && val.length === 0) return val;\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  // Use tildes to pre-encode slashes.\n\t  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t  // and bidirectional encoding/decoding fails.\n\t  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\t  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    \"string\": {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    \"int\": {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    \"bool\": {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    \"date\": {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    \"json\": {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    \"any\": { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t\n\t      if (angular.isString(config.type))\n\t        return $types[config.type];\n\t      if (config.type instanceof Type)\n\t        return config.type;\n\t      return new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {function} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|function} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. \n\t   * \n\t   * If the handler is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|function} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t\n\t        isHtml5 = isHtml5 && $sniffer.history;\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = inherit(state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. Only parameters specified in the state definition can be overridden, new \n\t     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n\t     *    have changed.  It will reload the resolves and views of the current state and parent states.\n\t     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n\t     *    the transition reloads the resolves and views for that matched state, and all its children states.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t      \n\t      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n\t      if (hash) toParams['#'] = hash;\n\t      \n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n\t          if ($state.transition == null) $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            result.$$resolveAs = view.resolveAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .factory('$stateParams', function () { return {}; })\n\t  .constant(\"$state.runtime\", { autoinject: true })\n\t  .provider('$state', $StateProvider)\n\t  // Inject $state to initialize when entering runtime. #2574\n\t  .run(['$injector', function ($injector) {\n\t    // Allow tests (stateSpec.js) to turn this off by defining this constant\n\t    if ($injector.get(\"$state.runtime\").autoinject) {\n\t      $injector.get('$state');\n\t    }\n\t  }]);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t *\n\t * @example\n\t * A view can be unnamed or named.\n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div>\n\t *\n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a\n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div>\n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t *\n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * But typically you'll only use the views property if you name your view or have more than one view\n\t * in the same template. There's not really a compelling reason to name a view if its the only one,\n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre>\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div>\n\t * <div ui-view=\"data\"></div>\n\t * </pre>\n\t *\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t *\n\t * Resolve data:\n\t *\n\t * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n\t * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n\t *\n\t * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n\t * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n\t * depends on `$resolve` data.\n\t *\n\t * Example usage of $resolve in a view template\n\t * <pre>\n\t * $stateProvider.state('home', {\n\t *   template: '<my-component user=\"$resolve.user\"></my-component>',\n\t *   resolve: {\n\t *     user: function(UserService) { return UserService.fetchUser(); }\n\t *   }\n\t * });\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          if (angular.version.minor > 2) {\n\t            $animate.enter(element, null, target).then(cb);\n\t          } else {\n\t            $animate.enter(element, null, target, cb);\n\t          }\n\t        },\n\t        leave: function(element, cb) {\n\t          if (angular.version.minor > 2) {\n\t            $animate.leave(element).then(cb);\n\t          } else {\n\t            $animate.leave(element, cb);\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope),\n\t            inherited     = $element.inheritedData('$uiView');\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            var $uiViewData = currentEl.data('$uiView');\n\t            renderer.leave(currentEl, function() {\n\t              $uiViewData.$$animLeave.resolve();\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, inherited, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoading\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           *\n\t           * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          newScope.$emit('$viewContentLoading', name);\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            var animEnter = $q.defer(), animLeave = $q.defer();\n\t            var viewData = {\n\t              name: name,\n\t              $animEnter: animEnter.promise,\n\t              $animLeave: animLeave.promise,\n\t              $$animLeave: animLeave\n\t            };\n\t\n\t            renderer.enter(clone.data('$uiView', viewData), $element, function onUiViewEnter() {\n\t              animEnter.resolve();\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded', name);\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            $uiViewData = $element.data('$uiView'),\n\t            locals  = current && current.locals[$uiViewData.name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        extend($uiViewData, { state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var resolveData = angular.extend({}, locals);\n\t        scope[locals.$$resolveAs] = resolveData;\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n\t          }\n\t          if (isFunction(controller.$onInit)) controller.$onInit();\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, inherited, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\tfunction getTypeInfo(el) {\n\t  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t  var isForm = el[0].nodeName === \"FORM\";\n\t\n\t  return {\n\t    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t    clickable: !isForm\n\t  };\n\t}\n\t\n\tfunction clickHook(el, $state, $timeout, type, current) {\n\t  return function(e) {\n\t    var button = e.which || e.button, target = current();\n\t\n\t    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t      var transition = $timeout(function() {\n\t        $state.go(target.state, target.params, target.options);\n\t      });\n\t      e.preventDefault();\n\t\n\t      // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\t\n\t      e.preventDefault = function() {\n\t        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\tfunction defaultOpts(el, $state) {\n\t  return { relative: stateContext(el) || $state.$current, inherit: true };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t * URL, the directive will automatically generate & update the `href` attribute via\n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t * the link will trigger a state transition with optional parameters.\n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative\n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the\n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var def    = { state: ref.state, href: null, params: null };\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var unlinkInfoFn = null;\n\t      var hookFn;\n\t\n\t      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t\n\t      var update = function(val) {\n\t        if (val) def.params = angular.copy(val);\n\t        def.href = $state.href(ref.state, def.params, def.options);\n\t\n\t        if (unlinkInfoFn) unlinkInfoFn();\n\t        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n\t        if (def.href !== null) attrs.$set(type.attr, def.href);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n\t        def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (!type.clickable) return;\n\t      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n\t      element.bind(\"click\", hookFn);\n\t      scope.$on('$destroy', function() {\n\t        element.unbind(\"click\", hookFn);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-state\n\t *\n\t * @requires ui.router.state.uiSref\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t * params and override options.\n\t *\n\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n\t * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n\t */\n\t$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDynamicDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n\t      var def    = { state: null, params: null, options: null, href: null };\n\t      var unlinkInfoFn = null;\n\t      var hookFn;\n\t\n\t      function runStateRefLink (group) {\n\t        def.state = group[0]; def.params = group[1]; def.options = group[2];\n\t        def.href = $state.href(def.state, def.params, def.options);\n\t\n\t        if (unlinkInfoFn) unlinkInfoFn();\n\t        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n\t        if (def.href) attrs.$set(type.attr, def.href);\n\t      }\n\t\n\t      scope.$watch(watch, runStateRefLink, true);\n\t      runStateRefLink(scope.$eval(watch));\n\t\n\t      if (!type.clickable) return;\n\t      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n\t      element.bind(\"click\", hookFn);\n\t      scope.$on('$destroy', function() {\n\t        element.unbind(\"click\", hookFn);\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t * to an object hash, whose keys represent active class names and whose\n\t * values represent the respective state names/globs.\n\t * ui-sref-active will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * @Example\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * <pre>\n\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * </pre>\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t * to both the <div> and <a> elements. It is important to note that the state\n\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t\n\t      try {\n\t        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t      } catch (e) {\n\t        // Do nothing. uiSrefActive is not a valid expression.\n\t        // Fall back to using $interpolate below\n\t      }\n\t      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t      if (isObject(uiSrefActive)) {\n\t        forEach(uiSrefActive, function(stateOrName, activeClass) {\n\t          if (isString(stateOrName)) {\n\t            var ref = parseStateRef(stateOrName, $state.current.name);\n\t            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t          }\n\t        });\n\t      }\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        // we already got an explicit state provided by ui-sref-active, so we\n\t        // shadow the one that comes from ui-sref\n\t        if (isObject(uiSrefActive) && states.length > 0) {\n\t          return;\n\t        }\n\t        var deregister = addState(newState, newParams, uiSrefActive);\n\t        update();\n\t        return deregister;\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      function addState(stateName, stateParams, activeClass) {\n\t        var state = $state.get(stateName, stateContext($element));\n\t        var stateHash = createStateHash(stateName, stateParams);\n\t\n\t        var stateInfo = {\n\t          state: state || { name: stateName },\n\t          params: stateParams,\n\t          hash: stateHash\n\t        };\n\t\n\t        states.push(stateInfo);\n\t        activeClasses[stateHash] = activeClass;\n\t\n\t        return function removeState() {\n\t          var idx = states.indexOf(stateInfo);\n\t          if (idx !== -1) states.splice(idx, 1);\n\t        };\n\t      }\n\t\n\t      /**\n\t       * @param {string} state\n\t       * @param {Object|string} [params]\n\t       * @return {string}\n\t       */\n\t      function createStateHash(state, params) {\n\t        if (!isString(state)) {\n\t          throw new Error('state should be a string');\n\t        }\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        params = $scope.$eval(params);\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        return state;\n\t      }\n\t\n\t      // Update route state\n\t      function update() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (anyMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeClasses[states[i].hash]);\n\t          } else {\n\t            removeClass($element, activeClasses[states[i].hash]);\n\t          }\n\t\n\t          if (exactMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeEqClass);\n\t          } else {\n\t            removeClass($element, activeEqClass);\n\t          }\n\t        }\n\t      }\n\t\n\t      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t      function removeClass(el, className) { el.removeClass(className); }\n\t      function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t      function exactMatch(state, params) { return $state.is(state.name, params); }\n\t\n\t      update();\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n\t  .directive('uiState', $StateRefDynamicDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state, params) {\n\t    return $state.is(state, params);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state, params, options) {\n\t    return $state.includes(state, params, options);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n/* 9 */,\n/* 10 */,\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(14);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * todo todo的一些controller\n\t */\n\t_app2.default.controller(\"todoController\", [\"$scope\", \"$window\", \"todoTools\", \"todoModel\", \"$state\", \"$stateParams\", \"todo-consts\", function ($scope, $window, todoTools, todoModel, $state, $stateParams, todoConsts) {\n\t    // 用户的todo列表\n\t    $scope.todoList = [];\n\t    // 用户的todo列表(\n\t    $scope.filterList = [];\n\t\n\t    // 用户待完成数量\n\t    $scope.todoNum = 0;\n\t\n\t    $scope.title = \"新建\";\n\t\n\t    // 默认的新建todo\n\t    $scope.newTodo = {};\n\t\n\t    // 待完成todo数量\n\t    $scope.unfinishNum = 0;\n\t\n\t    /**\n\t     * 初始化新建todo对象\n\t     */\n\t    $scope.initNewTodo = function () {\n\t        $scope.newTodo = {\n\t            todo_name: todoConsts.DEFAULT_TODONAME,\n\t            userid: todoTools.userInfo.userid() == 0 ? 1 : parseInt(todoTools.userInfo.userid()),\n\t            categoryid: todoConsts.DEFAULT_CATEGORYID,\n\t            status: todoConsts.DEFAULT_TODOSTATUS,\n\t            remark: \"\"\n\t        };\n\t    };\n\t\n\t    // 状态列表\n\t    $scope.todoStatusCateogries = todoConsts.TODO_CATEGORYLIST;\n\t    $scope.currentStatus = todoConsts.TODO_CATEGORYLIST[0].id;\n\t\n\t    // 是否正在载入中\n\t    $scope.loading = true;\n\t\n\t    $scope.stateParams = $stateParams;\n\t\n\t    $scope.validate = {\n\t        msg: \"\",\n\t        error: {\n\t            todo_name: false,\n\t            remark: false,\n\t            start_time: false,\n\t            end_time: false\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 获取todo列表\n\t     */\n\t    $scope.fetchList = function () {\n\t        if (todoTools.userInfo.userid() != 0) {\n\t            todoModel.list(todoTools.userInfo.userid).then(function (data) {\n\t                $scope.loading = false;\n\t                $scope.filterList = $scope.todoList = data.list;\n\t                for (var i = 0, len = $scope.todoList.length; i < len; i++) {\n\t                    if (data.list[i].status != 2) {\n\t                        $scope.unfinishNum += 1;\n\t                    }\n\t                }\n\t            }, function () {\n\t                $scope.loading = false;\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 选择某一个setStatus的状态\n\t     * @param status\n\t     */\n\t    $scope.filterStatusList = function (status) {\n\t        $scope.currentStatus = status;\n\t        $scope.filterList = $scope.todoList.filter(function (item) {\n\t            switch ($scope.currentStatus) {\n\t                case 0:\n\t                    return true;\n\t                case 1:\n\t                    return item.status == 2;\n\t                case 2:\n\t                default:\n\t                    return item.status == 0;\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * 获取详情\n\t     */\n\t    $scope.getDetail = function () {\n\t        if (typeof $stateParams.todoid != 'undefined') {\n\t            $scope.title = \"编辑\";\n\t            todoModel.detail({\n\t                userid: todoTools.userInfo.userid(),\n\t                id: $stateParams.todoid\n\t            }).then(function (data) {\n\t                $scope.newTodo = data;\n\t                if ($scope.newTodo.start_time != 0) {\n\t                    $scope.newTodo.start_time = new Date($scope.newTodo.start_time * 1000);\n\t                }\n\t                if ($scope.newTodo.end_time != 0) {\n\t                    $scope.newTodo.end_time = new Date($scope.newTodo.end_time * 1000);\n\t                }\n\t            }, function (response) {\n\t                var errMsg = \"请求错误\";\n\t                if (_typeof(response.data) == 'object' && typeof response.data.errmsg != 'undefined') {\n\t                    errMsg = response.data.errmsg + \"(错误代码:\" + response.data.errcode + \")\";\n\t                }\n\t                $window.alert(errMsg);\n\t                $state.go(\"todo.list\");\n\t            });\n\t        } else {\n\t            $scope.initNewTodo();\n\t            $scope.title = \"新建\";\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 跳转到todo详情\n\t     * @param todoid\n\t     */\n\t    $scope.directToDetail = function (todoid) {\n\t        $state.go('todo.edit', {\n\t            userid: todoTools.userInfo.userid(),\n\t            todoid: todoid\n\t        });\n\t    };\n\t\n\t    /**\n\t     * 添加一个todo\n\t     */\n\t    $scope.saveTodo = function () {\n\t        if ($scope.newTodo.todo_name.length < 3 || $scope.newTodo.todo_name.length > 30) {\n\t            $scope.validate.msg = \"TODO名称长度不合法:3-30个字符之间!\";\n\t            $scope.validate.error.todo_name = true;\n\t            return;\n\t        }\n\t\n\t        var startTimeStamp = 0,\n\t            endTimestamp = 0;\n\t\n\t        startTimeStamp = parseInt(Date.parse(new Date($scope.newTodo.start_time)) / 1000);\n\t        endTimestamp = parseInt(Date.parse(new Date($scope.newTodo.end_time)) / 1000);\n\t\n\t        if (startTimeStamp != 0 && endTimestamp != 0) {\n\t            if (startTimeStamp > endTimestamp) {\n\t                $scope.validate.error.start_time = true;\n\t                $scope.validate.error.end_time = true;\n\t                $scope.validate.msg = \"最晚时间不能小于开始时间\";\n\t                return;\n\t            }\n\t        }\n\t\n\t        $scope.newTodo.start_time = startTimeStamp;\n\t        $scope.newTodo.end_time = endTimestamp;\n\t\n\t        var promise = null;\n\t        if (typeof $stateParams.todoid != 'undefined') {\n\t            promise = todoModel.update($scope.newTodo);\n\t        } else {\n\t            promise = todoModel.insert($scope.newTodo);\n\t        }\n\t\n\t        promise.then(function (data) {\n\t            $scope.validate.msg = \"\";\n\t            $scope.validate.error.todo_name = false;\n\t            $scope.validate.error.remark = false;\n\t            $scope.todoList.splice(0, 0, data);\n\t            $state.go(\"todo.list\");\n\t        }, function (resp) {\n\t            if (resp.status == 401) {\n\t                $state.go(\"login\");\n\t                return;\n\t            }\n\t            $scope.validate.msg = \"\";\n\t            $scope.validate.error.todo_name = false;\n\t            $scope.validate.error.remark = false;\n\t            $window.alert(resp.data.errmsg);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * 更新todo状态\n\t     * @param todoid\n\t     */\n\t    $scope.updateStatus = function (todoid) {\n\t        console.log(todoid);\n\t        var todoItem = $scope.filterList.find(function (item) {\n\t            if (item.id == todoid) {\n\t                item.status = item.status == 2 ? 0 : 2;\n\t                if (item.status == 2) {\n\t                    $scope.unfinishNum--;\n\t                } else {\n\t                    $scope.unfinishNum++;\n\t                }\n\t            }\n\t            return item.id === todoid;\n\t        });\n\t\n\t        todoModel.update(todoItem).then(function (data) {}, function (response) {\n\t            if (response.status == 401) {\n\t                $state.go(\"login\");\n\t                return;\n\t            }\n\t            $window.alert(response.data.errmsg);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * 删除一个todo\n\t     * @param todoid\n\t     */\n\t    $scope.deleteTodo = function (todoid) {\n\t        if (!$window.confirm(\"确定要删除该条todo?\")) {\n\t            return;\n\t        }\n\t        todoModel.delete({\n\t            userid: todoTools.userInfo.userid(),\n\t            id: todoid\n\t        }).then(function (data) {\n\t            $state.go(\"todo.list\");\n\t        }, function (response) {\n\t            if (response.status == 401) {\n\t                $state.go(\"login\");\n\t                return;\n\t            }\n\t            var errMsg = \"请求错误\";\n\t            if (_typeof(response.data) == 'object' && typeof response.data.errmsg != 'undefined') {\n\t                errMsg = response.data.errmsg + \"(错误代码:\" + response.data.errcode + \")\";\n\t            }\n\t            $window.alert(errMsg);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * 时间戳转日期\n\t     * @param timestamp\n\t     * @returns {string}\n\t     */\n\t    $scope.timestampToDate = function (timestamp) {\n\t        var dateObj = new Date(timestamp * 1000),\n\t            date = \"\";\n\t\n\t        date = dateObj.getFullYear();\n\t        date += \"-\" + (parseInt(dateObj.getMonth()) + 1);\n\t        date += \"-\" + dateObj.getDate();\n\t        return date;\n\t    };\n\t}]);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t'use strict';\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * userController 用户相关的controller\n\t */\n\t_app2.default.controller(\"userController\", [\"$scope\", \"userModel\", \"md5\", \"$state\", \"todoTools\", function ($scope, userModel, md5, $state, todoTools) {\n\t    // 用户信息\n\t    $scope.userInfo = {\n\t        userid: 0,\n\t        user_name: \"\",\n\t        create_time: 0,\n\t        last_login: 0,\n\t        unfinish_num: 0\n\t    };\n\t\n\t    // 用户登录信息相关\n\t    $scope.userLoginInfo = {\n\t        user_name: \"\",\n\t        password: \"\"\n\t    };\n\t\n\t    $scope.validate = {\n\t        msg: '',\n\t        error: {\n\t            user_name: false,\n\t            password: false\n\t        }\n\t    };\n\t\n\t    // 错误提示\n\t    $scope.errMsg = \"\";\n\t\n\t    // 用户登录\n\t    $scope.login = function () {\n\t        // 验证用户信息\n\t        if (!/^[a-zA-Z0-9]{6,16}$/.test($scope.userLoginInfo.user_name)) {\n\t            $scope.validate.msg = \"请输入正确的用户名(长度6-16位)\";\n\t            $scope.validate.error.user_name = true;\n\t            return;\n\t        }\n\t        if ($scope.userLoginInfo.password.length < 6 || $scope.userLoginInfo.password.length > 16) {\n\t            $scope.validate.msg = \"密码长度在6-16位之间\";\n\t            $scope.validate.error.password = true;\n\t            return;\n\t        }\n\t\n\t        var loginInfo = {\n\t            user_name: $scope.userLoginInfo.user_name,\n\t            password: md5.createHash($scope.userLoginInfo.password)\n\t        };\n\t\n\t        userModel.login(loginInfo).then(function (data) {\n\t            $scope.validate.msg = '';\n\t            $scope.validate.error.user_name = false;\n\t            $scope.validate.error.password = false;\n\t\n\t            todoTools.userInfo.save(data);\n\t\n\t            $state.go(\"todo.list\");\n\t        }, function (response) {\n\t            $scope.validate.error.user_name = false;\n\t            $scope.validate.error.password = false;\n\t            $scope.validate.msg = response.data.errmsg + \"(\" + \"错误代码:\" + response.data.errcode + \")\";\n\t        });\n\t    };\n\t\n\t    if (todoTools.isLogin()) {\n\t        $state.go(\"todo.list\");\n\t    }\n\t}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 6/5/16.\n\t */\n\t\n\t'use strict';\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_app2.default.factory(\"todo-consts\", function () {\n\t    var consts = {\n\t        DEFAULT_CATEGORYID: 0, // 默认的categoryid\n\t        DEFAULT_TODONAME: \"\",\n\t        DEFAULT_TODOSTATUS: 0, // 默认新建状态\n\t        TODO_CATEGORYLIST: [{\n\t            id: 0,\n\t            name: \"全部\"\n\t        }, {\n\t            id: 1,\n\t            name: \"已完成\"\n\t        }, {\n\t            id: 2,\n\t            name: \"待完成\"\n\t        }] // 默认的todo状态列表\n\t    };\n\t\n\t    return consts;\n\t});\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t'use strict';\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\t__webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * todoModel 关于todo的model操作\n\t */\n\t_app2.default.factory(\"todoModel\", [\"$resource\", \"todoTools\", function ($resource, todoTools) {\n\t  return {\n\t    /**\n\t     * 获取列表信息\n\t     *\n\t     * @param userid\n\t     * @returns {*|Function}\n\t     */\n\t    list: function list(userid) {\n\t      return $resource(todoTools.apiUrl('todo/:userid'), { userid: userid }).get().$promise;\n\t    },\n\t    /**\n\t     * 插入一个新的todo数据\n\t     * @param data\n\t     */\n\t    insert: function insert(data) {\n\t      return $resource(todoTools.apiUrl('todo/:userid'), { userid: data.userid }).save(data).$promise;\n\t    },\n\t    /**\n\t     * 更新一条todo\n\t     * @param data\n\t     */\n\t    update: function update(data) {\n\t      return $resource(todoTools.apiUrl('todo/:userid/:todoid'), { userid: data.userid, todoid: data.id }).update(data).$promise;\n\t    },\n\t    /**\n\t     * 删除一条todo\n\t     * @param data\n\t     */\n\t    delete: function _delete(data) {\n\t      return $resource(todoTools.apiUrl('todo/:userid/:todoid'), { userid: data.userid, todoid: data.id }).delete().$promise;\n\t    },\n\t    /**\n\t     * 获取某todo详情\n\t     * @param data\n\t     * @returns {*|Function}\n\t     */\n\t    detail: function detail(data) {\n\t      return $resource(todoTools.apiUrl('todo/:userid/:todoid'), { userid: data.userid, todoid: data.id }).get().$promise;\n\t    }\n\t  };\n\t}]);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t'use strict';\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\t__webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * userModel 关于user的一些model\n\t */\n\t_app2.default.factory(\"userModel\", [\"$resource\", \"todoTools\", function ($resource, todoTools) {\n\t  return {\n\t    /**\n\t     * 用户登录\n\t     * @param data\n\t     * @returns {*|Function}\n\t     */\n\t    login: function login(data) {\n\t      return $resource(todoTools.apiUrl('login')).save(data).$promise;\n\t    }\n\t  };\n\t}]);\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by scofield on 5/31/16.\n\t */\n\t'use strict';\n\t\n\tvar _app = __webpack_require__(1);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_app2.default.config([\"$stateProvider\", \"$urlRouterProvider\", function ($stateProvider, $urlRouterProvider) {\n\t    $urlRouterProvider.otherwise(\"/todo/list\");\n\t\n\t    $stateProvider\n\t    // todo列表\n\t    .state('todo', {\n\t        abstract: true,\n\t        url: \"/todo\",\n\t        template: \"<div ui-view></div>\"\n\t    }).state('todo.list', {\n\t        url: \"/list\",\n\t        templateUrl: \"/statics/tpls/todo/list.html\",\n\t        controller: \"todoController\"\n\t    })\n\t    // todo详情\n\t    .state('todo.detail', {\n\t        url: \"/detail/:todoid\",\n\t        templateUrl: '/statics/tpls/todo/detail.html',\n\t        controller: \"todoController\"\n\t    })\n\t    // todo新建\n\t    .state('todo.insert', {\n\t        url: '/insert',\n\t        templateUrl: '/statics/tpls/todo/edit.html',\n\t        controller: \"todoController\"\n\t    })\n\t    // todo编辑\n\t    .state('todo.edit', {\n\t        url: \"/edit/:todoid\",\n\t        templateUrl: '/statics/tpls/todo/edit.html',\n\t        controller: \"todoController\"\n\t    })\n\t    // todo删除\n\t    .state('todo.delete', {\n\t        url: \"/delete/:todoid\",\n\t        templateUrl: \"/statics/tpls/todo/delete.html\",\n\t        controller: \"todoController\"\n\t    })\n\t    // 用户登录\n\t    .state('login', {\n\t        url: \"/user/login\",\n\t        templateUrl: \"/statics/tpls/user/login.html\",\n\t        controller: \"userController\"\n\t    });\n\t}]);\n\t\n\t_app2.default.run([\"$rootScope\", \"$state\", \"todoTools\", function ($rootScope, $state, todoTools) {\n\t    // publicUrls 不需要登录的states\n\t    var publicUrls = [\"todo\", \"todo.list\", \"user.login\"];\n\t    $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams, error) {\n\t        $rootScope.previousState = fromState.name;\n\t        // 判断用户是否登录\n\t        if (publicUrls.indexOf(toState.name) == -1) {\n\t            if (!todoTools.isLogin()) {\n\t                $state.go('login');\n\t            }\n\t        }\n\t    });\n\t}]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** app.js\n **/"," \tvar parentHotUpdateCallback = this[\"webpackHotUpdate\"];\n \tthis[\"webpackHotUpdate\"] = \r\n \tfunction webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\thotAddUpdateChunk(chunkId, moreModules);\r\n \t\tif(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\r\n \t}\r\n \t\r\n \tfunction hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars\r\n \t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n \t\tvar script = document.createElement(\"script\");\r\n \t\tscript.type = \"text/javascript\";\r\n \t\tscript.charset = \"utf-8\";\r\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\";\r\n \t\thead.appendChild(script);\r\n \t}\r\n \t\r\n \tfunction hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars\r\n \t\tif(typeof XMLHttpRequest === \"undefined\")\r\n \t\t\treturn callback(new Error(\"No browser support\"));\r\n \t\ttry {\r\n \t\t\tvar request = new XMLHttpRequest();\r\n \t\t\tvar requestPath = __webpack_require__.p + \"\" + hotCurrentHash + \".hot-update.json\";\r\n \t\t\trequest.open(\"GET\", requestPath, true);\r\n \t\t\trequest.timeout = 10000;\r\n \t\t\trequest.send(null);\r\n \t\t} catch(err) {\r\n \t\t\treturn callback(err);\r\n \t\t}\r\n \t\trequest.onreadystatechange = function() {\r\n \t\t\tif(request.readyState !== 4) return;\r\n \t\t\tif(request.status === 0) {\r\n \t\t\t\t// timeout\r\n \t\t\t\tcallback(new Error(\"Manifest request to \" + requestPath + \" timed out.\"));\r\n \t\t\t} else if(request.status === 404) {\r\n \t\t\t\t// no update available\r\n \t\t\t\tcallback();\r\n \t\t\t} else if(request.status !== 200 && request.status !== 304) {\r\n \t\t\t\t// other failure\r\n \t\t\t\tcallback(new Error(\"Manifest request to \" + requestPath + \" failed.\"));\r\n \t\t\t} else {\r\n \t\t\t\t// success\r\n \t\t\t\ttry {\r\n \t\t\t\t\tvar update = JSON.parse(request.responseText);\r\n \t\t\t\t} catch(e) {\r\n \t\t\t\t\tcallback(e);\r\n \t\t\t\t\treturn;\r\n \t\t\t\t}\r\n \t\t\t\tcallback(null, update);\r\n \t\t\t}\r\n \t\t};\r\n \t}\r\n\n \t\r\n \t\r\n \t// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js\r\n \tvar canDefineProperty = false;\r\n \ttry {\r\n \t\tObject.defineProperty({}, \"x\", {\r\n \t\t\tget: function() {}\r\n \t\t});\r\n \t\tcanDefineProperty = true;\r\n \t} catch(x) {\r\n \t\t// IE will fail on defineProperty\r\n \t}\r\n \t\r\n \tvar hotApplyOnUpdate = true;\r\n \tvar hotCurrentHash = \"26a4502983c84f9af9cd\"; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentModuleData = {};\r\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n \t\r\n \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar me = installedModules[moduleId];\r\n \t\tif(!me) return __webpack_require__;\r\n \t\tvar fn = function(request) {\r\n \t\t\tif(me.hot.active) {\r\n \t\t\t\tif(installedModules[request]) {\r\n \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n \t\t\t\t\tif(me.children.indexOf(request) < 0)\r\n \t\t\t\t\t\tme.children.push(request);\r\n \t\t\t\t} else hotCurrentParents = [moduleId];\r\n \t\t\t} else {\r\n \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n \t\t\t\thotCurrentParents = [];\r\n \t\t\t}\r\n \t\t\treturn __webpack_require__(request);\r\n \t\t};\r\n \t\tfor(var name in __webpack_require__) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {\r\n \t\t\t\tif(canDefineProperty) {\r\n \t\t\t\t\tObject.defineProperty(fn, name, (function(name) {\r\n \t\t\t\t\t\treturn {\r\n \t\t\t\t\t\t\tconfigurable: true,\r\n \t\t\t\t\t\t\tenumerable: true,\r\n \t\t\t\t\t\t\tget: function() {\r\n \t\t\t\t\t\t\t\treturn __webpack_require__[name];\r\n \t\t\t\t\t\t\t},\r\n \t\t\t\t\t\t\tset: function(value) {\r\n \t\t\t\t\t\t\t\t__webpack_require__[name] = value;\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t};\r\n \t\t\t\t\t}(name)));\r\n \t\t\t\t} else {\r\n \t\t\t\t\tfn[name] = __webpack_require__[name];\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\tfunction ensure(chunkId, callback) {\r\n \t\t\tif(hotStatus === \"ready\")\r\n \t\t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotChunksLoading++;\r\n \t\t\t__webpack_require__.e(chunkId, function() {\r\n \t\t\t\ttry {\r\n \t\t\t\t\tcallback.call(null, fn);\r\n \t\t\t\t} finally {\r\n \t\t\t\t\tfinishChunkLoading();\r\n \t\t\t\t}\r\n \t\r\n \t\t\t\tfunction finishChunkLoading() {\r\n \t\t\t\t\thotChunksLoading--;\r\n \t\t\t\t\tif(hotStatus === \"prepare\") {\r\n \t\t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n \t\t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\t\t\t\thotUpdateDownloaded();\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t});\r\n \t\t}\r\n \t\tif(canDefineProperty) {\r\n \t\t\tObject.defineProperty(fn, \"e\", {\r\n \t\t\t\tenumerable: true,\r\n \t\t\t\tvalue: ensure\r\n \t\t\t});\r\n \t\t} else {\r\n \t\t\tfn.e = ensure;\r\n \t\t}\r\n \t\treturn fn;\r\n \t}\r\n \t\r\n \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar hot = {\r\n \t\t\t// private stuff\r\n \t\t\t_acceptedDependencies: {},\r\n \t\t\t_declinedDependencies: {},\r\n \t\t\t_selfAccepted: false,\r\n \t\t\t_selfDeclined: false,\r\n \t\t\t_disposeHandlers: [],\r\n \t\r\n \t\t\t// Module API\r\n \t\t\tactive: true,\r\n \t\t\taccept: function(dep, callback) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfAccepted = true;\r\n \t\t\t\telse if(typeof dep === \"function\")\r\n \t\t\t\t\thot._selfAccepted = dep;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback;\r\n \t\t\t\telse\r\n \t\t\t\t\thot._acceptedDependencies[dep] = callback;\r\n \t\t\t},\r\n \t\t\tdecline: function(dep) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfDeclined = true;\r\n \t\t\t\telse if(typeof dep === \"number\")\r\n \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n \t\t\t\telse\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n \t\t\t},\r\n \t\t\tdispose: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\taddDisposeHandler: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\tremoveDisposeHandler: function(callback) {\r\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t// Management API\r\n \t\t\tcheck: hotCheck,\r\n \t\t\tapply: hotApply,\r\n \t\t\tstatus: function(l) {\r\n \t\t\t\tif(!l) return hotStatus;\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\taddStatusHandler: function(l) {\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\tremoveStatusHandler: function(l) {\r\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t//inherit from previous dispose call\r\n \t\t\tdata: hotCurrentModuleData[moduleId]\r\n \t\t};\r\n \t\treturn hot;\r\n \t}\r\n \t\r\n \tvar hotStatusHandlers = [];\r\n \tvar hotStatus = \"idle\";\r\n \t\r\n \tfunction hotSetStatus(newStatus) {\r\n \t\thotStatus = newStatus;\r\n \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n \t}\r\n \t\r\n \t// while downloading\r\n \tvar hotWaitingFiles = 0;\r\n \tvar hotChunksLoading = 0;\r\n \tvar hotWaitingFilesMap = {};\r\n \tvar hotRequestedFilesMap = {};\r\n \tvar hotAvailibleFilesMap = {};\r\n \tvar hotCallback;\r\n \t\r\n \t// The update info\r\n \tvar hotUpdate, hotUpdateNewHash;\r\n \t\r\n \tfunction toModuleId(id) {\r\n \t\tvar isNumber = (+id) + \"\" === id;\r\n \t\treturn isNumber ? +id : id;\r\n \t}\r\n \t\r\n \tfunction hotCheck(apply, callback) {\r\n \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n \t\tif(typeof apply === \"function\") {\r\n \t\t\thotApplyOnUpdate = false;\r\n \t\t\tcallback = apply;\r\n \t\t} else {\r\n \t\t\thotApplyOnUpdate = apply;\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\thotSetStatus(\"check\");\r\n \t\thotDownloadManifest(function(err, update) {\r\n \t\t\tif(err) return callback(err);\r\n \t\t\tif(!update) {\r\n \t\t\t\thotSetStatus(\"idle\");\r\n \t\t\t\tcallback(null, null);\r\n \t\t\t\treturn;\r\n \t\t\t}\r\n \t\r\n \t\t\thotRequestedFilesMap = {};\r\n \t\t\thotAvailibleFilesMap = {};\r\n \t\t\thotWaitingFilesMap = {};\r\n \t\t\tfor(var i = 0; i < update.c.length; i++)\r\n \t\t\t\thotAvailibleFilesMap[update.c[i]] = true;\r\n \t\t\thotUpdateNewHash = update.h;\r\n \t\r\n \t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotCallback = callback;\r\n \t\t\thotUpdate = {};\r\n \t\t\tvar chunkId = 0;\r\n \t\t\t{ // eslint-disable-line no-lone-blocks\r\n \t\t\t\t/*globals chunkId */\r\n \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t}\r\n \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\thotUpdateDownloaded();\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\tif(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n \t\t\treturn;\r\n \t\thotRequestedFilesMap[chunkId] = false;\r\n \t\tfor(var moduleId in moreModules) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n \t\t\thotUpdateDownloaded();\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotEnsureUpdateChunk(chunkId) {\r\n \t\tif(!hotAvailibleFilesMap[chunkId]) {\r\n \t\t\thotWaitingFilesMap[chunkId] = true;\r\n \t\t} else {\r\n \t\t\thotRequestedFilesMap[chunkId] = true;\r\n \t\t\thotWaitingFiles++;\r\n \t\t\thotDownloadUpdateChunk(chunkId);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotUpdateDownloaded() {\r\n \t\thotSetStatus(\"ready\");\r\n \t\tvar callback = hotCallback;\r\n \t\thotCallback = null;\r\n \t\tif(!callback) return;\r\n \t\tif(hotApplyOnUpdate) {\r\n \t\t\thotApply(hotApplyOnUpdate, callback);\r\n \t\t} else {\r\n \t\t\tvar outdatedModules = [];\r\n \t\t\tfor(var id in hotUpdate) {\r\n \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tcallback(null, outdatedModules);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotApply(options, callback) {\r\n \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n \t\tif(typeof options === \"function\") {\r\n \t\t\tcallback = options;\r\n \t\t\toptions = {};\r\n \t\t} else if(options && typeof options === \"object\") {\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t} else {\r\n \t\t\toptions = {};\r\n \t\t\tcallback = callback || function(err) {\r\n \t\t\t\tif(err) throw err;\r\n \t\t\t};\r\n \t\t}\r\n \t\r\n \t\tfunction getAffectedStuff(module) {\r\n \t\t\tvar outdatedModules = [module];\r\n \t\t\tvar outdatedDependencies = {};\r\n \t\r\n \t\t\tvar queue = outdatedModules.slice();\r\n \t\t\twhile(queue.length > 0) {\r\n \t\t\t\tvar moduleId = queue.pop();\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tif(!module || module.hot._selfAccepted)\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tif(module.hot._selfDeclined) {\r\n \t\t\t\t\treturn new Error(\"Aborted because of self decline: \" + moduleId);\r\n \t\t\t\t}\r\n \t\t\t\tif(moduleId === 0) {\r\n \t\t\t\t\treturn;\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n \t\t\t\t\tvar parentId = module.parents[i];\r\n \t\t\t\t\tvar parent = installedModules[parentId];\r\n \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n \t\t\t\t\t\treturn new Error(\"Aborted because of declined dependency: \" + moduleId + \" in \" + parentId);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n \t\t\t\t\toutdatedModules.push(parentId);\r\n \t\t\t\t\tqueue.push(parentId);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\r\n \t\t\treturn [outdatedModules, outdatedDependencies];\r\n \t\t}\r\n \t\r\n \t\tfunction addAllToSet(a, b) {\r\n \t\t\tfor(var i = 0; i < b.length; i++) {\r\n \t\t\t\tvar item = b[i];\r\n \t\t\t\tif(a.indexOf(item) < 0)\r\n \t\t\t\t\ta.push(item);\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// at begin all updates modules are outdated\r\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n \t\tvar outdatedDependencies = {};\r\n \t\tvar outdatedModules = [];\r\n \t\tvar appliedUpdate = {};\r\n \t\tfor(var id in hotUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\tvar moduleId = toModuleId(id);\r\n \t\t\t\tvar result = getAffectedStuff(moduleId);\r\n \t\t\t\tif(!result) {\r\n \t\t\t\t\tif(options.ignoreUnaccepted)\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(new Error(\"Aborted because \" + moduleId + \" is not accepted\"));\r\n \t\t\t\t}\r\n \t\t\t\tif(result instanceof Error) {\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn callback(result);\r\n \t\t\t\t}\r\n \t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n \t\t\t\taddAllToSet(outdatedModules, result[0]);\r\n \t\t\t\tfor(var moduleId in result[1]) {\r\n \t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n \t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Store self accepted outdated modules to require them later by the module system\r\n \t\tvar outdatedSelfAcceptedModules = [];\r\n \t\tfor(var i = 0; i < outdatedModules.length; i++) {\r\n \t\t\tvar moduleId = outdatedModules[i];\r\n \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n \t\t\t\toutdatedSelfAcceptedModules.push({\r\n \t\t\t\t\tmodule: moduleId,\r\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n \t\t\t\t});\r\n \t\t}\r\n \t\r\n \t\t// Now in \"dispose\" phase\r\n \t\thotSetStatus(\"dispose\");\r\n \t\tvar queue = outdatedModules.slice();\r\n \t\twhile(queue.length > 0) {\r\n \t\t\tvar moduleId = queue.pop();\r\n \t\t\tvar module = installedModules[moduleId];\r\n \t\t\tif(!module) continue;\r\n \t\r\n \t\t\tvar data = {};\r\n \t\r\n \t\t\t// Call dispose handlers\r\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n \t\t\tfor(var j = 0; j < disposeHandlers.length; j++) {\r\n \t\t\t\tvar cb = disposeHandlers[j];\r\n \t\t\t\tcb(data);\r\n \t\t\t}\r\n \t\t\thotCurrentModuleData[moduleId] = data;\r\n \t\r\n \t\t\t// disable module (this disables requires from this module)\r\n \t\t\tmodule.hot.active = false;\r\n \t\r\n \t\t\t// remove module from cache\r\n \t\t\tdelete installedModules[moduleId];\r\n \t\r\n \t\t\t// remove \"parents\" references from all children\r\n \t\t\tfor(var j = 0; j < module.children.length; j++) {\r\n \t\t\t\tvar child = installedModules[module.children[j]];\r\n \t\t\t\tif(!child) continue;\r\n \t\t\t\tvar idx = child.parents.indexOf(moduleId);\r\n \t\t\t\tif(idx >= 0) {\r\n \t\t\t\t\tchild.parents.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// remove outdated dependency from module children\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tfor(var j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\r\n \t\t\t\t\tvar idx = module.children.indexOf(dependency);\r\n \t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Not in \"apply\" phase\r\n \t\thotSetStatus(\"apply\");\r\n \t\r\n \t\thotCurrentHash = hotUpdateNewHash;\r\n \t\r\n \t\t// insert new code\r\n \t\tfor(var moduleId in appliedUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// call accept handlers\r\n \t\tvar error = null;\r\n \t\tfor(var moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tvar module = installedModules[moduleId];\r\n \t\t\t\tvar moduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tvar callbacks = [];\r\n \t\t\t\tfor(var i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n \t\t\t\t\tvar dependency = moduleOutdatedDependencies[i];\r\n \t\t\t\t\tvar cb = module.hot._acceptedDependencies[dependency];\r\n \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n \t\t\t\t\tcallbacks.push(cb);\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < callbacks.length; i++) {\r\n \t\t\t\t\tvar cb = callbacks[i];\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tcb(outdatedDependencies);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Load self accepted modules\r\n \t\tfor(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n \t\t\tvar moduleId = item.module;\r\n \t\t\thotCurrentParents = [moduleId];\r\n \t\t\ttry {\r\n \t\t\t\t__webpack_require__(moduleId);\r\n \t\t\t} catch(err) {\r\n \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\titem.errorHandler(err);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t} else if(!error)\r\n \t\t\t\t\terror = err;\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// handle errors in accept handlers and self accepted module load\r\n \t\tif(error) {\r\n \t\t\thotSetStatus(\"fail\");\r\n \t\t\treturn callback(error);\r\n \t\t}\r\n \t\r\n \t\thotSetStatus(\"idle\");\r\n \t\tcallback(null, outdatedModules);\r\n \t}\r\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false,\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: hotCurrentParents,\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/statics/\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 26a4502983c84f9af9cd\n **/","/**\n * Created by scofield on 5/31/16.\n */\n\nvar app = angular.module(\"todo\",[require(\"angular-ui-router\"),require(\"angular-resource\"),require('angular-cookies'),require('angular-md5')]);\n    app.value('TODO_VERSON','beta 1.0');\n\n    app.config([\"$resourceProvider\",function($resourceProvider){\n        $resourceProvider.defaults.actions.update = {\n            \"method\":\"PUT\"\n        };\n    }]);\n\nexport default app;\n\n\n\n/** WEBPACK FOOTER **\n ** ./app.js\n **/","/**\n * Created by scofield on 5/31/16.\n */\n\n'use strict';\n\nimport path from \"path\";\nimport app from \"../app\";\n\napp.factory(\"todoTools\",[\"$http\",\"$window\",\"$cookies\",function($http,$window,$cookies){\n    var tools = {\n        /**1w\n         * 生成api请求地址\n         *\n         * @param url 请求的api地址\n         * @returns {string|*} 返回完整的api请求地址\n         */\n        apiUrl:function(url){\n            return path.join(\"/api/v1\",url);\n        },\n        /**\n         * userInfo 获取用户信息(从localStorage)\n         */\n        userInfo:{\n            /**\n             * 获取用户userid\n             */\n            userid:function() {\n                return $window.localStorage.getItem(\"TODO-userid\") == null ? 1 : parseInt($window.localStorage.getItem(\"TODO-userid\"));\n            },\n            /**\n             * 获取用户user_name\n             */\n            userName:function() {\n                return $window.localStorage.getItem(\"TODO-user_name\") == null ? \"\" : $window.localStorage.getItem(\"TODO-user_name\");\n            },\n            /**\n             * 获取用户上次登录时间\n             */\n            lastLogin:function() {\n                return $window.localStorage.getItem(\"TODO-last_login\") == null ? 0 : parseInt($window.localStorage.getItem(\"TODO-last_login\"));\n            },\n            /**\n             * 获取用户未完成数量\n             */\n            unfinishNum:function() {\n                return $window.localStorage.getItem(\"TODO-unfinish_num\") == null ? 0 : parseInt($window.localStorage.getItem(\"TODO-unfinish_num\"));\n            },\n            /**\n             * 保存用户信息\n             *\n             * @param userInfo\n             */\n            save:function(userInfo) {\n                if (typeof userInfo == \"object\") {\n                    if (typeof userInfo.userid != 'undefined') {\n                        $window.localStorage.setItem(\"TODO-userid\",userInfo.userid);\n                    }\n                    if (typeof userInfo['user_name'] != 'undefined') {\n                        $window.localStorage.setItem(\"TODO-user_name\",userInfo['user_name']);\n                    }\n                    if (typeof userInfo['last_login'] != 'undefined') {\n                        $window.localStorage.setItem(\"TODO-last_login\",userInfo['last_login']);\n                    }\n                    if (typeof userInfo['unfinish_num'] != 'undefined') {\n                        $window.localStorage.setItem(\"TODO-unfinish_num\",userInfo['unfinish_num']);\n                    }\n                }\n            }\n        },\n        /**\n         * 用户是否登录\n         *\n         * @returns {boolean}\n         */\n        isLogin:function() {\n            return $cookies.get('todo_logintoken') != \"\" && typeof $cookies.get('todo_logintoken') != 'undefined';\n        }\n    };\n\n    return tools;\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./libs/tools.js\n **/","/**\n * @license AngularJS v1.5.6\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngCookies\n * @description\n *\n * # ngCookies\n *\n * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies.\n *\n *\n * <div doc-module-components=\"ngCookies\"></div>\n *\n * See {@link ngCookies.$cookies `$cookies`} for usage.\n */\n\n\nangular.module('ngCookies', ['ng']).\n  /**\n   * @ngdoc provider\n   * @name $cookiesProvider\n   * @description\n   * Use `$cookiesProvider` to change the default behavior of the {@link ngCookies.$cookies $cookies} service.\n   * */\n   provider('$cookies', [function $CookiesProvider() {\n    /**\n     * @ngdoc property\n     * @name $cookiesProvider#defaults\n     * @description\n     *\n     * Object containing default options to pass when setting cookies.\n     *\n     * The object may have following properties:\n     *\n     * - **path** - `{string}` - The cookie will be available only for this path and its\n     *   sub-paths. By default, this is the URL that appears in your `<base>` tag.\n     * - **domain** - `{string}` - The cookie will be available only for this domain and\n     *   its sub-domains. For security reasons the user agent will not accept the cookie\n     *   if the current domain is not a sub-domain of this domain or equal to it.\n     * - **expires** - `{string|Date}` - String of the form \"Wdy, DD Mon YYYY HH:MM:SS GMT\"\n     *   or a Date object indicating the exact date/time this cookie will expire.\n     * - **secure** - `{boolean}` - If `true`, then the cookie will only be available through a\n     *   secured connection.\n     *\n     * Note: By default, the address that appears in your `<base>` tag will be used as the path.\n     * This is important so that cookies will be visible for all routes when html5mode is enabled.\n     *\n     **/\n    var defaults = this.defaults = {};\n\n    function calcOptions(options) {\n      return options ? angular.extend({}, defaults, options) : defaults;\n    }\n\n    /**\n     * @ngdoc service\n     * @name $cookies\n     *\n     * @description\n     * Provides read/write access to browser's cookies.\n     *\n     * <div class=\"alert alert-info\">\n     * Up until Angular 1.3, `$cookies` exposed properties that represented the\n     * current browser cookie values. In version 1.4, this behavior has changed, and\n     * `$cookies` now provides a standard api of getters, setters etc.\n     * </div>\n     *\n     * Requires the {@link ngCookies `ngCookies`} module to be installed.\n     *\n     * @example\n     *\n     * ```js\n     * angular.module('cookiesExample', ['ngCookies'])\n     *   .controller('ExampleController', ['$cookies', function($cookies) {\n     *     // Retrieving a cookie\n     *     var favoriteCookie = $cookies.get('myFavorite');\n     *     // Setting a cookie\n     *     $cookies.put('myFavorite', 'oatmeal');\n     *   }]);\n     * ```\n     */\n    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {\n      return {\n        /**\n         * @ngdoc method\n         * @name $cookies#get\n         *\n         * @description\n         * Returns the value of given cookie key\n         *\n         * @param {string} key Id to use for lookup.\n         * @returns {string} Raw cookie value.\n         */\n        get: function(key) {\n          return $$cookieReader()[key];\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#getObject\n         *\n         * @description\n         * Returns the deserialized value of given cookie key\n         *\n         * @param {string} key Id to use for lookup.\n         * @returns {Object} Deserialized cookie value.\n         */\n        getObject: function(key) {\n          var value = this.get(key);\n          return value ? angular.fromJson(value) : value;\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#getAll\n         *\n         * @description\n         * Returns a key value object with all the cookies\n         *\n         * @returns {Object} All cookies\n         */\n        getAll: function() {\n          return $$cookieReader();\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#put\n         *\n         * @description\n         * Sets a value for given cookie key\n         *\n         * @param {string} key Id for the `value`.\n         * @param {string} value Raw value to be stored.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        put: function(key, value, options) {\n          $$cookieWriter(key, value, calcOptions(options));\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#putObject\n         *\n         * @description\n         * Serializes and sets a value for given cookie key\n         *\n         * @param {string} key Id for the `value`.\n         * @param {Object} value Value to be stored.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        putObject: function(key, value, options) {\n          this.put(key, angular.toJson(value), options);\n        },\n\n        /**\n         * @ngdoc method\n         * @name $cookies#remove\n         *\n         * @description\n         * Remove given cookie\n         *\n         * @param {string} key Id of the key-value pair to delete.\n         * @param {Object=} options Options object.\n         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}\n         */\n        remove: function(key, options) {\n          $$cookieWriter(key, undefined, calcOptions(options));\n        }\n      };\n    }];\n  }]);\n\nangular.module('ngCookies').\n/**\n * @ngdoc service\n * @name $cookieStore\n * @deprecated\n * @requires $cookies\n *\n * @description\n * Provides a key-value (string-object) storage, that is backed by session cookies.\n * Objects put or retrieved from this storage are automatically serialized or\n * deserialized by angular's toJson/fromJson.\n *\n * Requires the {@link ngCookies `ngCookies`} module to be installed.\n *\n * <div class=\"alert alert-danger\">\n * **Note:** The $cookieStore service is **deprecated**.\n * Please use the {@link ngCookies.$cookies `$cookies`} service instead.\n * </div>\n *\n * @example\n *\n * ```js\n * angular.module('cookieStoreExample', ['ngCookies'])\n *   .controller('ExampleController', ['$cookieStore', function($cookieStore) {\n *     // Put cookie\n *     $cookieStore.put('myFavorite','oatmeal');\n *     // Get cookie\n *     var favoriteCookie = $cookieStore.get('myFavorite');\n *     // Removing a cookie\n *     $cookieStore.remove('myFavorite');\n *   }]);\n * ```\n */\n factory('$cookieStore', ['$cookies', function($cookies) {\n\n    return {\n      /**\n       * @ngdoc method\n       * @name $cookieStore#get\n       *\n       * @description\n       * Returns the value of given cookie key\n       *\n       * @param {string} key Id to use for lookup.\n       * @returns {Object} Deserialized cookie value, undefined if the cookie does not exist.\n       */\n      get: function(key) {\n        return $cookies.getObject(key);\n      },\n\n      /**\n       * @ngdoc method\n       * @name $cookieStore#put\n       *\n       * @description\n       * Sets a value for given cookie key\n       *\n       * @param {string} key Id for the `value`.\n       * @param {Object} value Value to be stored.\n       */\n      put: function(key, value) {\n        $cookies.putObject(key, value);\n      },\n\n      /**\n       * @ngdoc method\n       * @name $cookieStore#remove\n       *\n       * @description\n       * Remove given cookie\n       *\n       * @param {string} key Id of the key-value pair to delete.\n       */\n      remove: function(key) {\n        $cookies.remove(key);\n      }\n    };\n\n  }]);\n\n/**\n * @name $$cookieWriter\n * @requires $document\n *\n * @description\n * This is a private service for writing cookies\n *\n * @param {string} name Cookie name\n * @param {string=} value Cookie value (if undefined, cookie will be deleted)\n * @param {Object=} options Object with options that need to be stored for the cookie.\n */\nfunction $$CookieWriter($document, $log, $browser) {\n  var cookiePath = $browser.baseHref();\n  var rawDocument = $document[0];\n\n  function buildCookieString(name, value, options) {\n    var path, expires;\n    options = options || {};\n    expires = options.expires;\n    path = angular.isDefined(options.path) ? options.path : cookiePath;\n    if (angular.isUndefined(value)) {\n      expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n      value = '';\n    }\n    if (angular.isString(expires)) {\n      expires = new Date(expires);\n    }\n\n    var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n    str += path ? ';path=' + path : '';\n    str += options.domain ? ';domain=' + options.domain : '';\n    str += expires ? ';expires=' + expires.toUTCString() : '';\n    str += options.secure ? ';secure' : '';\n\n    // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n    // - 300 cookies\n    // - 20 cookies per unique domain\n    // - 4096 bytes per cookie\n    var cookieLength = str.length + 1;\n    if (cookieLength > 4096) {\n      $log.warn(\"Cookie '\" + name +\n        \"' possibly not set or overflowed because it was too large (\" +\n        cookieLength + \" > 4096 bytes)!\");\n    }\n\n    return str;\n  }\n\n  return function(name, value, options) {\n    rawDocument.cookie = buildCookieString(name, value, options);\n  };\n}\n\n$$CookieWriter.$inject = ['$document', '$log', '$browser'];\n\nangular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {\n  this.$get = $$CookieWriter;\n});\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-cookies/angular-cookies.js\n ** module id = 3\n ** module chunks = 0 1\n **/","require('./angular-cookies');\nmodule.exports = 'ngCookies';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-cookies/index.js\n ** module id = 4\n ** module chunks = 0 1\n **/","/*\n  angular-md5 - v0.1.8 \n  2015-11-17\n*/\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports) {\n  module.exports = \"angular-md5\";\n}\n(function(angular) {\n  angular.module(\"angular-md5\", [ \"gdi2290.md5\" ]);\n  angular.module(\"ngMd5\", [ \"gdi2290.md5\" ]);\n  angular.module(\"gdi2290.md5\", [ \"gdi2290.gravatar-filter\", \"gdi2290.md5-service\", \"gdi2290.md5-filter\" ]);\n  \"use strict\";\n  angular.module(\"gdi2290.gravatar-filter\", []).filter(\"gravatar\", [ \"md5\", function(md5) {\n    var cache = {};\n    return function(text, defaultText) {\n      if (!cache[text]) {\n        defaultText = defaultText ? md5.createHash(defaultText.toString().toLowerCase()) : \"\";\n        cache[text] = text ? md5.createHash(text.toString().toLowerCase()) : defaultText;\n      }\n      return cache[text];\n    };\n  } ]);\n  \"use strict\";\n  angular.module(\"gdi2290.md5-filter\", []).filter(\"md5\", [ \"md5\", function(md5) {\n    return function(text) {\n      return text ? md5.createHash(text.toString().toLowerCase()) : text;\n    };\n  } ]);\n  \"use strict\";\n  angular.module(\"gdi2290.md5-service\", []).factory(\"md5\", [ function() {\n    var md5 = {\n      createHash: function(str) {\n        if (null === str) {\n          return null;\n        }\n        var xl;\n        var rotateLeft = function(lValue, iShiftBits) {\n          return lValue << iShiftBits | lValue >>> 32 - iShiftBits;\n        };\n        var addUnsigned = function(lX, lY) {\n          var lX4, lY4, lX8, lY8, lResult;\n          lX8 = lX & 2147483648;\n          lY8 = lY & 2147483648;\n          lX4 = lX & 1073741824;\n          lY4 = lY & 1073741824;\n          lResult = (lX & 1073741823) + (lY & 1073741823);\n          if (lX4 & lY4) {\n            return lResult ^ 2147483648 ^ lX8 ^ lY8;\n          }\n          if (lX4 | lY4) {\n            if (lResult & 1073741824) {\n              return lResult ^ 3221225472 ^ lX8 ^ lY8;\n            } else {\n              return lResult ^ 1073741824 ^ lX8 ^ lY8;\n            }\n          } else {\n            return lResult ^ lX8 ^ lY8;\n          }\n        };\n        var _F = function(x, y, z) {\n          return x & y | ~x & z;\n        };\n        var _G = function(x, y, z) {\n          return x & z | y & ~z;\n        };\n        var _H = function(x, y, z) {\n          return x ^ y ^ z;\n        };\n        var _I = function(x, y, z) {\n          return y ^ (x | ~z);\n        };\n        var _FF = function(a, b, c, d, x, s, ac) {\n          a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));\n          return addUnsigned(rotateLeft(a, s), b);\n        };\n        var _GG = function(a, b, c, d, x, s, ac) {\n          a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));\n          return addUnsigned(rotateLeft(a, s), b);\n        };\n        var _HH = function(a, b, c, d, x, s, ac) {\n          a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));\n          return addUnsigned(rotateLeft(a, s), b);\n        };\n        var _II = function(a, b, c, d, x, s, ac) {\n          a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));\n          return addUnsigned(rotateLeft(a, s), b);\n        };\n        var convertToWordArray = function(str) {\n          var lWordCount;\n          var lMessageLength = str.length;\n          var lNumberOfWords_temp1 = lMessageLength + 8;\n          var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;\n          var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n          var lWordArray = new Array(lNumberOfWords - 1);\n          var lBytePosition = 0;\n          var lByteCount = 0;\n          while (lByteCount < lMessageLength) {\n            lWordCount = (lByteCount - lByteCount % 4) / 4;\n            lBytePosition = lByteCount % 4 * 8;\n            lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition;\n            lByteCount++;\n          }\n          lWordCount = (lByteCount - lByteCount % 4) / 4;\n          lBytePosition = lByteCount % 4 * 8;\n          lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition;\n          lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n          lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n          return lWordArray;\n        };\n        var wordToHex = function(lValue) {\n          var wordToHexValue = \"\", wordToHexValue_temp = \"\", lByte, lCount;\n          for (lCount = 0; lCount <= 3; lCount++) {\n            lByte = lValue >>> lCount * 8 & 255;\n            wordToHexValue_temp = \"0\" + lByte.toString(16);\n            wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);\n          }\n          return wordToHexValue;\n        };\n        var x = [], k, AA, BB, CC, DD, a, b, c, d, S11 = 7, S12 = 12, S13 = 17, S14 = 22, S21 = 5, S22 = 9, S23 = 14, S24 = 20, S31 = 4, S32 = 11, S33 = 16, S34 = 23, S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n        x = convertToWordArray(str);\n        a = 1732584193;\n        b = 4023233417;\n        c = 2562383102;\n        d = 271733878;\n        xl = x.length;\n        for (k = 0; k < xl; k += 16) {\n          AA = a;\n          BB = b;\n          CC = c;\n          DD = d;\n          a = _FF(a, b, c, d, x[k + 0], S11, 3614090360);\n          d = _FF(d, a, b, c, x[k + 1], S12, 3905402710);\n          c = _FF(c, d, a, b, x[k + 2], S13, 606105819);\n          b = _FF(b, c, d, a, x[k + 3], S14, 3250441966);\n          a = _FF(a, b, c, d, x[k + 4], S11, 4118548399);\n          d = _FF(d, a, b, c, x[k + 5], S12, 1200080426);\n          c = _FF(c, d, a, b, x[k + 6], S13, 2821735955);\n          b = _FF(b, c, d, a, x[k + 7], S14, 4249261313);\n          a = _FF(a, b, c, d, x[k + 8], S11, 1770035416);\n          d = _FF(d, a, b, c, x[k + 9], S12, 2336552879);\n          c = _FF(c, d, a, b, x[k + 10], S13, 4294925233);\n          b = _FF(b, c, d, a, x[k + 11], S14, 2304563134);\n          a = _FF(a, b, c, d, x[k + 12], S11, 1804603682);\n          d = _FF(d, a, b, c, x[k + 13], S12, 4254626195);\n          c = _FF(c, d, a, b, x[k + 14], S13, 2792965006);\n          b = _FF(b, c, d, a, x[k + 15], S14, 1236535329);\n          a = _GG(a, b, c, d, x[k + 1], S21, 4129170786);\n          d = _GG(d, a, b, c, x[k + 6], S22, 3225465664);\n          c = _GG(c, d, a, b, x[k + 11], S23, 643717713);\n          b = _GG(b, c, d, a, x[k + 0], S24, 3921069994);\n          a = _GG(a, b, c, d, x[k + 5], S21, 3593408605);\n          d = _GG(d, a, b, c, x[k + 10], S22, 38016083);\n          c = _GG(c, d, a, b, x[k + 15], S23, 3634488961);\n          b = _GG(b, c, d, a, x[k + 4], S24, 3889429448);\n          a = _GG(a, b, c, d, x[k + 9], S21, 568446438);\n          d = _GG(d, a, b, c, x[k + 14], S22, 3275163606);\n          c = _GG(c, d, a, b, x[k + 3], S23, 4107603335);\n          b = _GG(b, c, d, a, x[k + 8], S24, 1163531501);\n          a = _GG(a, b, c, d, x[k + 13], S21, 2850285829);\n          d = _GG(d, a, b, c, x[k + 2], S22, 4243563512);\n          c = _GG(c, d, a, b, x[k + 7], S23, 1735328473);\n          b = _GG(b, c, d, a, x[k + 12], S24, 2368359562);\n          a = _HH(a, b, c, d, x[k + 5], S31, 4294588738);\n          d = _HH(d, a, b, c, x[k + 8], S32, 2272392833);\n          c = _HH(c, d, a, b, x[k + 11], S33, 1839030562);\n          b = _HH(b, c, d, a, x[k + 14], S34, 4259657740);\n          a = _HH(a, b, c, d, x[k + 1], S31, 2763975236);\n          d = _HH(d, a, b, c, x[k + 4], S32, 1272893353);\n          c = _HH(c, d, a, b, x[k + 7], S33, 4139469664);\n          b = _HH(b, c, d, a, x[k + 10], S34, 3200236656);\n          a = _HH(a, b, c, d, x[k + 13], S31, 681279174);\n          d = _HH(d, a, b, c, x[k + 0], S32, 3936430074);\n          c = _HH(c, d, a, b, x[k + 3], S33, 3572445317);\n          b = _HH(b, c, d, a, x[k + 6], S34, 76029189);\n          a = _HH(a, b, c, d, x[k + 9], S31, 3654602809);\n          d = _HH(d, a, b, c, x[k + 12], S32, 3873151461);\n          c = _HH(c, d, a, b, x[k + 15], S33, 530742520);\n          b = _HH(b, c, d, a, x[k + 2], S34, 3299628645);\n          a = _II(a, b, c, d, x[k + 0], S41, 4096336452);\n          d = _II(d, a, b, c, x[k + 7], S42, 1126891415);\n          c = _II(c, d, a, b, x[k + 14], S43, 2878612391);\n          b = _II(b, c, d, a, x[k + 5], S44, 4237533241);\n          a = _II(a, b, c, d, x[k + 12], S41, 1700485571);\n          d = _II(d, a, b, c, x[k + 3], S42, 2399980690);\n          c = _II(c, d, a, b, x[k + 10], S43, 4293915773);\n          b = _II(b, c, d, a, x[k + 1], S44, 2240044497);\n          a = _II(a, b, c, d, x[k + 8], S41, 1873313359);\n          d = _II(d, a, b, c, x[k + 15], S42, 4264355552);\n          c = _II(c, d, a, b, x[k + 6], S43, 2734768916);\n          b = _II(b, c, d, a, x[k + 13], S44, 1309151649);\n          a = _II(a, b, c, d, x[k + 4], S41, 4149444226);\n          d = _II(d, a, b, c, x[k + 11], S42, 3174756917);\n          c = _II(c, d, a, b, x[k + 2], S43, 718787259);\n          b = _II(b, c, d, a, x[k + 9], S44, 3951481745);\n          a = addUnsigned(a, AA);\n          b = addUnsigned(b, BB);\n          c = addUnsigned(c, CC);\n          d = addUnsigned(d, DD);\n        }\n        var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n        return temp.toLowerCase();\n      }\n    };\n    return md5;\n  } ]);\n})(angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-md5/angular-md5.js\n ** module id = 5\n ** module chunks = 0 1\n **/","/**\n * @license AngularJS v1.5.6\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar $resourceMinErr = angular.$$minErr('$resource');\n\n// Helper functions and regex to lookup a dotted path on an object\n// stopping at undefined/null.  The path must be composed of ASCII\n// identifiers (just like $parse)\nvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\nfunction isValidDottedPath(path) {\n  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n      MEMBER_NAME_REGEX.test('.' + path));\n}\n\nfunction lookupDottedPath(obj, path) {\n  if (!isValidDottedPath(path)) {\n    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n  }\n  var keys = path.split('.');\n  for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {\n    var key = keys[i];\n    obj = (obj !== null) ? obj[key] : undefined;\n  }\n  return obj;\n}\n\n/**\n * Create a shallow copy of an object and clear other fields from the destination\n */\nfunction shallowClearAndCopy(src, dst) {\n  dst = dst || {};\n\n  angular.forEach(dst, function(value, key) {\n    delete dst[key];\n  });\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n/**\n * @ngdoc module\n * @name ngResource\n * @description\n *\n * # ngResource\n *\n * The `ngResource` module provides interaction support with RESTful services\n * via the $resource service.\n *\n *\n * <div doc-module-components=\"ngResource\"></div>\n *\n * See {@link ngResource.$resource `$resource`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $resource\n * @requires $http\n * @requires ng.$log\n * @requires $q\n * @requires ng.$timeout\n *\n * @description\n * A factory which creates a resource object that lets you interact with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n *\n * The returned resource object has action methods which provide high-level behaviors without\n * the need to interact with the low level {@link ng.$http $http} service.\n *\n * Requires the {@link ngResource `ngResource`} module to be installed.\n *\n * By default, trailing slashes will be stripped from the calculated URLs,\n * which can pose problems with server backends that do not expect that\n * behavior.  This can be disabled by configuring the `$resourceProvider` like\n * this:\n *\n * ```js\n     app.config(['$resourceProvider', function($resourceProvider) {\n       // Don't strip trailing slashes from calculated URLs\n       $resourceProvider.defaults.stripTrailingSlashes = false;\n     }]);\n * ```\n *\n * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n *   `/user/:username`. If you are using a URL with a port number (e.g.\n *   `http://example.com:8080/api`), it will be respected.\n *\n *   If you are using a url with a suffix, just add the suffix, like this:\n *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n *   can escape it with `/\\.`.\n *\n * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n *   `actions` methods. If a parameter value is a function, it will be executed every time\n *   when a param value needs to be obtained for a request (unless the param was overridden).\n *\n *   Each key value in the parameter object is first bound to url template if present and then any\n *   excess keys are appended to the url search query after the `?`.\n *\n *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n *   URL `/path/greet?salutation=Hello`.\n *\n *   If the parameter value is prefixed with `@` then the value for that parameter will be extracted\n *   from the corresponding property on the `data` object (provided when calling an action method).\n *   For example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of\n *   `someParam` will be `data.someProp`.\n *\n * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n *   the default set of resource actions. The declaration should be created in the format of {@link\n *   ng.$http#usage $http.config}:\n *\n *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n *        ...}\n *\n *   Where:\n *\n *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n *     your resource object.\n *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n *     `DELETE`, `JSONP`, etc).\n *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n *     the parameter value is a function, it will be executed every time when a param value needs to\n *     be obtained for a request (unless the param was overridden).\n *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n *     like for the resource-level urls.\n *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n *     see `returns` section.\n *   - **`transformRequest`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     request body and headers and returns its transformed (typically serialized) version.\n *     By default, transformRequest will contain one function that checks if the request data is\n *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n *     `transformRequest` to an empty array: `transformRequest: []`\n *   - **`transformResponse`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     response body and headers and returns its transformed (typically deserialized) version.\n *     By default, transformResponse will contain one function that checks if the response looks\n *     like a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior,\n *     set `transformResponse` to an empty array: `transformResponse: []`\n *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n *     GET request, otherwise if a cache instance built with\n *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n *     caching.\n *   - **`timeout`** – `{number}` – timeout in milliseconds.<br />\n *     **Note:** In contrast to {@link ng.$http#usage $http.config}, {@link ng.$q promises} are\n *     **not** supported in $resource, because the same value would be used for multiple requests.\n *     If you are looking for a way to cancel requests, you should use the `cancellable` option.\n *   - **`cancellable`** – `{boolean}` – if set to true, the request made by a \"non-instance\" call\n *     will be cancelled (if not already completed) by calling `$cancelRequest()` on the call's\n *     return value. Calling `$cancelRequest()` for a non-cancellable or an already\n *     completed/cancelled request will have no effect.<br />\n *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n *     XHR object. See\n *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n *     for more information.\n *   - **`responseType`** - `{string}` - see\n *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n *     with `http response` object. See {@link ng.$http $http interceptors}.\n *\n * @param {Object} options Hash with custom settings that should extend the\n *   default `$resourceProvider` behavior.  The supported options are:\n *\n *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n *   slashes from any calculated URL will be stripped. (Defaults to true.)\n *   - **`cancellable`** – {boolean} – If true, the request made by a \"non-instance\" call will be\n *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return value.\n *   This can be overwritten per action. (Defaults to false.)\n *\n * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n *   optionally extended with custom `actions`. The default set contains these actions:\n *   ```js\n *   { 'get':    {method:'GET'},\n *     'save':   {method:'POST'},\n *     'query':  {method:'GET', isArray:true},\n *     'remove': {method:'DELETE'},\n *     'delete': {method:'DELETE'} };\n *   ```\n *\n *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n *   destination and parameters. When the data is returned from the server then the object is an\n *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n *   read, update, delete) on server-side data like this:\n *   ```js\n *   var User = $resource('/user/:userId', {userId:'@id'});\n *   var user = User.get({userId:123}, function() {\n *     user.abc = true;\n *     user.$save();\n *   });\n *   ```\n *\n *   It is important to realize that invoking a $resource object method immediately returns an\n *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n *   server the existing reference is populated with the actual data. This is a useful trick since\n *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n *   object results in no rendering, once the data arrives from the server then the object is\n *   populated with the data and the view automatically re-renders itself showing the new data. This\n *   means that in most cases one never has to write a callback function for the action methods.\n *\n *   The action methods on the class object or instance object can be invoked with the following\n *   parameters:\n *\n *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n *\n *\n *   Success callback is called with (value, responseHeaders) arguments, where the value is\n *   the populated resource instance or collection object. The error callback is called\n *   with (httpResponse) argument.\n *\n *   Class actions return empty instance (with additional properties below).\n *   Instance actions return promise of the action.\n *\n *   The Resource instances and collections have these additional properties:\n *\n *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n *     instance or collection.\n *\n *     On success, the promise is resolved with the same resource instance or collection object,\n *     updated with data from server. This makes it easy to use in\n *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n *     rendering until the resource(s) are loaded.\n *\n *     On failure, the promise is rejected with the {@link ng.$http http response} object, without\n *     the `resource` property.\n *\n *     If an interceptor object was provided, the promise will instead be resolved with the value\n *     returned by the interceptor.\n *\n *   - `$resolved`: `true` after first server interaction is completed (either with success or\n *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n *      data-binding.\n *\n *   The Resource instances and collections have these additional methods:\n *\n *   - `$cancelRequest`: If there is a cancellable, pending request related to the instance or\n *      collection, calling this method will abort the request.\n *\n * @example\n *\n * # Credit card resource\n *\n * ```js\n     // Define CreditCard class\n     var CreditCard = $resource('/user/:userId/card/:cardId',\n      {userId:123, cardId:'@id'}, {\n       charge: {method:'POST', params:{charge:true}}\n      });\n\n     // We can retrieve a collection from the server\n     var cards = CreditCard.query(function() {\n       // GET: /user/123/card\n       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n       var card = cards[0];\n       // each item is an instance of CreditCard\n       expect(card instanceof CreditCard).toEqual(true);\n       card.name = \"J. Smith\";\n       // non GET methods are mapped onto the instances\n       card.$save();\n       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n       // our custom method is mapped as well.\n       card.$charge({amount:9.99});\n       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n     });\n\n     // we can create an instance as well\n     var newCard = new CreditCard({number:'0123'});\n     newCard.name = \"Mike Smith\";\n     newCard.$save();\n     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n     expect(newCard.id).toEqual(789);\n * ```\n *\n * The object returned from this function execution is a resource \"class\" which has \"static\" method\n * for each action in the definition.\n *\n * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n * `headers`.\n *\n * @example\n *\n * # User resource\n *\n * When the data is returned from the server then the object is an instance of the resource type and\n * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n * operations (create, read, update, delete) on server-side data.\n\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user) {\n       user.abc = true;\n       user.$save();\n     });\n   ```\n *\n * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n * in the response that came from the server as well as $http header getter function, so one\n * could rewrite the above example and get access to http headers as:\n *\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user, getResponseHeaders){\n       user.abc = true;\n       user.$save(function(user, putResponseHeaders) {\n         //user => saved user object\n         //putResponseHeaders => $http header getter\n       });\n     });\n   ```\n *\n * You can also access the raw `$http` promise via the `$promise` property on the object returned\n *\n   ```\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123})\n         .$promise.then(function(user) {\n           $scope.user = user;\n         });\n   ```\n *\n * @example\n *\n * # Creating a custom 'PUT' request\n *\n * In this example we create a custom method on our resource to make a PUT request\n * ```js\n *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n *\n *    // Some APIs expect a PUT request in the format URL/object/ID\n *    // Here we are creating an 'update' method\n *    app.factory('Notes', ['$resource', function($resource) {\n *    return $resource('/notes/:id', null,\n *        {\n *            'update': { method:'PUT' }\n *        });\n *    }]);\n *\n *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n *    // We pass in $routeParams and our Notes factory along with $scope\n *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n                                      function($scope, $routeParams, Notes) {\n *    // First get a note object from the factory\n *    var note = Notes.get({ id:$routeParams.id });\n *    $id = note.id;\n *\n *    // Now call update passing in the ID first then the object you are updating\n *    Notes.update({ id:$id }, note);\n *\n *    // This will PUT /notes/ID with the note object in the request payload\n *    }]);\n * ```\n *\n * @example\n *\n * # Cancelling requests\n *\n * If an action's configuration specifies that it is cancellable, you can cancel the request related\n * to an instance or collection (as long as it is a result of a \"non-instance\" call):\n *\n   ```js\n     // ...defining the `Hotel` resource...\n     var Hotel = $resource('/api/hotel/:id', {id: '@id'}, {\n       // Let's make the `query()` method cancellable\n       query: {method: 'get', isArray: true, cancellable: true}\n     });\n\n     // ...somewhere in the PlanVacationController...\n     ...\n     this.onDestinationChanged = function onDestinationChanged(destination) {\n       // We don't care about any pending request for hotels\n       // in a different destination any more\n       this.availableHotels.$cancelRequest();\n\n       // Let's query for hotels in '<destination>'\n       // (calls: /api/hotel?location=<destination>)\n       this.availableHotels = Hotel.query({location: destination});\n     };\n   ```\n *\n */\nangular.module('ngResource', ['ng']).\n  provider('$resource', function() {\n    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\\/\\/[^\\/]*/;\n    var provider = this;\n\n    this.defaults = {\n      // Strip slashes by default\n      stripTrailingSlashes: true,\n\n      // Default actions configuration\n      actions: {\n        'get': {method: 'GET'},\n        'save': {method: 'POST'},\n        'query': {method: 'GET', isArray: true},\n        'remove': {method: 'DELETE'},\n        'delete': {method: 'DELETE'}\n      }\n    };\n\n    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {\n\n      var noop = angular.noop,\n        forEach = angular.forEach,\n        extend = angular.extend,\n        copy = angular.copy,\n        isFunction = angular.isFunction;\n\n      /**\n       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n       * (pchar) allowed in path segments:\n       *    segment       = *pchar\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriSegment(val) {\n        return encodeUriQuery(val, true).\n          replace(/%26/gi, '&').\n          replace(/%3D/gi, '=').\n          replace(/%2B/gi, '+');\n      }\n\n\n      /**\n       * This method is intended for encoding *key* or *value* parts of query component. We need a\n       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n       *    query       = *( pchar / \"/\" / \"?\" )\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriQuery(val, pctEncodeSpaces) {\n        return encodeURIComponent(val).\n          replace(/%40/gi, '@').\n          replace(/%3A/gi, ':').\n          replace(/%24/g, '$').\n          replace(/%2C/gi, ',').\n          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n      }\n\n      function Route(template, defaults) {\n        this.template = template;\n        this.defaults = extend({}, provider.defaults, defaults);\n        this.urlParams = {};\n      }\n\n      Route.prototype = {\n        setUrlParams: function(config, params, actionUrl) {\n          var self = this,\n            url = actionUrl || self.template,\n            val,\n            encodedVal,\n            protocolAndDomain = '';\n\n          var urlParams = self.urlParams = {};\n          forEach(url.split(/\\W/), function(param) {\n            if (param === 'hasOwnProperty') {\n              throw $resourceMinErr('badname', \"hasOwnProperty is not a valid parameter name.\");\n            }\n            if (!(new RegExp(\"^\\\\d+$\").test(param)) && param &&\n              (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n              urlParams[param] = {\n                isQueryParamValue: (new RegExp(\"\\\\?.*=:\" + param + \"(?:\\\\W|$)\")).test(url)\n              };\n            }\n          });\n          url = url.replace(/\\\\:/g, ':');\n          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {\n            protocolAndDomain = match;\n            return '';\n          });\n\n          params = params || {};\n          forEach(self.urlParams, function(paramInfo, urlParam) {\n            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n            if (angular.isDefined(val) && val !== null) {\n              if (paramInfo.isQueryParamValue) {\n                encodedVal = encodeUriQuery(val, true);\n              } else {\n                encodedVal = encodeUriSegment(val);\n              }\n              url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match, p1) {\n                return encodedVal + p1;\n              });\n            } else {\n              url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n                  leadingSlashes, tail) {\n                if (tail.charAt(0) == '/') {\n                  return tail;\n                } else {\n                  return leadingSlashes + tail;\n                }\n              });\n            }\n          });\n\n          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n          if (self.defaults.stripTrailingSlashes) {\n            url = url.replace(/\\/+$/, '') || '/';\n          }\n\n          // then replace collapse `/.` if found in the last URL path segment before the query\n          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n          // replace escaped `/\\.` with `/.`\n          config.url = protocolAndDomain + url.replace(/\\/\\\\\\./, '/.');\n\n\n          // set params - delegate param encoding to $http\n          forEach(params, function(value, key) {\n            if (!self.urlParams[key]) {\n              config.params = config.params || {};\n              config.params[key] = value;\n            }\n          });\n        }\n      };\n\n\n      function resourceFactory(url, paramDefaults, actions, options) {\n        var route = new Route(url, options);\n\n        actions = extend({}, provider.defaults.actions, actions);\n\n        function extractParams(data, actionParams) {\n          var ids = {};\n          actionParams = extend({}, paramDefaults, actionParams);\n          forEach(actionParams, function(value, key) {\n            if (isFunction(value)) { value = value(); }\n            ids[key] = value && value.charAt && value.charAt(0) == '@' ?\n              lookupDottedPath(data, value.substr(1)) : value;\n          });\n          return ids;\n        }\n\n        function defaultResponseInterceptor(response) {\n          return response.resource;\n        }\n\n        function Resource(value) {\n          shallowClearAndCopy(value || {}, this);\n        }\n\n        Resource.prototype.toJSON = function() {\n          var data = extend({}, this);\n          delete data.$promise;\n          delete data.$resolved;\n          return data;\n        };\n\n        forEach(actions, function(action, name) {\n          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n          var numericTimeout = action.timeout;\n          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :\n              (options && angular.isDefined(options.cancellable)) ? options.cancellable :\n              provider.defaults.cancellable;\n\n          if (numericTimeout && !angular.isNumber(numericTimeout)) {\n            $log.debug('ngResource:\\n' +\n                       '  Only numeric values are allowed as `timeout`.\\n' +\n                       '  Promises are not supported in $resource, because the same value would ' +\n                       'be used for multiple requests. If you are looking for a way to cancel ' +\n                       'requests, you should use the `cancellable` option.');\n            delete action.timeout;\n            numericTimeout = null;\n          }\n\n          Resource[name] = function(a1, a2, a3, a4) {\n            var params = {}, data, success, error;\n\n            /* jshint -W086 */ /* (purposefully fall through case statements) */\n            switch (arguments.length) {\n              case 4:\n                error = a4;\n                success = a3;\n              //fallthrough\n              case 3:\n              case 2:\n                if (isFunction(a2)) {\n                  if (isFunction(a1)) {\n                    success = a1;\n                    error = a2;\n                    break;\n                  }\n\n                  success = a2;\n                  error = a3;\n                  //fallthrough\n                } else {\n                  params = a1;\n                  data = a2;\n                  success = a3;\n                  break;\n                }\n              case 1:\n                if (isFunction(a1)) success = a1;\n                else if (hasBody) data = a1;\n                else params = a1;\n                break;\n              case 0: break;\n              default:\n                throw $resourceMinErr('badargs',\n                  \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\",\n                  arguments.length);\n            }\n            /* jshint +W086 */ /* (purposefully fall through case statements) */\n\n            var isInstanceCall = this instanceof Resource;\n            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n            var httpConfig = {};\n            var responseInterceptor = action.interceptor && action.interceptor.response ||\n              defaultResponseInterceptor;\n            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n              undefined;\n            var timeoutDeferred;\n            var numericTimeoutPromise;\n\n            forEach(action, function(value, key) {\n              switch (key) {\n                default:\n                  httpConfig[key] = copy(value);\n                  break;\n                case 'params':\n                case 'isArray':\n                case 'interceptor':\n                case 'cancellable':\n                  break;\n              }\n            });\n\n            if (!isInstanceCall && cancellable) {\n              timeoutDeferred = $q.defer();\n              httpConfig.timeout = timeoutDeferred.promise;\n\n              if (numericTimeout) {\n                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);\n              }\n            }\n\n            if (hasBody) httpConfig.data = data;\n            route.setUrlParams(httpConfig,\n              extend({}, extractParams(data, action.params || {}), params),\n              action.url);\n\n            var promise = $http(httpConfig).then(function(response) {\n              var data = response.data;\n\n              if (data) {\n                // Need to convert action.isArray to boolean in case it is undefined\n                // jshint -W018\n                if (angular.isArray(data) !== (!!action.isArray)) {\n                  throw $resourceMinErr('badcfg',\n                      'Error in resource configuration for action `{0}`. Expected response to ' +\n                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n                }\n                // jshint +W018\n                if (action.isArray) {\n                  value.length = 0;\n                  forEach(data, function(item) {\n                    if (typeof item === \"object\") {\n                      value.push(new Resource(item));\n                    } else {\n                      // Valid JSON values may be string literals, and these should not be converted\n                      // into objects. These items will not have access to the Resource prototype\n                      // methods, but unfortunately there\n                      value.push(item);\n                    }\n                  });\n                } else {\n                  var promise = value.$promise;     // Save the promise\n                  shallowClearAndCopy(data, value);\n                  value.$promise = promise;         // Restore the promise\n                }\n              }\n              response.resource = value;\n\n              return response;\n            }, function(response) {\n              (error || noop)(response);\n              return $q.reject(response);\n            });\n\n            promise['finally'](function() {\n              value.$resolved = true;\n              if (!isInstanceCall && cancellable) {\n                value.$cancelRequest = angular.noop;\n                $timeout.cancel(numericTimeoutPromise);\n                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;\n              }\n            });\n\n            promise = promise.then(\n              function(response) {\n                var value = responseInterceptor(response);\n                (success || noop)(value, response.headers);\n                return value;\n              },\n              responseErrorInterceptor);\n\n            if (!isInstanceCall) {\n              // we are creating instance / collection\n              // - set the initial promise\n              // - return the instance / collection\n              value.$promise = promise;\n              value.$resolved = false;\n              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;\n\n              return value;\n            }\n\n            // instance call\n            return promise;\n          };\n\n\n          Resource.prototype['$' + name] = function(params, success, error) {\n            if (isFunction(params)) {\n              error = success; success = params; params = {};\n            }\n            var result = Resource[name].call(this, params, this, success, error);\n            return result.$promise || result;\n          };\n        });\n\n        Resource.bind = function(additionalParamDefaults) {\n          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n        };\n\n        return Resource;\n      }\n\n      return resourceFactory;\n    }];\n  });\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-resource/angular-resource.js\n ** module id = 6\n ** module chunks = 0 1\n **/","require('./angular-resource');\nmodule.exports = 'ngResource';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-resource/index.js\n ** module id = 7\n ** module chunks = 0 1\n **/","/**\n * State-based routing for AngularJS\n * @version v0.3.0\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            result.$$resolveAs = view.resolveAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .constant(\"$state.runtime\", { autoinject: true })\n  .provider('$state', $StateProvider)\n  // Inject $state to initialize when entering runtime. #2574\n  .run(['$injector', function ($injector) {\n    // Allow tests (stateSpec.js) to turn this off by defining this constant\n    if ($injector.get(\"$state.runtime\").autoinject) {\n      $injector.get('$state');\n    }\n  }]);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @example\n * A view can be unnamed or named.\n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#methods_state `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre>\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * </pre>\n *\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * Example usage of $resolve in a view template\n * <pre>\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate,   $q) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope),\n            inherited     = $element.inheritedData('$uiView');\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            var $uiViewData = currentEl.data('$uiView');\n            renderer.leave(currentEl, function() {\n              $uiViewData.$$animLeave.resolve();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, inherited, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            var animEnter = $q.defer(), animLeave = $q.defer();\n            var viewData = {\n              name: name,\n              $animEnter: animEnter.promise,\n              $animLeave: animLeave.promise,\n              $$animLeave: animLeave\n            };\n\n            renderer.enter(clone.data('$uiView', viewData), $element, function onUiViewEnter() {\n              animEnter.resolve();\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            $uiViewData = $element.data('$uiView'),\n            locals  = current && current.locals[$uiViewData.name];\n\n        if (! locals) {\n          return;\n        }\n\n        extend($uiViewData, { state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var resolveData = angular.extend({}, locals);\n        scope[locals.$$resolveAs] = resolveData;\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n            scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;\n          }\n          if (isFunction(controller.$onInit)) controller.$onInit();\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, inherited, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element.bind(\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element.unbind(\"click\", hookFn);\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#methods_href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#methods_go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n      var unlinkInfoFn = null;\n      var hookFn;\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (unlinkInfoFn) unlinkInfoFn();\n        if (active) unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      hookFn = clickHook(element, $state, $timeout, type, function() { return def; });\n      element.bind(\"click\", hookFn);\n      scope.$on('$destroy', function() {\n        element.unbind(\"click\", hookFn);\n      });\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        var deregister = addState(newState, newParams, uiSrefActive);\n        update();\n        return deregister;\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        var stateInfo = {\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        };\n\n        states.push(stateInfo);\n        activeClasses[stateHash] = activeClass;\n\n        return function removeState() {\n          var idx = states.indexOf(stateInfo);\n          if (idx !== -1) states.splice(idx, 1);\n        };\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-ui-router/release/angular-ui-router.js\n ** module id = 8\n ** module chunks = 0 1\n **/","/**\n * Created by scofield on 5/31/16.\n */\n\"use strict\";\nimport app from '../app';\n\nimport \"../libs/consts\";\nimport \"../libs/tools\";\nimport \"../models/todoModel\";\n\n/**\n * todo todo的一些controller\n */\napp.controller(\"todoController\",[\"$scope\",\"$window\",\"todoTools\",\"todoModel\",\"$state\",\"$stateParams\",\"todo-consts\",function($scope,$window,todoTools,todoModel,$state,$stateParams,todoConsts){\n    // 用户的todo列表\n    $scope.todoList = [];\n    // 用户的todo列表(\n    $scope.filterList = [];\n\n    // 用户待完成数量\n    $scope.todoNum = 0;\n\n    $scope.title = \"新建\";\n\n    // 默认的新建todo\n    $scope.newTodo = {};\n\n    // 待完成todo数量\n    $scope.unfinishNum = 0;\n\n    /**\n     * 初始化新建todo对象\n     */\n    $scope.initNewTodo = () => {\n        $scope.newTodo = {\n            todo_name:todoConsts.DEFAULT_TODONAME,\n            userid:todoTools.userInfo.userid() == 0 ? 1 : parseInt(todoTools.userInfo.userid()),\n            categoryid:todoConsts.DEFAULT_CATEGORYID,\n            status:todoConsts.DEFAULT_TODOSTATUS,\n            remark:\"\"\n        };\n    };\n\n    // 状态列表\n    $scope.todoStatusCateogries = todoConsts.TODO_CATEGORYLIST;\n    $scope.currentStatus = todoConsts.TODO_CATEGORYLIST[0].id;\n\n    // 是否正在载入中\n    $scope.loading = true;\n\n    $scope.stateParams = $stateParams;\n\n    $scope.validate = {\n        msg:\"\",\n        error:{\n            todo_name:false,\n            remark:false,\n            start_time:false,\n            end_time:false\n        }\n    };\n\n    /**\n     * 获取todo列表\n     */\n    $scope.fetchList = () => {\n        if(todoTools.userInfo.userid() != 0) {\n            todoModel.list(todoTools.userInfo.userid).then(function(data){\n                $scope.loading = false;\n                $scope.filterList = $scope.todoList = data.list;\n                for(let i=0,len=$scope.todoList.length;i<len;i++) {\n                    if(data.list[i].status != 2) {\n                        $scope.unfinishNum += 1;\n                    }\n                }\n            },function(){\n                $scope.loading = false;\n            });\n        }\n    };\n\n    /**\n     * 选择某一个setStatus的状态\n     * @param status\n     */\n    $scope.filterStatusList  = (status) => {\n        $scope.currentStatus = status;\n        $scope.filterList = $scope.todoList.filter( (item) => {\n            switch($scope.currentStatus) {\n                case 0:\n                    return true;\n                case 1:\n                    return item.status == 2;\n                case 2:\n                default:\n                    return item.status == 0;\n            }\n        });\n    };\n\n    /**\n     * 获取详情\n     */\n    $scope.getDetail = () => {\n        if(typeof $stateParams.todoid != 'undefined') {\n            $scope.title = \"编辑\";\n            todoModel.detail({\n                userid: todoTools.userInfo.userid(),\n                id:$stateParams.todoid\n            }).then( (data) => {\n                $scope.newTodo = data;\n                if ($scope.newTodo.start_time != 0 ) {\n                    $scope.newTodo.start_time = new Date($scope.newTodo.start_time * 1000);\n                }\n                if ($scope.newTodo.end_time != 0 ) {\n                    $scope.newTodo.end_time = new Date($scope.newTodo.end_time * 1000);\n                }\n            }, (response) => {\n                let errMsg = \"请求错误\";\n                if(typeof response.data == 'object' && typeof response.data.errmsg != 'undefined') {\n                    errMsg = response.data.errmsg + \"(错误代码:\" + response.data.errcode + \")\";\n                }\n                $window.alert(errMsg);\n                $state.go(\"todo.list\");\n            });\n        } else {\n            $scope.initNewTodo();\n            $scope.title = \"新建\";\n        }\n    };\n\n    /**\n     * 跳转到todo详情\n     * @param todoid\n     */\n    $scope.directToDetail = (todoid) => {\n        $state.go('todo.edit',{\n            userid:todoTools.userInfo.userid(),\n            todoid:todoid\n        });\n    };\n\n    /**\n     * 添加一个todo\n     */\n    $scope.saveTodo = () => {\n        if($scope.newTodo.todo_name.length<3|| $scope.newTodo.todo_name.length>30) {\n            $scope.validate.msg = \"TODO名称长度不合法:3-30个字符之间!\";\n            $scope.validate.error.todo_name = true;\n            return;\n        }\n\n        let startTimeStamp = 0,\n            endTimestamp = 0;\n\n        startTimeStamp = parseInt(Date.parse(new Date($scope.newTodo.start_time)) / 1000);\n        endTimestamp = parseInt(Date.parse(new Date($scope.newTodo.end_time)) / 1000);\n        \n        if (startTimeStamp != 0 && endTimestamp != 0) {\n            if (startTimeStamp > endTimestamp) {\n                $scope.validate.error.start_time = true;\n                $scope.validate.error.end_time = true;\n                $scope.validate.msg = \"最晚时间不能小于开始时间\";\n                return;\n            }\n        }\n\n        $scope.newTodo.start_time = startTimeStamp;\n        $scope.newTodo.end_time = endTimestamp;\n\n        let promise = null;\n        if(typeof $stateParams.todoid != 'undefined') {\n            promise = todoModel.update($scope.newTodo);\n        } else {\n            promise = todoModel.insert($scope.newTodo);\n        }\n\n        promise.then((data)=>{\n            $scope.validate.msg = \"\";\n            $scope.validate.error.todo_name = false;\n            $scope.validate.error.remark = false;\n            $scope.todoList.splice(0,0,data);\n            $state.go(\"todo.list\");\n        },(resp)=>{\n            if(resp.status == 401) {\n                $state.go(\"login\");\n                return;\n            }\n            $scope.validate.msg = \"\";\n            $scope.validate.error.todo_name = false;\n            $scope.validate.error.remark = false;\n            $window.alert(resp.data.errmsg);\n        });\n    };\n\n    /**\n     * 更新todo状态\n     * @param todoid\n     */\n    $scope.updateStatus = (todoid) => {\n        console.log(todoid);\n        let todoItem = $scope.filterList.find((item) => {\n            if (item.id == todoid) {\n                item.status = item.status == 2 ? 0 : 2;\n                if(item.status==2){\n                    $scope.unfinishNum--;\n                } else {\n                    $scope.unfinishNum++;\n                }\n            }\n            return item.id === todoid;\n        });\n\n        todoModel.update(todoItem).then( (data) => {\n        }, (response) => {\n            if(response.status == 401) {\n                $state.go(\"login\");\n                return;\n            }\n            $window.alert(response.data.errmsg);\n        });\n    };\n\n    /**\n     * 删除一个todo\n     * @param todoid\n     */\n    $scope.deleteTodo = (todoid) => {\n        if(!$window.confirm(\"确定要删除该条todo?\")){\n            return;\n        }\n        todoModel.delete({\n            userid:todoTools.userInfo.userid(),\n            id:todoid\n        }).then( (data) => {\n            $state.go(\"todo.list\");\n        }, (response) => {\n            if(response.status == 401) {\n                $state.go(\"login\");\n                return;\n            }\n            let errMsg = \"请求错误\";\n            if(typeof response.data == 'object' && typeof response.data.errmsg != 'undefined') {\n                errMsg = response.data.errmsg + \"(错误代码:\" + response.data.errcode + \")\";\n            }\n            $window.alert(errMsg);\n        });\n    };\n\n    /**\n     * 时间戳转日期\n     * @param timestamp\n     * @returns {string}\n     */\n    $scope.timestampToDate = (timestamp) => {\n        let dateObj = new Date(timestamp*1000),\n            date = \"\";\n\n        date = dateObj.getFullYear();\n        date += \"-\" + (parseInt(dateObj.getMonth())+1);\n        date += \"-\" + dateObj.getDate();\n        return date;\n    };\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./controllers/todoController.js\n **/","/**\n * Created by scofield on 5/31/16.\n */\n'use strict';\n\nimport app from \"../app.js\";\nimport \"../models/userModel\";\nimport \"../libs/tools\";\n\n/**\n * userController 用户相关的controller\n */\napp.controller(\"userController\",[\"$scope\",\"userModel\",\"md5\",\"$state\",\"todoTools\",function($scope,userModel,md5,$state,todoTools){\n    // 用户信息\n    $scope.userInfo = {\n        userid:0,\n        user_name:\"\",\n        create_time:0,\n        last_login:0,\n        unfinish_num:0\n    };\n\n    // 用户登录信息相关\n    $scope.userLoginInfo = {\n        user_name:\"\",\n        password:\"\"\n    };\n\n    $scope.validate = {\n        msg:'',\n        error:{\n            user_name:false,\n            password:false\n        }\n    };\n\n    // 错误提示\n    $scope.errMsg = \"\";\n\n    // 用户登录\n    $scope.login = () => {\n        // 验证用户信息\n        if( !/^[a-zA-Z0-9]{6,16}$/.test($scope.userLoginInfo.user_name) ) {\n            $scope.validate.msg = \"请输入正确的用户名(长度6-16位)\";\n            $scope.validate.error.user_name = true;\n            return;\n        }\n        if( $scope.userLoginInfo.password.length < 6 || $scope.userLoginInfo.password.length > 16 ) {\n            $scope.validate.msg = \"密码长度在6-16位之间\";\n            $scope.validate.error.password = true;\n            return;\n        }\n\n        let loginInfo = {\n            user_name:$scope.userLoginInfo.user_name,\n            password:md5.createHash($scope.userLoginInfo.password)\n        };\n\n        userModel.login(loginInfo).then((data) => {\n            $scope.validate.msg = '';\n            $scope.validate.error.user_name = false;\n            $scope.validate.error.password = false;\n\n            todoTools.userInfo.save(data);\n\n            $state.go(\"todo.list\");\n        }, (response) => {\n            $scope.validate.error.user_name = false;\n            $scope.validate.error.password = false;\n            $scope.validate.msg = response.data.errmsg + \"(\" + \"错误代码:\" + response.data.errcode + \")\";\n        });\n    };\n    \n    if(todoTools.isLogin()) {\n        $state.go(\"todo.list\");\n    }\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./controllers/userController.js\n **/","/**\n * Created by scofield on 6/5/16.\n */\n\n'use strict';\n\nimport app from \"../app\";\n\napp.factory(\"todo-consts\",function(){\n    let consts = {\n        DEFAULT_CATEGORYID:0, // 默认的categoryid\n        DEFAULT_TODONAME:\"\",\n        DEFAULT_TODOSTATUS:0, // 默认新建状态\n        TODO_CATEGORYLIST :[\n            {\n                id:0,\n                name:\"全部\"\n            },\n            {\n                id:1,\n                name:\"已完成\"\n            },\n            {\n                id:2,\n                name:\"待完成\"\n            }\n        ] // 默认的todo状态列表\n    };\n\n    return consts;\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./libs/consts.js\n **/","/**\n * Created by scofield on 5/31/16.\n */\n'use strict';\n\nimport app from \"../app\";\nimport \"../libs/tools\";\n\n/**\n * todoModel 关于todo的model操作\n */\napp.factory(\"todoModel\",[\"$resource\",\"todoTools\",function($resource,todoTools){\n    return {\n        /**\n         * 获取列表信息\n         *\n         * @param userid\n         * @returns {*|Function}\n         */\n        list:function(userid) {\n            return $resource(todoTools.apiUrl('todo/:userid'),{userid:userid}).get().$promise;\n        },\n        /**\n         * 插入一个新的todo数据\n         * @param data\n         */\n        insert:function(data) {\n            return $resource(todoTools.apiUrl('todo/:userid'),{userid:data.userid}).save(data).$promise;\n        },\n        /**\n         * 更新一条todo\n         * @param data\n         */\n        update:function(data) {\n            return $resource(todoTools.apiUrl('todo/:userid/:todoid'),{userid:data.userid,todoid:data.id}).update(data).$promise;\n        },\n        /**\n         * 删除一条todo\n         * @param data\n         */\n        delete:function(data) {\n            return $resource(todoTools.apiUrl('todo/:userid/:todoid'),{userid:data.userid,todoid:data.id}).delete().$promise;\n        },\n        /**\n         * 获取某todo详情\n         * @param data\n         * @returns {*|Function}\n         */\n        detail:function(data) {\n            return $resource(todoTools.apiUrl('todo/:userid/:todoid'),{userid:data.userid,todoid:data.id}).get().$promise;\n        }\n    }\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./models/todoModel.js\n **/","/**\n * Created by scofield on 5/31/16.\n */\n'use strict';\n\nimport app from \"../app\";\nimport \"../libs/tools\";\n\n/**\n * userModel 关于user的一些model\n */\napp.factory(\"userModel\",[\"$resource\",\"todoTools\",function ($resource,todoTools) {\n    return {\n        /**\n         * 用户登录\n         * @param data\n         * @returns {*|Function}\n         */\n        login:function(data) {\n            return $resource(todoTools.apiUrl('login')).save(data).$promise;\n        }\n    }\n}]);\n\n\n/** WEBPACK FOOTER **\n ** ./models/userModel.js\n **/","/**\n * Created by scofield on 5/31/16.\n */\n'use strict';\n\nimport app from \"./app\";\n\nimport \"./controllers/todoController\";\nimport \"./controllers/userController\";\n\nimport \"./libs/tools\";\n\napp.config([\"$stateProvider\",\"$urlRouterProvider\",function($stateProvider,$urlRouterProvider){\n    $urlRouterProvider.otherwise(\"/todo/list\");\n\n    $stateProvider\n    // todo列表\n    .state('todo',{\n        abstract:true,\n        url:\"/todo\",\n        template:\"<div ui-view></div>\"\n    })\n    .state('todo.list',{\n        url:\"/list\",\n        templateUrl:\"/statics/tpls/todo/list.html\",\n        controller:\"todoController\"\n    })\n    // todo详情\n    .state('todo.detail',{\n        url:\"/detail/:todoid\",\n        templateUrl:'/statics/tpls/todo/detail.html',\n        controller:\"todoController\"\n    })\n    // todo新建\n    .state('todo.insert',{\n        url:'/insert',\n        templateUrl:'/statics/tpls/todo/edit.html',\n        controller:\"todoController\"\n    })\n    // todo编辑\n    .state('todo.edit',{\n        url:\"/edit/:todoid\",\n        templateUrl:'/statics/tpls/todo/edit.html',\n        controller:\"todoController\"\n    })\n    // todo删除\n    .state('todo.delete',{\n        url:\"/delete/:todoid\",\n        templateUrl:\"/statics/tpls/todo/delete.html\",\n        controller:\"todoController\"\n    })\n    // 用户登录\n    .state('login',{\n        url:\"/user/login\",\n        templateUrl:\"/statics/tpls/user/login.html\",\n        controller:\"userController\"\n    });\n}]);\n\napp.run([\"$rootScope\",\"$state\",\"todoTools\",function($rootScope,$state,todoTools){\n    // publicUrls 不需要登录的states\n    let publicUrls = [\"todo\",\"todo.list\",\"user.login\"];\n    $rootScope.$on('$stateChangeSuccess', (event, toState, toParams, fromState, fromParams,error) => {\n        $rootScope.previousState = fromState.name;\n        // 判断用户是否登录\n        if (publicUrls.indexOf(toState.name) == -1) {\n            if (!todoTools.isLogin()) {\n                $state.go('login');\n            }\n        }\n    });\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./router.js\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/path-browserify/index.js\n ** module id = 17\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/process/browser.js\n ** module id = 18\n ** module chunks = 0\n **/"],"sourceRoot":""}